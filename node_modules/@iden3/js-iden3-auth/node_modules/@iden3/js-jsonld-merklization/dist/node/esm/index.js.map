{
  "version": 3,
  "sources": ["../../../src/lib/constants.ts", "../../../src/lib/poseidon.ts", "../../../src/lib/types/types.ts", "../../../src/lib/mt-value.ts", "../../../src/lib/utils.ts", "../../../src/lib/merklizer.ts", "../../../src/lib/rdf-dataset.ts", "../../../src/lib/dataset-idx.ts", "../../../src/lib/ref-tp.ts", "../../../src/loaders/jsonld-loader.ts", "../../../src/lib/options.ts", "../../../src/lib/merkle-tree.ts", "../../../src/lib/path.ts", "../../../src/lib/quad-arr-key.ts", "../../../src/lib/relationship.ts", "../../../src/lib/rdf-entry.ts", "../../../src/index.ts"],
  "sourcesContent": ["export const MerklizationConstants = Object.freeze({\n  ERRORS: {\n    CONTEXT_NOT_DEFINED: new Error('error: context not defined on the object'),\n    PARSED_CONTEXT_IS_NULL: new Error('error: parsed context is null'),\n    TERM_IS_NOT_DEFINED: new Error('error: term is not defined'),\n    NO_ID_ATTR: new Error('error: no @id attribute is defined'),\n    CTX_TYP_IS_EMPTY: new Error('error: ctx type is empty'),\n    FIELD_PATH_IS_EMPTY: new Error('error: filed path is empty'),\n    UNEXPECTED_ARR_ELEMENT: new Error('error: unexpected array elements'),\n    INVALID_REFERENCE_TYPE: new Error('error: invalid reference type'),\n    MULTIPLE_PARENTS_FOUND: new Error('error: multiple parents found'),\n    PARENT_NOT_FOUND: new Error('error: parent not found'),\n    GRAPH_NOT_FOUND: new Error('error: graph not found'),\n    QUAD_NOT_FOUND: new Error('error: quad not found'),\n    MT_VALUE_INCORRECT_TYPE: new Error('error: incorrect type')\n  },\n  DEFAULT_GRAPH_NODE_NAME: '@default',\n  DEFAULT_GRAPH_TERM_TYPE: 'DefaultGraph',\n  QUADS_FORMAT: 'application/n-quads',\n  DIGITS_ONLY_REGEX: /^\\d+$/,\n  Q: BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617')\n});\n", "import { MerklizationConstants } from './constants';\nimport { poseidon } from '@iden3/js-crypto';\nimport { Hasher } from './types/types';\n\nexport class PoseidonHasher implements Hasher {\n  constructor(private readonly _hasher = poseidon) {}\n\n  async hash(inp: bigint[]): Promise<bigint> {\n    return this._hasher.hash(inp);\n  }\n\n  async hashBytes(b: Uint8Array): Promise<bigint> {\n    return this._hasher.hashBytes(b);\n  }\n\n  prime(): bigint {\n    return MerklizationConstants.Q;\n  }\n}\n\nexport const DEFAULT_HASHER = new PoseidonHasher();\n", "import { Temporal } from '@js-temporal/polyfill';\nimport { DocumentLoader } from '../../loaders/jsonld-loader';\nimport { JsonLdDocument } from 'jsonld/jsonld';\nimport { Options as jsonLDOpts } from 'jsonld/jsonld-spec';\n\nexport interface Options {\n  hasher?: Hasher;\n  ipfsNodeURL?: string;\n  ipfsGatewayURL?: string;\n  documentLoader?: DocumentLoader;\n}\n\nexport interface Hasher {\n  hash: (inp: bigint[]) => Promise<bigint>;\n  hashBytes: (b: Uint8Array) => Promise<bigint>;\n  prime: () => bigint;\n}\n\nexport enum NodeType {\n  BlankNode = 'BlankNode',\n  IRI = 'NamedNode',\n  Literal = 'Literal',\n  Undefined = 'Undefined'\n}\n\nexport enum XSDNS {\n  Boolean = 'http://www.w3.org/2001/XMLSchema#boolean',\n  Integer = 'http://www.w3.org/2001/XMLSchema#integer',\n  NonNegativeInteger = 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger',\n  NonPositiveInteger = 'http://www.w3.org/2001/XMLSchema#nonPositiveInteger',\n  NegativeInteger = 'http://www.w3.org/2001/XMLSchema#negativeInteger',\n  PositiveInteger = 'http://www.w3.org/2001/XMLSchema#positiveInteger',\n  DateTime = 'http://www.w3.org/2001/XMLSchema#dateTime',\n  Double = 'http://www.w3.org/2001/XMLSchema#double'\n}\nexport const isDouble = (v: number) => String(v).includes('.') || Math.abs(v) >= 1e21;\n\nexport const canonicalDouble = (v: number) => v.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n\nexport type Value = boolean | number | Temporal.Instant | string | bigint;\n\nexport type Parts = Array<string | number>;\n\nexport interface ParsedCtx {\n  mappings: Map<string, object | string>;\n}\n\ndeclare module 'jsonld' {\n  function processContext(\n    activeCtx: ParsedCtx | null,\n    localCtx: JsonLdDocument | null,\n    opts: jsonLDOpts\n  ): Promise<ParsedCtx>;\n}\n", "import { MerklizationConstants } from './constants';\nimport { Hasher } from './types/types';\nimport { Value } from './types/types';\nimport { DEFAULT_HASHER } from './poseidon';\nimport { Temporal } from '@js-temporal/polyfill';\nimport { minMaxFromPrime } from './utils';\n\nconst bytesEncoder = new TextEncoder();\n\nexport class MtValue {\n  constructor(public readonly value: Value, private readonly h: Hasher = DEFAULT_HASHER) {}\n\n  isString(): boolean {\n    return typeof this.value === 'string';\n  }\n\n  asString(): string {\n    if (!this.isString()) {\n      throw MerklizationConstants.ERRORS.MT_VALUE_INCORRECT_TYPE;\n    }\n    return this.value.toString();\n  }\n\n  isTime(): boolean {\n    return this.value instanceof Temporal.Instant;\n  }\n\n  asTime(): Temporal.Instant {\n    if (!this.isTime()) {\n      throw MerklizationConstants.ERRORS.MT_VALUE_INCORRECT_TYPE;\n    }\n    return this.value as Temporal.Instant;\n  }\n\n  isNumber(): boolean {\n    return typeof this.value === 'number';\n  }\n\n  asNumber(): number {\n    if (!this.isNumber()) {\n      throw MerklizationConstants.ERRORS.MT_VALUE_INCORRECT_TYPE;\n    }\n    return this.value as number;\n  }\n\n  isBool(): boolean {\n    return typeof this.value === 'boolean';\n  }\n\n  asBool(): boolean {\n    if (!this.isBool()) {\n      throw MerklizationConstants.ERRORS.MT_VALUE_INCORRECT_TYPE;\n    }\n    return this.value as boolean;\n  }\n\n  mtEntry(): Promise<bigint> {\n    return MtValue.mkValueMtEntry(this.h, this.value);\n  }\n\n  isBigInt(): boolean {\n    return typeof this.value === 'bigint';\n  }\n\n  asBigInt(): bigint {\n    if (!this.isBigInt()) {\n      throw MerklizationConstants.ERRORS.MT_VALUE_INCORRECT_TYPE;\n    }\n    return this.value as bigint;\n  }\n\n  static mkValueMtEntry = (h: Hasher, v: Value): Promise<bigint> => {\n    switch (typeof v) {\n      case 'number':\n        return MtValue.mkValueInt(h, v);\n      case 'string':\n        return MtValue.mkValueString(h, v);\n      case 'boolean':\n        return MtValue.mkValueBool(h, v);\n      case 'bigint':\n        return MtValue.mkValueBigInt(h, v);\n      default: {\n        if (v instanceof Temporal.Instant) {\n          return MtValue.mkValueTime(h, v);\n        }\n        throw new Error(`error: unexpected type ${typeof v}`);\n      }\n    }\n  };\n\n  static async mkValueInt(h: Hasher, v: number | bigint): Promise<bigint> {\n    if (v >= 0) {\n      return BigInt(v);\n    }\n    return h.prime() + BigInt(v);\n  }\n\n  static mkValueUInt = (h: Hasher, v: bigint): bigint => {\n    return BigInt.asUintN(64, v);\n  };\n\n  static mkValueBool = (h: Hasher, v: boolean): Promise<bigint> => {\n    if (v) {\n      return h.hash([BigInt.asIntN(64, BigInt(1))]);\n    }\n    return h.hash([BigInt.asIntN(64, BigInt(0))]);\n  };\n\n  static mkValueString = (h: Hasher, v: string): Promise<bigint> => {\n    return h.hashBytes(bytesEncoder.encode(v));\n  };\n\n  static mkValueTime = async (h: Hasher, v: Temporal.Instant): Promise<bigint> => {\n    // convert unixTimeStamp from ms -> ns as in go implementation\n    return this.mkValueInt(h, v.epochNanoseconds);\n  };\n\n  static mkValueBigInt = async (h: Hasher, v: bigint): Promise<bigint> => {\n    const prime = h.prime();\n    if (v >= prime) {\n      throw new Error(`value is too big: ${v}`);\n    }\n    if (v < 0n) {\n      const { min } = minMaxFromPrime(prime);\n\n      if (v < min) {\n        throw new Error(`value is too small: ${v}`);\n      }\n\n      return v + prime;\n    }\n\n    return v;\n  };\n}\n", "/* eslint-disable no-case-declarations */\n// @ts-ignore-next-line\nimport { Quad } from 'n3';\nimport { MerklizationConstants } from './constants';\nimport { canonicalDouble, Value, XSDNS } from './types/types';\nimport { Temporal } from '@js-temporal/polyfill';\n\nexport function getGraphName(q: Quad): string {\n  if (!q.graph.value) {\n    return MerklizationConstants.DEFAULT_GRAPH_NODE_NAME;\n  }\n\n  if (q.graph.termType !== 'BlankNode') {\n    throw new Error('graph node is not of BlankNode type');\n  }\n\n  return q.graph.value;\n}\n\nexport const sortArr = <T>(arr: T[]): T[] => {\n  return arr.sort((a, b) => {\n    if (a < b) {\n      return -1;\n    }\n    if (a > b) {\n      return 1;\n    }\n    return 0;\n  });\n};\n\nexport const byteEncoder = new TextEncoder();\n\nexport const validateValue = (val: Value): void => {\n  switch (typeof val) {\n    case 'boolean':\n    case 'string':\n    case 'bigint':\n    case 'number':\n      return;\n    case 'object':\n      if (val instanceof Temporal.Instant) {\n        return;\n      }\n  }\n\n  throw new Error(\n    `unexpected value type ${typeof val}, expected boolean | number | Temporal.Instant | string`\n  );\n};\n\nexport interface Range {\n  min: bigint;\n  max: bigint;\n}\n\nexport const minMaxFromPrime = (prime: bigint): Range => {\n  const max = prime / 2n;\n  const min = max - prime + 1n;\n  return { min, max };\n};\n\n// return included minimum and included maximum values for integers by XSD type\nexport function minMaxByXSDType(xsdType: string, prime: bigint): Range {\n  switch (xsdType) {\n    case XSDNS.PositiveInteger:\n      return { min: 1n, max: prime - 1n };\n    case XSDNS.NonNegativeInteger:\n      return { min: 0n, max: prime - 1n };\n    case XSDNS.Integer:\n      return minMaxFromPrime(prime);\n    case XSDNS.NegativeInteger:\n      return { min: minMaxFromPrime(prime).min, max: -1n };\n    case XSDNS.NonPositiveInteger:\n      return { min: minMaxFromPrime(prime).min, max: 0n };\n    default:\n      throw new Error(`unsupported XSD type: ${xsdType}`);\n  }\n}\n\nexport const convertStringToXsdValue = (\n  dataType: string,\n  valueStr: string,\n  maxFieldValue: bigint\n): Value => {\n  switch (dataType) {\n    case XSDNS.Boolean:\n      switch (valueStr) {\n        case 'false':\n        case '0':\n          return false;\n        case 'true':\n        case '1':\n          return true;\n        default:\n          throw new Error('incorrect boolean value');\n      }\n    case XSDNS.Integer:\n    case XSDNS.NonNegativeInteger:\n    case XSDNS.NonPositiveInteger:\n    case XSDNS.NegativeInteger:\n    case XSDNS.PositiveInteger:\n      const int = BigInt(valueStr);\n\n      const { min, max } = minMaxByXSDType(dataType, maxFieldValue);\n\n      if (int > max) {\n        throw new Error(`integer exceeds maximum value: ${int}`);\n      }\n\n      if (int < min) {\n        throw new Error(`integer is below minimum value: ${int}`);\n      }\n\n      return int;\n\n    case XSDNS.DateTime: {\n      if (isNaN(Date.parse(valueStr))) {\n        throw new Error(`error: error parsing time string ${valueStr}`);\n      }\n      const dateRegEx = /^\\d{4}-\\d{2}-\\d{2}$/;\n      if (dateRegEx.test(valueStr)) {\n        return Temporal.Instant.from(new Date(valueStr).toISOString());\n      }\n      return Temporal.Instant.from(valueStr);\n    }\n    case XSDNS.Double:\n      return canonicalDouble(parseFloat(valueStr));\n    default:\n      return valueStr;\n  }\n};\n\nexport const convertAnyToString = (v: unknown, datatype: string): string => {\n  const isDoubleType = datatype === XSDNS.Double;\n  switch (typeof v) {\n    case 'string':\n      return isDoubleType ? canonicalDouble(parseFloat(v)) : v;\n    case 'boolean':\n      return `${v}`;\n    case 'number': {\n      return isDoubleType ? canonicalDouble(v) : `${v}`;\n    }\n    default:\n      throw new Error('unsupported type');\n  }\n};\n", "import { Hasher, Value, Options } from './types/types';\nimport {\n  compact,\n  NodeObject,\n  JsonLdDocument,\n  ContextDefinition,\n  Options as JsonLdOptions\n} from 'jsonld';\nimport { Merkletree, Hash, Proof } from '@iden3/js-merkletree';\nimport { RDFDataset } from './rdf-dataset';\nimport { DEFAULT_HASHER } from './poseidon';\nimport { addEntriesToMerkleTree, getMerkleTreeInitParam } from './merkle-tree';\nimport { RDFEntry } from './rdf-entry';\nimport { Path } from './path';\nimport { MtValue } from './mt-value';\nimport { convertAnyToString, convertStringToXsdValue } from './utils';\nimport { getDocumentLoader, getHasher } from './options';\n\nexport class Merklizer {\n  constructor(\n    public readonly srcDoc: string | null = null,\n    public readonly mt: Merkletree | null = null,\n    public readonly hasher: Hasher = DEFAULT_HASHER,\n    public readonly entries: Map<string, RDFEntry> = new Map(),\n    public compacted: NodeObject | null = null,\n    public documentLoader = getDocumentLoader()\n  ) {\n    if (!mt) {\n      const { db, writable, maxLevels } = getMerkleTreeInitParam();\n      this.mt = new Merkletree(db, writable, maxLevels);\n    }\n  }\n\n  async proof(p: Path): Promise<{ proof: Proof; value?: MtValue }> {\n    const kHash = await p.mtEntry();\n    if (!this.mt) {\n      throw new Error('Merkle tree is not initialized');\n    }\n    const { proof } = await this.mt.generateProof(kHash);\n\n    if (proof.existence) {\n      if (!this.entries.has(kHash.toString())) {\n        throw new Error('error: [assertion] no entry found while existence is true');\n      }\n      const entry = this.entries.get(kHash.toString());\n      if (!entry) {\n        throw new Error('entry not found');\n      }\n\n      const value = new MtValue(entry.value, this.hasher);\n      return { proof, value };\n    }\n\n    return { proof };\n  }\n\n  mkValue(val: Value): MtValue {\n    return new MtValue(val, this.hasher);\n  }\n\n  async resolveDocPath(path: string, opts?: Options): Promise<Path> {\n    if (!this.srcDoc) {\n      throw new Error('Source document is not initialized');\n    }\n    const realPath = await Path.fromDocument(null, this.srcDoc, path, opts);\n    realPath.hasher = this.hasher;\n    return realPath;\n  }\n\n  async entry(path: Path): Promise<RDFEntry> {\n    const key = await path.mtEntry();\n    const e = this.entries.get(key.toString());\n    if (!e) {\n      throw new Error('entry not found');\n    }\n\n    return e;\n  }\n\n  // JSONLDType returns the JSON-LD type of the given path. If there is no literal\n  // by this path, it returns an error.\n  async jsonLDType(path: Path): Promise<string> {\n    const entry = await this.entry(path);\n    return entry.dataType;\n  }\n\n  async root(): Promise<Hash> {\n    if (!this.mt) {\n      throw new Error('Merkle tree is not initialized');\n    }\n    return this.mt.root();\n  }\n\n  rawValue(path: Path): Value {\n    let parts = path.parts;\n    if (!this.compacted) {\n      throw new Error('Compact document is not initialized');\n    }\n    let obj: NodeObject = this.compacted;\n    const traversedParts: string[] = [];\n    const currentPath = (): string => traversedParts.join(' / ');\n\n    while (parts.length > 0) {\n      const p = parts[0];\n      if (typeof p === 'string') {\n        traversedParts.push(p);\n        obj = (obj[p] ?? ((obj['@graph'] ?? {}) as NodeObject)[p]) as NodeObject;\n        if (!obj) {\n          throw new Error('value not found');\n        }\n      } else if (typeof p === 'number') {\n        traversedParts.push(p.toString());\n        obj = this.rvExtractArrayIdx(obj, p) as NodeObject;\n      } else {\n        throw new Error(`unexpected type of path ${currentPath()}`);\n      }\n      parts = parts.slice(1);\n    }\n\n    if (typeof obj['@value'] !== 'undefined') {\n      return obj['@value'] as Value;\n    }\n\n    return obj as unknown as Value;\n  }\n\n  private rvExtractArrayIdx(obj: unknown, idx: number): unknown {\n    const isArray = Array.isArray(obj);\n    if (!isArray) {\n      throw new Error('expected array');\n    }\n    if (idx < 0 || idx >= obj.length) {\n      throw new Error('index is out of range');\n    }\n    return obj[idx];\n  }\n\n  static async merklizeJSONLD(docStr: string, opts?: Options): Promise<Merklizer> {\n    const hasher = getHasher(opts);\n    const documentLoader = getDocumentLoader(opts);\n    const mz = new Merklizer(docStr, null, hasher, new Map(), null, documentLoader);\n    if (!mz) {\n      throw new Error('Merklizer is not initialized');\n    }\n    if (!mz.srcDoc) {\n      throw new Error('Source document is not initialized');\n    }\n    const doc = JSON.parse(mz.srcDoc);\n    const dataset = await RDFDataset.fromDocument(doc, documentLoader);\n    const entries = await RDFEntry.fromDataSet(dataset, hasher);\n\n    for (const e of entries) {\n      const k = await e.getKeyMtEntry();\n      mz.entries.set(k.toString(), e);\n    }\n\n    if (!mz.mt) {\n      throw new Error('Merkle tree is not initialized');\n    }\n    await addEntriesToMerkleTree(mz.mt, entries);\n    // input: JsonLdDocument, ctx?: ContextDefinition, options?: Options.Compact\n    mz.compacted = await compact(\n      doc as JsonLdDocument,\n      {} as ContextDefinition,\n      {\n        documentLoader,\n        base: null,\n        compactArrays: true,\n        compactToRelative: true\n      } as unknown as JsonLdOptions.Compact\n    );\n\n    return mz;\n  }\n\n  static async hashValue(dataType: string, value: unknown): Promise<bigint> {\n    return this.hashValueWithHasher(DEFAULT_HASHER, dataType, value);\n  }\n\n  private static async hashValueWithHasher(\n    h: Hasher,\n    dataType: string,\n    value: unknown\n  ): Promise<bigint> {\n    const valueStr = convertAnyToString(value, dataType);\n\n    const xsdValue = convertStringToXsdValue(dataType, valueStr, h.prime());\n\n    return await MtValue.mkValueMtEntry(h, xsdValue);\n  }\n\n  get options(): Options {\n    return {\n      hasher: this.hasher,\n      documentLoader: this.documentLoader\n    };\n  }\n}\n", "import { MerklizationConstants } from './constants';\n// @ts-ignore-next-line\nimport { Quad, Parser } from 'n3';\nimport { canonize, JsonLdDocument } from 'jsonld';\nimport { DocumentLoader } from '../loaders/jsonld-loader';\nimport { DatasetIdx } from './dataset-idx';\nimport { getGraphName } from './utils';\nimport { RefTp } from './ref-tp';\nimport { NodeType } from './types/types';\nimport { getDocumentLoader } from './options';\n\nexport class RDFDataset {\n  constructor(public readonly graphs: Map<string, Quad[]> = new Map()) {}\n  // assert consistency of dataset and validate that only\n  // quads we support contains in dataset.\n  static assertDatasetConsistency = (ds: RDFDataset): void => {\n    for (const [graph, quads] of ds.graphs) {\n      for (const q of quads) {\n        if (!graph) {\n          throw new Error('empty graph name');\n        }\n        if (graph === MerklizationConstants.DEFAULT_GRAPH_NODE_NAME && q.graph.id) {\n          throw new Error('graph should be nil for @default graph');\n        }\n        if (!q.graph.id && graph !== MerklizationConstants.DEFAULT_GRAPH_NODE_NAME) {\n          throw new Error('graph should not be nil for non-@default graph');\n        }\n      }\n    }\n  };\n\n  static async fromDocument(\n    doc: JsonLdDocument,\n    documentLoader: DocumentLoader = getDocumentLoader()\n  ): Promise<RDFDataset> {\n    const normalizedData = await canonize(doc, {\n      format: MerklizationConstants.QUADS_FORMAT,\n      documentLoader\n    });\n    const parser = new Parser({ format: MerklizationConstants.QUADS_FORMAT });\n\n    const quads: Quad[] = parser.parse(normalizedData);\n    const ds = new RDFDataset();\n    for (const q of quads) {\n      const graphName =\n        q.graph.termType === MerklizationConstants.DEFAULT_GRAPH_TERM_TYPE\n          ? MerklizationConstants.DEFAULT_GRAPH_NODE_NAME\n          : q.graph.value;\n      const graphQuads = ds.graphs.get(graphName) ?? [];\n      graphQuads.push(q);\n      ds.graphs.set(graphName, graphQuads);\n    }\n\n    return ds;\n  }\n\n  static getQuad(ds: RDFDataset, idx: DatasetIdx): Quad {\n    const quads = ds.graphs.get(idx.graphName);\n    if (!quads) {\n      throw MerklizationConstants.ERRORS.GRAPH_NOT_FOUND;\n    }\n    if (idx.idx >= quads.length) {\n      throw MerklizationConstants.ERRORS.QUAD_NOT_FOUND;\n    }\n    return quads[idx.idx];\n  }\n\n  static iterGraphsOrdered(ds: RDFDataset, callback: (graphName: string, quads: Quad[]) => void) {\n    const graphNames: string[] = [];\n    for (const graphName of ds.graphs.keys()) {\n      graphNames.push(graphName);\n    }\n    graphNames.sort((a, b) => a.localeCompare(b));\n\n    for (const graphName of graphNames) {\n      const quads = ds.graphs.get(graphName);\n      if (!quads) {\n        continue;\n      }\n      callback(graphName, quads);\n    }\n  }\n\n  static findParent(ds: RDFDataset, q: Quad): DatasetIdx | undefined {\n    const parent = RDFDataset.findParentInsideGraph(ds, q);\n    if (parent) {\n      return parent;\n    }\n\n    return RDFDataset.findGraphParent(ds, q);\n  }\n\n  static findParentInsideGraph(ds: RDFDataset, q: Quad): DatasetIdx | undefined {\n    const graphName = getGraphName(q);\n    let result: DatasetIdx | undefined;\n    const quads = ds.graphs.get(graphName);\n    if (!quads) {\n      return undefined;\n    }\n\n    const qKey = RefTp.getRefFromQuad(q.subject);\n    if (qKey.tp === NodeType.Undefined) {\n      return undefined;\n    }\n    let found = false;\n    // var result datasetIdx\n    for (let idx = 0; idx < quads.length; idx++) {\n      const quad = quads[idx];\n      if (quad.equals(q)) {\n        continue;\n      }\n\n      const objKey = RefTp.getRefFromQuad(quad.object);\n      if (objKey.tp === NodeType.Undefined) {\n        continue;\n      }\n\n      if (qKey?.tp === objKey?.tp && qKey?.val === objKey?.val) {\n        if (found) {\n          throw MerklizationConstants.ERRORS.MULTIPLE_PARENTS_FOUND;\n        }\n        found = true;\n        result = new DatasetIdx(graphName, idx);\n      }\n    }\n    return result;\n  }\n\n  static findGraphParent(ds: RDFDataset, q: Quad): DatasetIdx | undefined {\n    if (!q.graph) {\n      return undefined;\n    }\n\n    const qKey = RefTp.getRefFromQuad(q.graph);\n    if (qKey.tp === NodeType.Undefined) {\n      return undefined;\n    }\n    if (qKey.tp !== NodeType.BlankNode) {\n      throw new Error('graph parent can only be a blank node');\n    }\n\n    let found = false;\n    let result: DatasetIdx | undefined;\n    for (const [graphName, quads] of ds.graphs) {\n      for (let idx = 0; idx < quads.length; idx++) {\n        const quad = quads[idx];\n\n        if (quad.equals(q)) {\n          continue;\n        }\n\n        const objKey = RefTp.getRefFromQuad(quad.object);\n        if (objKey.tp === NodeType.Undefined) {\n          continue;\n        }\n\n        if (qKey.toString() == objKey.toString()) {\n          if (found) {\n            throw MerklizationConstants.ERRORS.MULTIPLE_PARENTS_FOUND;\n          }\n          found = true;\n          result = new DatasetIdx(graphName, idx);\n        }\n      }\n    }\n\n    if (found) {\n      return result;\n    }\n    throw MerklizationConstants.ERRORS.PARENT_NOT_FOUND;\n  }\n}\n", "export class DatasetIdx {\n  constructor(public readonly graphName: string, public readonly idx: number) {}\n\n  toString(): string {\n    return `${this.graphName}:${this.idx}`;\n  }\n}\n", "// @ts-ignore-next-line\nimport { Quad } from 'n3';\nimport { NodeType } from './types/types';\n\nexport class RefTp {\n  constructor(public readonly tp: NodeType, public readonly val: unknown) {}\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static getRefFromQuad(n: Quad): RefTp {\n    if (n.termType === NodeType.IRI) {\n      return new RefTp(NodeType.IRI, n.value);\n    }\n    if (n.termType === NodeType.BlankNode) {\n      return new RefTp(NodeType.BlankNode, n.value);\n    }\n    return new RefTp(NodeType.Undefined, '');\n  }\n}\n", "import { JsonLd, RemoteDocument, Url } from 'jsonld/jsonld-spec';\n// @ts-ignore-next-line\nimport { parseLinkHeader } from 'jsonld/lib/util';\n// @ts-ignore-next-line\nimport { LINK_HEADER_CONTEXT } from 'jsonld/lib/constants';\n// @ts-ignore-next-line\nimport JsonLdError from 'jsonld/lib/JsonLdError';\n// @ts-ignore-next-line\nimport { prependBase } from 'jsonld/lib/url';\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          [secure]: require all URLs to use HTTPS. (default: false)\n *          [strictSSL]: true to require SSL certificates to be valid,\n *            false not to. (default: true)\n *          [maxRedirects]: the maximum number of redirects to permit.\n *            (default: none)\n *          [headers]: an object (map) of headers which will be passed as\n *            request headers for the requested document. Accept is not\n *            allowed. (default: none).\n *          [httpAgent]: a Node.js `http.Agent` to use with 'http' requests.\n *            (default: none)\n *          [httpsAgent]: a Node.js `https.Agent` to use with 'https' requests.\n *            (default: An agent with rejectUnauthorized to the strictSSL\n *            value.ts)\n *\n * @return the node document loader.\n */\nexport class JsonLDLoader {\n  async loadDocument(url: string, redirects: string[] = []): Promise<RemoteDocument> {\n    const isHttp = url.startsWith('http:');\n    const isHttps = url.startsWith('https:');\n    if (!isHttp && !isHttps) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.',\n        'jsonld.InvalidUrl',\n        { code: 'loading document failed', url }\n      );\n    }\n\n    // TODO: disable cache until HTTP caching implemented\n    // let doc = null; //cache.get(url);\n    // if (doc !== null) {\n    //   return doc;\n    // }\n\n    let alternate = null;\n\n    const { res, body } = await _fetch({ url });\n    const doc = { contextUrl: undefined, documentUrl: url, document: body || null };\n\n    // handle error\n    if (res.status >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${res.statusText}`,\n        'jsonld.InvalidUrl',\n        {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.status\n        }\n      );\n    }\n    const link = res.headers.get('link');\n    let location = res.headers.get('location');\n    const contentType = res.headers.get('content-type');\n\n    // handle Link Header\n    if (link && contentType !== 'application/ld+json' && contentType !== 'application/json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if (Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          { code: 'multiple context link headers', url }\n        );\n      }\n      if (linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders.alternate;\n      if (\n        alternate &&\n        alternate['type'] == 'application/ld+json' &&\n        !(contentType || '').match(/^application\\/(\\w*\\+)?json$/)\n      ) {\n        location = prependBase(url, alternate['target']);\n      }\n    }\n\n    // handle redirect\n    if ((alternate || (res.status >= 300 && res.status < 400)) && location) {\n      if (redirects.length === -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects',\n          {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.status,\n            redirects\n          }\n        );\n      }\n      if (redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected',\n          {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.status,\n            redirects\n          }\n        );\n      }\n      redirects.push(url);\n      // location can be relative, turn into full url\n      const nextUrl = new URL(location, url).href;\n      return this.loadDocument(nextUrl, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: undefined, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc as RemoteDocument;\n  }\n}\n\nconst ipfsMethodCat = 'cat';\n\nexport function normalizeIPFSNodeURL(ipfsNodeURL: string, apiMethod: string): string {\n  const apiSuffix = '/api/v0';\n\n  while (ipfsNodeURL.endsWith('/')) {\n    ipfsNodeURL = ipfsNodeURL.slice(0, -1);\n  }\n\n  if (!ipfsNodeURL.endsWith(apiSuffix)) {\n    ipfsNodeURL += apiSuffix;\n  }\n\n  return ipfsNodeURL + '/' + apiMethod;\n}\n\nfunction trimRightSlash(url: string): string {\n  while (url.endsWith('/')) {\n    url = url.slice(0, -1);\n  }\n  return url;\n}\n\nfunction trimLeftSlash(url: string): string {\n  while (url.startsWith('/')) {\n    url = url.slice(1);\n  }\n  return url;\n}\n\nfunction buildIpfsGatewayURL(ipfsGatewayURL: string, documentURL: string): string {\n  return trimRightSlash(ipfsGatewayURL) + '/ipfs/' + trimLeftSlash(documentURL);\n}\n\nasync function loadIPFS(\n  url: string,\n  ipfsNodeURL: string | undefined = undefined,\n  ipfsGatewayURL: string | undefined = undefined\n): Promise<RemoteDocument> {\n  const documentURL = ipfsURLPrefix + url;\n\n  if (!ipfsNodeURL && !ipfsGatewayURL) {\n    throw new JsonLdError('IPFS is not configured', 'jsonld.IPFSNotConfigured', {\n      code: 'loading document failed',\n      url: documentURL\n    });\n  }\n\n  if (ipfsNodeURL) {\n    return await loadFromIPFSNode(url, ipfsNodeURL);\n  } else {\n    return await loadFromIPFSGateway(url, ipfsGatewayURL);\n  }\n}\n\nasync function loadFromIPFSNode(url: string, ipfsNodeURL: string): Promise<RemoteDocument> {\n  const catRequestURL = new URL(normalizeIPFSNodeURL(ipfsNodeURL, ipfsMethodCat));\n  catRequestURL.searchParams.append('arg', url);\n\n  const { res, body } = await _fetch({ url: catRequestURL, method: 'POST' });\n\n  if (res.status != 200) {\n    throw new Error(`Error calling IPFS node: [${res.status}] ${res.statusText}\\n${body}`);\n  }\n\n  return {\n    contextUrl: undefined,\n    document: (body as JsonLd) || null,\n    documentUrl: ipfsURLPrefix + url\n  };\n}\n\nasync function loadFromIPFSGateway(\n  url: string,\n  ipfsGatewayURL: string | undefined = undefined\n): Promise<RemoteDocument> {\n  if (!ipfsGatewayURL) {\n    throw new JsonLdError('IPFS gateway is not configured', 'jsonld.IPFSNotConfigured', {\n      code: 'loading document failed',\n      url: ipfsURLPrefix + url\n    });\n  }\n  const loader = new JsonLDLoader();\n  const document = await loader.loadDocument(buildIpfsGatewayURL(ipfsGatewayURL, url), []);\n  document.contextUrl = undefined;\n  document.documentUrl = ipfsURLPrefix + url;\n  return document;\n}\n\nasync function _fetch({ url, method }: { url: string | URL; method?: string }): Promise<{\n  res: Response;\n  body: unknown;\n}> {\n  const options: Record<string, unknown> = {};\n  if (typeof method !== 'undefined') {\n    options['method'] = method;\n  }\n  try {\n    url = new URL(url);\n    if (url.username && url.password) {\n      options['headers'] = {\n        ...(options['headers'] ?? {}),\n        authorization: `Basic ${btoa(url.username + ':' + url.password)}`\n      };\n      url = removeCredentialsFromURL(url);\n    }\n\n    const res = await fetch(url, options);\n    if (res.status >= 300 && res.status < 400) {\n      return { res, body: null };\n    }\n    const text = await res.text();\n    if (text && text.length > 0 && text.startsWith('{')) {\n      return { res, body: JSON.parse(text) };\n    }\n    return { res, body: text };\n  } catch (e: unknown) {\n    // HTTP errors have a response in them\n    // ky considers redirects HTTP errors\n    if (e instanceof Error && 'response' in e) {\n      return { res: e.response as Response, body: null };\n    }\n    throw new JsonLdError(\n      'URL could not be dereferenced, an error occurred.',\n      'jsonld.LoadDocumentError',\n      { code: 'loading document failed', url, cause: e }\n    );\n  }\n}\n\nfunction removeCredentialsFromURL(url: string | URL): string {\n  const urlObj = new URL(url);\n  urlObj.username = '';\n  urlObj.password = '';\n  return urlObj.href;\n}\nexport type DocumentLoader = (url: Url) => Promise<RemoteDocument>;\n\nconst ipfsURLPrefix = 'ipfs://';\n\nexport const getJsonLdDocLoader = (\n  ipfsNodeURL: string | undefined = undefined,\n  ipfsGatewayURL: string | undefined = undefined\n): DocumentLoader => {\n  return async (url: Url): Promise<RemoteDocument> => {\n    if (url.startsWith(ipfsURLPrefix)) {\n      const ipfsURL: string = url.slice(ipfsURLPrefix.length);\n      return await loadIPFS(ipfsURL, ipfsNodeURL, ipfsGatewayURL);\n    }\n\n    const loader = new JsonLDLoader();\n    return loader.loadDocument(url, []);\n  };\n};\n", "import { Hasher, Options } from './types/types';\nimport { DEFAULT_HASHER } from './poseidon';\nimport { getJsonLdDocLoader, DocumentLoader } from '../loaders/jsonld-loader';\n\nexport function getHasher(opts?: Options): Hasher {\n  return opts?.hasher ?? DEFAULT_HASHER;\n}\n\nexport function getDocumentLoader(opts?: Options): DocumentLoader {\n  return opts?.documentLoader ?? getJsonLdDocLoader(opts?.ipfsNodeURL, opts?.ipfsGatewayURL);\n}\n", "import { InMemoryDB, str2Bytes, Merkletree } from '@iden3/js-merkletree';\nimport { RDFEntry } from './rdf-entry';\n\nexport const getMerkleTreeInitParam = (\n  prefix = '',\n  writable = true,\n  maxLevels = 40\n): {\n  db: InMemoryDB;\n  writable: boolean;\n  maxLevels: number;\n} => {\n  return {\n    db: new InMemoryDB(str2Bytes(prefix)),\n    writable,\n    maxLevels\n  };\n};\n\nexport const addEntriesToMerkleTree = async (\n  mt: Merkletree,\n  entries: RDFEntry[]\n): Promise<void> => {\n  for (const e of entries) {\n    const { k, v } = await e.getKeyValueMTEntry();\n    await mt.add(k, v);\n  }\n};\n", "import { MerklizationConstants } from './constants';\nimport { Hasher, Options, Parts, ParsedCtx } from './types/types';\nimport { processContext, JsonLdDocument } from 'jsonld';\nimport { DEFAULT_HASHER } from './poseidon';\nimport { byteEncoder, sortArr } from './utils';\nimport { getDocumentLoader, getHasher } from './options';\n\nexport class Path {\n  constructor(public parts: Parts = [], public hasher: Hasher = DEFAULT_HASHER) {}\n\n  reverse(): Parts {\n    return this.parts.reverse();\n  }\n\n  append(p: Parts): void {\n    this.parts = [...this.parts, ...p];\n  }\n\n  prepend(p: Parts): void {\n    this.parts = [...p, ...this.parts];\n  }\n\n  async mtEntry(): Promise<bigint> {\n    const h = this.hasher ?? DEFAULT_HASHER;\n\n    const keyParts: bigint[] = new Array<bigint>(this.parts.length).fill(BigInt(0));\n\n    for (let i = 0; i < this.parts.length; i += 1) {\n      const p = this.parts[i];\n      if (typeof p === 'string') {\n        const b = byteEncoder.encode(p);\n        keyParts[i] = await h.hashBytes(b);\n      } else if (typeof p === 'number') {\n        keyParts[i] = BigInt(p);\n      } else {\n        throw new Error(`error: unexpected type ${typeof p}`);\n      }\n    }\n\n    return h.hash(keyParts);\n  }\n\n  async pathFromContext(docStr: string, path: string, opts?: Options): Promise<void> {\n    const doc = JSON.parse(docStr);\n    if (!doc['@context']) {\n      throw MerklizationConstants.ERRORS.CONTEXT_NOT_DEFINED;\n    }\n    const jsonldOpts = { documentLoader: getDocumentLoader(opts) };\n    const emptyCtx = await processContext(null, null, jsonldOpts);\n    let parsedCtx = await processContext(emptyCtx, doc, jsonldOpts);\n\n    const parts = path.split('.');\n\n    for (const i in parts) {\n      const p = parts[i];\n      if (MerklizationConstants.DIGITS_ONLY_REGEX.test(p)) {\n        this.parts.push(parseInt(p));\n      } else {\n        const m = parsedCtx.mappings.get(p);\n        if (typeof m !== 'object') {\n          throw MerklizationConstants.ERRORS.TERM_IS_NOT_DEFINED;\n        }\n\n        const id = (m as { '@id': string | undefined })['@id'];\n        if (!id) {\n          throw MerklizationConstants.ERRORS.NO_ID_ATTR;\n        }\n\n        const nextCtx = (m as { '@context': string | undefined })['@context'];\n        if (nextCtx) {\n          parsedCtx = await processContext(parsedCtx, m, jsonldOpts);\n        }\n        this.parts.push(id);\n      }\n    }\n  }\n\n  async typeFromContext(ctxStr: string, path: string, opts?: Options): Promise<string> {\n    const ctxObj = JSON.parse(ctxStr);\n\n    if (!('@context' in ctxObj)) {\n      throw MerklizationConstants.ERRORS.PARSED_CONTEXT_IS_NULL;\n    }\n\n    const jsonldOpts = { documentLoader: getDocumentLoader(opts) };\n    const emptyCtx = await processContext(null, null, jsonldOpts);\n    let parsedCtx = await processContext(emptyCtx, ctxObj, jsonldOpts);\n\n    const parts = path.split('.');\n\n    for (const i in parts) {\n      const p = parts[i];\n      const expP = expandType(parsedCtx, p);\n      if (expP.hasContext) {\n        parsedCtx = await processContext(parsedCtx, expP.typeDef, jsonldOpts);\n      }\n      this.parts.push(expP['@id']);\n    }\n\n    return Path.getTypeMapping(parsedCtx, parts[parts.length - 1]);\n  }\n\n  private static getTypeMapping(ctx: ParsedCtx, prop: string): string {\n    let rval = '';\n    const defaultT = ctx.mappings.get('@type');\n    if (defaultT) {\n      rval = defaultT as string;\n    }\n    const propDef = ctx.mappings.get(prop);\n    if (propDef && (propDef as { '@type': string | undefined })['@type']) {\n      rval = (propDef as { '@type': string | undefined })['@type'] as string;\n    }\n    return rval;\n  }\n\n  static newPath = (parts: Parts): Path => {\n    const p = new Path();\n    p.append(parts);\n    return p;\n  };\n\n  private static async pathFromDocument(\n    ldCTX: ParsedCtx | null,\n    doc: JsonLdDocument,\n    pathParts: string[],\n    acceptArray: boolean,\n    opts?: Options\n  ): Promise<Parts> {\n    if (pathParts.length === 0) {\n      return [];\n    }\n\n    const term = pathParts[0];\n    const newPathParts = pathParts.slice(1);\n    const jsonldOpts = { documentLoader: getDocumentLoader(opts) };\n\n    if (MerklizationConstants.DIGITS_ONLY_REGEX.test(term)) {\n      const num = parseInt(term);\n      const moreParts = await Path.pathFromDocument(ldCTX, doc, newPathParts, true, opts);\n\n      return [num, ...moreParts];\n    }\n\n    if (typeof doc !== 'object') {\n      throw new Error(`error: expected type object got ${typeof doc}`);\n    }\n\n    if (Array.isArray(doc)) {\n      if (!doc.length) {\n        throw new Error(\"error: can't generate path on zero-sized array\");\n      }\n      if (!acceptArray) {\n        throw MerklizationConstants.ERRORS.UNEXPECTED_ARR_ELEMENT;\n      }\n\n      return Path.pathFromDocument(ldCTX, doc[0], pathParts, false, opts);\n    }\n\n    if ('@context' in doc) {\n      if (ldCTX) {\n        ldCTX = await processContext(ldCTX, doc, jsonldOpts);\n      } else {\n        const emptyCtx = await processContext(null, null, jsonldOpts);\n        ldCTX = await processContext(emptyCtx, doc, jsonldOpts);\n      }\n    }\n\n    const elemKeys = sortArr(Object.keys(doc));\n    const typedScopedCtx = ldCTX;\n\n    for (const k in elemKeys) {\n      const key = elemKeys[k];\n      if (key !== '@type') {\n        const keyCtx = ldCTX?.mappings.get(key);\n        if (typeof keyCtx !== 'object') {\n          continue;\n        }\n        if ((keyCtx as { '@id': string | undefined })['@id'] !== '@type') {\n          continue;\n        }\n      }\n\n      let types: string[] = [];\n\n      const docKey = (doc as Record<string, unknown>)[key];\n      if (Array.isArray(docKey)) {\n        docKey.forEach((e) => {\n          if (typeof e !== 'string') {\n            throw new Error(`error: @type value must be an array of strings: ${typeof e}`);\n          }\n          types.push(e as string);\n          types = sortArr(types);\n        });\n      } else if (typeof docKey === 'string') {\n        types.push(docKey);\n      } else {\n        throw new Error(`error: unexpected @type field type: ${typeof docKey}`);\n      }\n\n      for (const tt of types) {\n        const td = typedScopedCtx?.mappings.get(tt);\n        if (typeof td === 'object' && '@context' in td) {\n          ldCTX = await processContext(ldCTX, td as JsonLdDocument, jsonldOpts);\n        }\n      }\n\n      break;\n    }\n\n    const expTerm = expandType(ldCTX, term);\n    if (expTerm.hasContext) {\n      if (ldCTX) {\n        ldCTX = await processContext(ldCTX, expTerm.typeDef, jsonldOpts);\n      } else {\n        const emptyCtx = await processContext(null, null, jsonldOpts);\n        ldCTX = await processContext(emptyCtx, expTerm.typeDef, jsonldOpts);\n      }\n    }\n    const moreParts = await Path.pathFromDocument(\n      ldCTX,\n      (doc as Record<string, JsonLdDocument>)[term] as JsonLdDocument,\n      newPathParts,\n      true,\n      opts\n    );\n\n    return [expTerm['@id'], ...moreParts];\n  }\n\n  static async newPathFromCtx(docStr: string, path: string, opts?: Options): Promise<Path> {\n    const p = new Path([], getHasher(opts));\n    await p.pathFromContext(docStr, path, opts);\n    return p;\n  }\n\n  static getContextPathKey = async (\n    docStr: string,\n    ctxTyp: string,\n    fieldPath: string,\n    opts?: Options\n  ): Promise<Path> => {\n    if (ctxTyp === '') {\n      throw MerklizationConstants.ERRORS.CTX_TYP_IS_EMPTY;\n    }\n    if (fieldPath === '') {\n      throw MerklizationConstants.ERRORS.FIELD_PATH_IS_EMPTY;\n    }\n\n    const fullPath = await Path.newPathFromCtx(docStr, `${ctxTyp}.${fieldPath}`, opts);\n    const typePath = await Path.newPathFromCtx(docStr, ctxTyp, opts);\n    return new Path(fullPath.parts.slice(typePath.parts.length));\n  };\n\n  static async fromDocument(\n    ldCTX: ParsedCtx | null,\n    docStr: string,\n    path: string,\n    opts?: Options\n  ): Promise<Path> {\n    const doc = JSON.parse(docStr);\n    const pathParts = path.split('.');\n    if (pathParts.length === 0) {\n      throw MerklizationConstants.ERRORS.FIELD_PATH_IS_EMPTY;\n    }\n\n    const p = await Path.pathFromDocument(ldCTX, doc, pathParts, false, opts);\n    return new Path(p, getHasher(opts));\n  }\n\n  static async newTypeFromContext(\n    contextStr: string,\n    path: string,\n    opts?: Options\n  ): Promise<string> {\n    const p = new Path([], getHasher(opts));\n    return await p.typeFromContext(contextStr, path, opts);\n  }\n\n  static async getTypeIDFromContext(\n    ctxStr: string,\n    typeName: string,\n    opts?: Options\n  ): Promise<string> {\n    const ctxObj = JSON.parse(ctxStr);\n    const jsonldOpts = { documentLoader: getDocumentLoader(opts) };\n    const emptyCtx = await processContext(null, null, jsonldOpts);\n    const parsedCtx = await processContext(emptyCtx, ctxObj, jsonldOpts);\n    const typeDef = parsedCtx.mappings.get(typeName);\n\n    if (!typeDef) {\n      throw new Error(`looks like ${typeName} is not a type`);\n    }\n\n    const typeID = (typeDef as { '@id': string | undefined })['@id'];\n    if (!typeID) {\n      throw new Error(`@id attribute is not found for type ${typeName}`);\n    }\n\n    // const typeIDStr = typeID.(string)\n    if (typeof typeID !== 'string') {\n      throw new Error(`@id attribute is not a string for type ${typeName}`);\n    }\n\n    return typeID;\n  }\n}\n\ninterface CtxTypeAttrs {\n  '@id': string;\n  hasContext: boolean;\n  typeDef: object;\n}\n\nfunction expandType(ctx: ParsedCtx | null, term: string): CtxTypeAttrs {\n  const m = ctx?.mappings.get(term);\n  if (typeof m !== 'object') {\n    throw MerklizationConstants.ERRORS.TERM_IS_NOT_DEFINED;\n  }\n\n  const id = (m as { '@id': string | undefined })['@id'];\n  if (!id) {\n    throw MerklizationConstants.ERRORS.NO_ID_ATTR;\n  }\n\n  if (typeof id !== 'string') {\n    throw new Error(`error: @id attr is not of type string: ${typeof id}`);\n  }\n\n  return {\n    '@id': id,\n    hasContext: '@context' in m,\n    typeDef: m\n  };\n}\n", "// @ts-ignore-next-line\nimport { Quad } from 'n3';\nimport { getGraphName } from './utils';\nimport { RefTp } from './ref-tp';\nimport { NodeType } from './types/types';\n\nexport class QuadArrKey {\n  subject: RefTp;\n  predicate: unknown;\n  graph: string;\n\n  constructor(q: Quad) {\n    this.graph = getGraphName(q);\n    const s = q.subject;\n    switch (s.termType) {\n      case NodeType.IRI:\n        this.subject = { tp: NodeType.IRI, val: s.value };\n        break;\n      case NodeType.BlankNode:\n        this.subject = { tp: NodeType.BlankNode, val: s.value };\n        break;\n      default:\n        throw new Error('invalid subject type');\n    }\n\n    if (q.predicate.termType !== NodeType.IRI) {\n      throw new Error('invalid predicate type');\n    }\n    this.predicate = q.predicate.value;\n  }\n\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static countEntries = (nodes: Quad[]): Map<string, number> => {\n    const res: Map<string, number> = new Map();\n    for (const q of nodes) {\n      const key = new QuadArrKey(q);\n      let c = res.get(key.toString()) ?? 0;\n      res.set(key.toString(), ++c);\n    }\n    return res;\n  };\n}\n", "import { Hasher, NodeType } from './types/types';\n// @ts-ignore-next-line\nimport { Quad } from 'n3';\nimport { Path } from './path';\nimport { RefTp } from './ref-tp';\nimport { QuadArrKey } from './quad-arr-key';\nimport { RDFDataset } from './rdf-dataset';\nimport { DatasetIdx } from './dataset-idx';\nimport { DEFAULT_HASHER } from './poseidon';\n\nexport class Relationship {\n  constructor(\n    // string should be derived from instance of NodeID for the below maps\n    public parents: Map<string, DatasetIdx> = new Map(),\n    // map[qArrKey]map[refTp]int\n    public children: Map<string, Map<string, number>> = new Map(),\n    public hasher: Hasher = DEFAULT_HASHER\n  ) {}\n\n  static getIriValue(n: Quad): Quad {\n    if (n.predicate.termType === NodeType.IRI) {\n      return n.predicate.value;\n    }\n    throw new Error('type is not IRI');\n  }\n\n  path(dsIdx: DatasetIdx, ds: RDFDataset, idx: number): Path {\n    const k = new Path([], this.hasher);\n    if (typeof idx === 'number') {\n      k.append([idx]);\n    }\n    const n = RDFDataset.getQuad(ds, dsIdx);\n\n    const predicate = Relationship.getIriValue(n);\n    k.append([predicate]);\n\n    let nextKey = dsIdx;\n\n    for (;;) {\n      const parentIdx = this.parents.get(nextKey.toString());\n      if (!parentIdx) {\n        break;\n      }\n      const parent = RDFDataset.getQuad(ds, parentIdx);\n      const parentKey = new QuadArrKey(parent);\n      const childrenMap = this.children.get(parentKey.toString());\n\n      if (!childrenMap) {\n        throw new Error('parent mapping not found');\n      }\n\n      const childQuad = RDFDataset.getQuad(ds, nextKey);\n      const childRef = RefTp.getRefFromQuad(childQuad.subject);\n      const childIdx = childrenMap.get(childRef.toString());\n      if (typeof childIdx !== 'number') {\n        throw new Error('child not found in parents mapping');\n      }\n\n      const parentPredicate = Relationship.getIriValue(parent);\n\n      if (childrenMap.size === 1) {\n        k.append([parentPredicate]);\n      } else {\n        k.append([childIdx, parentPredicate]);\n      }\n      nextKey = parentIdx;\n    }\n    k.reverse();\n    return k;\n  }\n\n  static async newRelationship(ds: RDFDataset, hasher: Hasher): Promise<Relationship> {\n    const r = new Relationship(new Map(), new Map(), hasher);\n\n    RDFDataset.iterGraphsOrdered(ds, (graphName, quads) => {\n      for (let idx = 0; idx < quads.length; idx++) {\n        const q = quads[idx];\n        const parentIdx = RDFDataset.findParent(ds, q);\n        if (!parentIdx) {\n          continue;\n        }\n        const qIdx: DatasetIdx = new DatasetIdx(graphName, idx);\n        r.parents.set(qIdx.toString(), parentIdx);\n        const parentQuad = RDFDataset.getQuad(ds, parentIdx);\n        const qKey = new QuadArrKey(parentQuad);\n        //string here is json representation of RefTp interface\n        let childrenM: Map<string, number> | undefined = r.children.get(qKey.toString());\n        if (!childrenM) {\n          childrenM = new Map();\n          r.children.set(qKey.toString(), childrenM);\n        }\n\n        const childRef = RefTp.getRefFromQuad(q.subject);\n\n        const childExists = childrenM.get(childRef.toString());\n        if (typeof childExists !== 'number') {\n          const nextIdx = childrenM.size;\n          childrenM.set(childRef.toString(), nextIdx);\n        }\n      }\n    });\n\n    return r;\n  }\n}\n", "// @ts-ignore-next-line\nimport { Quad } from 'n3';\n/* eslint-disable no-case-declarations */\nimport { MerklizationConstants } from './constants';\nimport { Path } from './path';\nimport { Hasher, NodeType, Value } from './types/types';\nimport { MtValue } from './mt-value';\nimport { DEFAULT_HASHER } from './poseidon';\nimport { convertStringToXsdValue, validateValue } from './utils';\nimport { RDFDataset } from './rdf-dataset';\nimport { Relationship } from './relationship';\nimport { DatasetIdx } from './dataset-idx';\nimport { QuadArrKey } from './quad-arr-key';\nimport { Temporal } from '@js-temporal/polyfill';\n\nexport class RDFEntry {\n  constructor(\n    public key: Path,\n    public value: Value,\n    public dataType: string = '',\n    public hasher: Hasher = DEFAULT_HASHER\n  ) {\n    if (!key.parts.length) {\n      throw new Error('key length is zero');\n    }\n    validateValue(value);\n  }\n\n  getHasher(): Hasher {\n    return this.hasher;\n  }\n\n  getKeyMtEntry(): Promise<bigint> {\n    return this.key.mtEntry();\n  }\n\n  getValueMtEntry(): Promise<bigint> {\n    return MtValue.mkValueMtEntry(this.getHasher(), this.value);\n  }\n\n  async getKeyValueMTEntry(): Promise<{ k: bigint; v: bigint }> {\n    const k = await this.getKeyMtEntry();\n    const v = await this.getValueMtEntry();\n    return { k, v };\n  }\n\n  static newRDFEntry = (k: Path, v: Value) => {\n    const e = new RDFEntry(k, v);\n    switch (typeof v) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        e.value = v;\n        break;\n      default:\n        if (v instanceof Temporal.Instant) {\n          e.value = v;\n        } else {\n          throw new Error(`error: incorrect value type ${typeof v}`);\n        }\n    }\n    return e;\n  };\n\n  static async fromDataSet(ds: RDFDataset, hasher: Hasher = DEFAULT_HASHER): Promise<RDFEntry[]> {\n    RDFDataset.assertDatasetConsistency(ds);\n\n    const quads = ds.graphs.get(MerklizationConstants.DEFAULT_GRAPH_NODE_NAME);\n    if (!quads?.length) {\n      throw new Error('@default graph not found in dataset');\n    }\n\n    const rs = await Relationship.newRelationship(ds, hasher);\n    const entries: RDFEntry[] = [];\n    const graphProcessor = (graphName: string, quads: Quad[]): void => {\n      const counts = QuadArrKey.countEntries(quads);\n      const seenCount = new Map<string, number>();\n      for (let quadIdx = 0; quadIdx < quads.length; quadIdx++) {\n        let dataType = '';\n        const q = quads[quadIdx];\n        const quadGraphIdx = new DatasetIdx(graphName, quadIdx);\n        const qKey = new QuadArrKey(q);\n        let value: Value;\n        const qo = q.object.termType;\n        const qoVal = q.object.value;\n\n        switch (qo) {\n          case NodeType.Literal:\n            dataType = q?.object?.datatype?.value;\n            value = convertStringToXsdValue(dataType, qoVal, hasher.prime());\n\n            break;\n          case NodeType.IRI:\n            if (!qo) {\n              throw new Error('object IRI is nil');\n            }\n            value = qoVal;\n            break;\n          case NodeType.BlankNode:\n            const p = rs.children.get(qKey.toString());\n            if (p) {\n              // this node is a reference to known parent,\n              // skip it and do not put it into merkle tree because it\n              // will be used as parent for other nodes, but has\n              // no value to put itself.\n              continue;\n            }\n            throw new Error('BlankNode is not supported yet');\n          case 'Variable':\n            value = qoVal;\n            break;\n          default:\n            throw new Error(\"unexpected Quad's Object type\");\n        }\n\n        const count = counts.get(qKey.toString());\n        let idx: number | undefined;\n        switch (count) {\n          case 0:\n            throw new Error('[assertion] key not found in counts');\n          case 1:\n            // leave idx nil: only one element, do not consider it as an array\n            break;\n          default:\n            const key = qKey.toString();\n            idx = seenCount.get(key) ?? 0;\n            seenCount.set(key, idx + 1);\n        }\n\n        const path = rs.path(quadGraphIdx, ds, idx as number);\n        const e = new RDFEntry(path, value, dataType, hasher);\n        entries.push(e);\n      }\n    };\n\n    RDFDataset.iterGraphsOrdered(ds, graphProcessor);\n\n    return entries;\n  }\n}\n", "export { PoseidonHasher } from './lib/poseidon';\nexport { Value } from './lib/types/types';\nexport { MtValue } from './lib/mt-value';\nexport { Merklizer } from './lib/merklizer';\nexport { Path } from './lib/path';\nexport { Hasher, Options } from './lib/types/types';\nexport { MerklizationConstants } from './lib/constants';\nexport { getDocumentLoader } from './lib/options';\nexport { DocumentLoader } from './loaders/jsonld-loader';\nexport { Temporal } from '@js-temporal/polyfill';\n"],
  "mappings": "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",
  "names": ["Temporal", "Temporal", "Merkletree", "moreParts", "Temporal", "quads", "Merkletree", "Temporal"]
}
