import{fromBigEndian as t,toBigEndian as e,Id as n}from"@iden3/js-iden3-core";import{sha256 as r,poseidon as i}from"@iden3/js-crypto";import{groth16 as o}from"snarkjs";import{Hash as s}from"@iden3/js-merkletree";import{getCurveFromName as c}from"ffjavascript";const a="21888242871839275222246405745257275088548364400416034343698204186575808495617";function u(e){const n=r(e),o=t(n.reverse());let s=BigInt(0);return s=o<BigInt(a)?o:o%BigInt(a),i.hash([s])}class l{constructor(t,e){this.alg=t,this.circuitId=e}toString(){return`${this.alg}:${this.circuitId}`}}const d=new Map;function f(t,e){return new Promise((n=>{d.set(t.toString(),e),n()}))}function h(t){return new Promise(((e,n)=>{const r=d.get(t.toString());if(r){e(r())}else n("unknown alg")}))}var g,p={chars:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bits:6},m=function(t,e){return function(t,e,n){var r;void 0===n&&(n={});if(!e.codes){e.codes={};for(var i=0;i<e.chars.length;++i)e.codes[e.chars[i]]=i}if(!n.loose&&t.length*e.bits&7)throw new SyntaxError("Invalid padding");var o=t.length;for(;"="===t[o-1];)if(--o,!(n.loose||(t.length-o)*e.bits&7))throw new SyntaxError("Invalid padding");for(var s=new(null!=(r=n.out)?r:Uint8Array)(o*e.bits/8|0),c=0,a=0,u=0,l=0;l<o;++l){var d=e.codes[t[l]];if(void 0===d)throw new SyntaxError("Invalid character "+t[l]);a=a<<e.bits|d,(c+=e.bits)>=8&&(c-=8,s[u++]=255&a>>c)}if(c>=e.bits||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return s}(t,p,e)},y=function(t,e){return function(t,e,n){void 0===n&&(n={});for(var r=n.pad,i=void 0===r||r,o=(1<<e.bits)-1,s="",c=0,a=0,u=0;u<t.length;++u)for(a=a<<8|255&t[u],c+=8;c>e.bits;)c-=e.bits,s+=e.chars[o&a>>c];c&&(s+=e.chars[o&a<<e.bits-c]);if(i)for(;s.length*e.bits&7;)s+="=";return s}(t,p,e)};!function(t){t.Type="typ",t.Alg="alg",t.CircuitId="circuitId",t.Critical="crit"}(g||(g={}));class w{constructor(t,e,n,r){this.payload=t,this.protectedHeaders=e,this.header=n,this.zkp=r}async sanitized(){if(!this.payload)throw new Error("iden3/js-jwz: missing payload in JWZ message");const t=JSON.parse((new TextDecoder).decode(this.protectedHeaders));t[g.Critical].forEach((e=>{if(!t[e])throw new Error(`iden3/js-jwz: header is listed in critical ${e}, but not presented`)}));const e=t[g.Alg],n=t[g.CircuitId],r=await h(new l(e,n)),i=JSON.parse((new TextDecoder).decode(this.zkp)),o=new E(r,(new TextDecoder).decode(this.payload));o.alg=e,o.circuitId=n,o.zkProof=i;for(const[e,n]of Object.entries(t))o.setHeader(e,n);return o}}class E{constructor(t,e,n){this.method=t,this.inputsPreparer=n,this.zkProof={},this.alg=this.method.alg,this.circuitId=this.method.circuitId,this.raw={},this.raw.header=this.getDefaultHeaders(),this.raw.payload=(new TextEncoder).encode(e)}setHeader(t,e){this.raw.header[t]=e}getPayload(){return(new TextDecoder).decode(this.raw.payload)}getDefaultHeaders(){return{[g.Alg]:this.alg,[g.Critical]:[g.CircuitId],[g.CircuitId]:this.circuitId,[g.Type]:"JWZ"}}static parse(t){const e=t?.trim();return e.startsWith("{")?E.parseFull(t):E.parseCompact(t)}static async parseCompact(t){const e=t.split(".");if(3!=e.length)throw new Error("iden3/js-jwz: compact JWZ format must have three segments");const n=m(e[0],{loose:!0}),r=m(e[1],{loose:!0}),i=m(e[2],{loose:!0}),o=new w(r,n,{},i);return await o.sanitized()}static async parseFull(t){const e=JSON.parse(t);return await e.sanitized()}async prove(t,e){const n=this.serializeHeaders();this.raw.protectedHeaders=(new TextEncoder).encode(n);const r=await this.getMessageHash();if(!this.inputsPreparer)throw new Error("iden3/jwz: prepare func must be defined");const i=await function(t,e,n){return t(e,n)}(this.inputsPreparer,r,this.circuitId),o=await this.method.prove(i,t,e),s=JSON.stringify(o);return this.zkProof=o,this.raw.zkp=(new TextEncoder).encode(s),this.compactSerialize()}compactSerialize(){if(!this.raw.header||!this.raw.protectedHeaders||!this.zkProof)throw new Error("iden3/jwz:can't serialize without one of components");const t=y(this.raw.protectedHeaders,{pad:!1}),e=y(this.raw.zkp,{pad:!1});return`${t}.${y(this.raw.payload,{pad:!1})}.${e}`}fullSerialize(){return JSON.stringify(this.raw)}async getMessageHash(){const t=this.serializeHeaders(),n=(new TextEncoder).encode(t),r=y(n,{pad:!1}),i=y(this.raw.payload,{pad:!1}),o=(new TextEncoder).encode(`${r}.${i}`),s=await u(o);return e(s,32)}async verify(t){const e=await this.getMessageHash();return this.method.verify(e,this.zkProof,t)}serializeHeaders(){return JSON.stringify(this.raw.header,Object.keys(this.raw.header).sort())}}async function B(t,e){let n;e=e||{};try{n=await WebAssembly.compile(t)}catch(t){throw console.log(t),console.log("\nTry to run circom --c in order to generate c++ code instead\n"),new Error(t)}let r="",i="";const o=await WebAssembly.instantiate(n,{runtime:{exceptionHandler:function(t){let e;throw e=1==t?"Signal not found.\n":2==t?"Too many signals set.\n":3==t?"Signal already set.\n":4==t?"Assert Failed.\n":5==t?"Not enough memory.\n":6==t?"Input signal array access exceeds the size.\n":"Unknown error.\n",new Error(e+r)},printErrorMessage:function(){r+=s()+"\n"},writeBufferMessage:function(){const t=s();"\n"===t?(console.log(i),i=""):(""!==i&&(i+=" "),i+=t)},showSharedRWMemory:function(){!function(){const t=o.exports.getFieldNumLen32(),e=new Uint32Array(t);for(let n=0;n<t;n++)e[t-1-n]=o.exports.readSharedRWMemory(n);""!==i&&(i+=" ");i+=S(e).toString()}()}}});return new b(o,e);function s(){let t="",e=o.exports.getMessageChar();for(;0!=e;)t+=String.fromCharCode(e),e=o.exports.getMessageChar();return t}}class b{constructor(t,e){this.instance=t,this.instance=t,this.version=this.instance.exports.getVersion(),this.n32=this.instance.exports.getFieldNumLen32(),this.instance.exports.getRawPrime();const n=new Uint32Array(this.n32);for(let t=0;t<this.n32;t++)n[this.n32-1-t]=this.instance.exports.readSharedRWMemory(t);this.prime=S(n),this.witnessSize=this.instance.exports.getWitnessSize(),this.sanityCheck=e}circom_version(){return this.instance.exports.getVersion()}async _doCalculateWitness(t,e){this.instance.exports.init(this.sanityCheck||e?1:0);const n=Object.keys(t);let r=0;if(n.forEach((e=>{const n=function(t){const e=BigInt(2)**BigInt(64);let n=BigInt("0xCBF29CE484222325");for(let r=0;r<t.length;r++)n^=BigInt(t[r].charCodeAt()),n*=BigInt(1099511628211),n%=e;let r=n.toString(16);const i=16-r.length;return r="0".repeat(i).concat(r),r}(e),i=parseInt(n.slice(0,8),16),o=parseInt(n.slice(8,16),16),s=function(t){const e=[];return n(e,t),e;function n(t,e){if(Array.isArray(e))for(let r=0;r<e.length;r++)n(t,e[r]);else t.push(e)}}(t[e]),c=this.instance.exports.getInputSignalSize(i,o);if(c<0)throw new Error(`Signal ${e} not found\n`);if(s.length<c)throw new Error(`Not enough values for input signal ${e}\n`);if(s.length>c)throw new Error(`Too many values for input signal ${e}\n`);for(let t=0;t<s.length;t++){const e=v(BigInt(s[t])%this.prime,this.n32);for(let t=0;t<this.n32;t++)this.instance.exports.writeSharedRWMemory(t,e[this.n32-1-t]);try{this.instance.exports.setInputSignal(i,o,t),r++}catch(t){throw new Error(t)}}})),r<this.instance.exports.getInputSize())throw new Error(`Not all inputs have been set. Only ${r} out of ${this.instance.exports.getInputSize()}`)}async calculateWitness(t,e){const n=[];await this._doCalculateWitness(t,e);for(let t=0;t<this.witnessSize;t++){this.instance.exports.getWitness(t);const e=new Uint32Array(this.n32);for(let t=0;t<this.n32;t++)e[this.n32-1-t]=this.instance.exports.readSharedRWMemory(t);n.push(S(e))}return n}async calculateBinWitness(t,e){const n=new Uint32Array(this.witnessSize*this.n32),r=new Uint8Array(n.buffer);await this._doCalculateWitness(t,e);for(let t=0;t<this.witnessSize;t++){this.instance.exports.getWitness(t);const e=t*this.n32;for(let t=0;t<this.n32;t++)n[e+t]=this.instance.exports.readSharedRWMemory(t)}return r}async calculateWTNSBin(t,e){const n=new Uint32Array(this.witnessSize*this.n32+this.n32+11),r=new Uint8Array(n.buffer);await this._doCalculateWitness(t,e),r[0]="w".charCodeAt(0),r[1]="t".charCodeAt(0),r[2]="n".charCodeAt(0),r[3]="s".charCodeAt(0),n[1]=2,n[2]=2,n[3]=1;const i=4*this.n32,o=(8+i).toString(16);n[4]=parseInt(o.slice(0,8),16),n[5]=parseInt(o.slice(8,16),16),n[6]=i,this.instance.exports.getRawPrime();let s=7;for(let t=0;t<this.n32;t++)n[s+t]=this.instance.exports.readSharedRWMemory(t);s+=this.n32,n[s]=this.witnessSize,s++,n[s]=2,s++;const c=(i*this.witnessSize).toString(16);n[s]=parseInt(c.slice(0,8),16),n[s+1]=parseInt(c.slice(8,16),16),s+=2;for(let t=0;t<this.witnessSize;t++){this.instance.exports.getWitness(t);for(let t=0;t<this.n32;t++)n[s+t]=this.instance.exports.readSharedRWMemory(t);s+=this.n32}return r}}function v(t,e){const n=[],r=BigInt(4294967296);for(;t;)n.unshift(Number(t%r)),t/=r;if(e){let t=e-n.length;for(;t>0;)n.unshift(0),t--}return n}function S(t){let e=BigInt(0);const n=BigInt(4294967296);for(let r=0;r<t.length;r++)e=e*n+BigInt(t[r]);return e}const x="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function I(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function R(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function O(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function A(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function N(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function P(t,e){return t<<32-e|t>>>e}function q(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),R(t),t}class T{}function F(t){const e=e=>t().update(q(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function z(t=32){if(x&&"function"==typeof x.getRandomValues)return x.getRandomValues(new Uint8Array(t));if(x&&"function"==typeof x.randomBytes)return Uint8Array.from(x.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function C(t,e,n){return t&e^t&n^e&n}class D extends T{constructor(t,e,n,r){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.buffer=new Uint8Array(t),this.view=N(this.buffer)}update(t){O(this),R(t=q(t));const{view:e,buffer:n,blockLen:r}=this,i=t.length;for(let o=0;o<i;){const s=Math.min(r-this.pos,i-o);if(s!==r)n.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===r&&(this.process(e,0),this.pos=0);else{const e=N(t);for(;r<=i-o;o+=r)this.process(e,o)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){O(this),function(t,e){R(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:r,isLE:i}=this;let{pos:o}=this;e[o++]=128,A(this.buffer.subarray(o)),this.padOffset>r-o&&(this.process(n,0),o=0);for(let t=o;t<r;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const i=BigInt(32),o=BigInt(4294967295),s=Number(n>>i&o),c=Number(n&o),a=r?4:0,u=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+u,c,r)}(n,r-8,BigInt(8*this.length),i),this.process(n,0);const s=N(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<a;t++)s.setUint32(4*t,u[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:i,destroyed:o,pos:s}=this;return t.destroyed=o,t.finished=i,t.length=r,t.pos=s,r%e&&t.buffer.set(n),t}clone(){return this._cloneInto()}}const H=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),j=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),U=new Uint32Array(64);class L extends D{constructor(t=32){super(64,t,8,!1),this.A=0|H[0],this.B=0|H[1],this.C=0|H[2],this.D=0|H[3],this.E=0|H[4],this.F=0|H[5],this.G=0|H[6],this.H=0|H[7]}get(){const{A:t,B:e,C:n,D:r,E:i,F:o,G:s,H:c}=this;return[t,e,n,r,i,o,s,c]}set(t,e,n,r,i,o,s,c){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|c}process(t,e){for(let n=0;n<16;n++,e+=4)U[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=U[t-15],n=U[t-2],r=P(e,7)^P(e,18)^e>>>3,i=P(n,17)^P(n,19)^n>>>10;U[t]=i+U[t-7]+r+U[t-16]|0}let{A:n,B:r,C:i,D:o,E:s,F:c,G:a,H:u}=this;for(let t=0;t<64;t++){const e=u+(P(s,6)^P(s,11)^P(s,25))+((l=s)&c^~l&a)+j[t]+U[t]|0,d=(P(n,2)^P(n,13)^P(n,22))+C(n,r,i)|0;u=a,a=c,c=s,s=o+e|0,o=i,i=r,r=n,n=e+d|0}var l;n=n+this.A|0,r=r+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,c=c+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(n,r,i,o,s,c,a,u)}roundClean(){A(U)}destroy(){this.set(0,0,0,0,0,0,0,0),A(this.buffer)}}const Z=F((()=>new L));class _ extends T{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");I(t.outputLen),I(t.blockLen)}(t);const n=q(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(n.length>r?t.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),A(i)}update(t){return O(this),this.iHash.update(t),this}digestInto(t){O(this),R(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=r,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const k=(t,e,n)=>new _(t,e).update(n).digest();k.create=(t,e)=>new _(t,e);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const M=BigInt(0),V=BigInt(1);function G(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function W(t){if(!G(t))throw new Error("Uint8Array expected")}function Y(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function K(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?M:BigInt("0x"+t)}const $="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,J=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function X(t){if(W(t),$)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=J[t[n]];return e}const Q=48,tt=57,et=65,nt=70,rt=97,it=102;function ot(t){return t>=Q&&t<=tt?t-Q:t>=et&&t<=nt?t-(et-10):t>=rt&&t<=it?t-(rt-10):void 0}function st(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if($)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,i=0;e<n;e++,i+=2){const n=ot(t.charCodeAt(i)),o=ot(t.charCodeAt(i+1));if(void 0===n||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}r[e]=16*n+o}return r}function ct(t){return K(X(t))}function at(t){return W(t),K(X(Uint8Array.from(t).reverse()))}function ut(t,e){return st(t.toString(16).padStart(2*e,"0"))}function lt(t,e){return ut(t,e).reverse()}function dt(t,e,n){let r;if("string"==typeof e)try{r=st(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!G(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const i=r.length;if("number"==typeof n&&i!==n)throw new Error(t+" of length "+n+" expected, got "+i);return r}function ft(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];W(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}function ht(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const gt=t=>"bigint"==typeof t&&M<=t;function pt(t,e,n){return gt(t)&&gt(e)&&gt(n)&&e<=t&&t<n}function mt(t,e,n,r){if(!pt(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function yt(t){let e;for(e=0;t>M;t>>=V,e+=1);return e}function wt(t,e){return t>>BigInt(e)&V}const Et=t=>(V<<BigInt(t))-V;const Bt={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||G(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function bt(t,e,n={}){const r=(e,n,r)=>{const i=Bt[n];if("function"!=typeof i)throw new Error("invalid validator function");const o=t[e];if(!(r&&void 0===o||i(o,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+o)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}const vt=()=>{throw new Error("not implemented")};function St(t){const e=new WeakMap;return(n,...r)=>{const i=e.get(n);if(void 0!==i)return i;const o=t(n,...r);return e.set(n,o),o}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xt=BigInt(0),It=BigInt(1),Rt=BigInt(2),Ot=BigInt(3),At=BigInt(4),Nt=BigInt(5),Pt=BigInt(8);function qt(t,e){const n=t%e;return n>=xt?n:e+n}function Tt(t,e){if(t===xt)throw new Error("invert: expected non-zero number");if(e<=xt)throw new Error("invert: expected positive modulus, got "+e);let n=qt(t,e),r=e,i=xt,o=It;for(;n!==xt;){const t=r%n,e=i-o*(r/n);r=n,n=t,i=o,o=e}if(r!==It)throw new Error("invert: does not exist");return qt(i,e)}function Ft(t,e){const n=(t.ORDER+It)/At,r=t.pow(e,n);if(!t.eql(t.sqr(r),e))throw new Error("Cannot find square root");return r}function zt(t,e){const n=(t.ORDER-Nt)/Pt,r=t.mul(e,Rt),i=t.pow(r,n),o=t.mul(e,i),s=t.mul(t.mul(o,Rt),i),c=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(c),e))throw new Error("Cannot find square root");return c}function Ct(t){return t%At===Ot?Ft:t%Pt===Nt?zt:function(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-It,n=0;for(;e%Rt===xt;)e/=Rt,n++;let r=Rt;const i=Zt(t);for(;1===Ut(i,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return Ft;let o=i.pow(r,e);const s=(e+It)/Rt;return function(t,r){if(t.is0(r))return r;if(1!==Ut(t,r))throw new Error("Cannot find square root");let i=n,c=t.mul(t.ONE,o),a=t.pow(r,e),u=t.pow(r,s);for(;!t.eql(a,t.ONE);){if(t.is0(a))return t.ZERO;let e=1,n=t.sqr(a);for(;!t.eql(n,t.ONE);)if(e++,n=t.sqr(n),e===i)throw new Error("Cannot find square root");const r=It<<BigInt(i-e-1),o=t.pow(c,r);i=e,c=t.sqr(o),a=t.mul(a,c),u=t.mul(u,o)}return u}}(t)}const Dt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ht(t,e,n){if(n<xt)throw new Error("invalid exponent, negatives unsupported");if(n===xt)return t.ONE;if(n===It)return e;let r=t.ONE,i=e;for(;n>xt;)n&It&&(r=t.mul(r,i)),i=t.sqr(i),n>>=It;return r}function jt(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),i=e.reduce(((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n))),t.ONE),o=t.inv(i);return e.reduceRight(((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n))),o),r}function Ut(t,e){const n=(t.ORDER-It)/Rt,r=t.pow(e,n),i=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),s=t.eql(r,t.neg(t.ONE));if(!i&&!o&&!s)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Lt(t,e){void 0!==e&&I(e);const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Zt(t,e,n=!1,r={}){if(t<=xt)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:o}=Lt(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const c=Object.freeze({ORDER:t,isLE:n,BITS:i,BYTES:o,MASK:Et(i),ZERO:xt,ONE:It,create:e=>qt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return xt<=e&&e<t},is0:t=>t===xt,isOdd:t=>(t&It)===It,neg:e=>qt(-e,t),eql:(t,e)=>t===e,sqr:e=>qt(e*e,t),add:(e,n)=>qt(e+n,t),sub:(e,n)=>qt(e-n,t),mul:(e,n)=>qt(e*n,t),pow:(t,e)=>Ht(c,t,e),div:(e,n)=>qt(e*Tt(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Tt(e,t),sqrt:r.sqrt||(e=>(s||(s=Ct(t)),s(c,e))),toBytes:t=>n?lt(t,o):ut(t,o),fromBytes:t=>{if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);return n?at(t):ct(t)},invertBatch:t=>jt(c,t),cmov:(t,e,n)=>n?e:t});return Object.freeze(c)}function _t(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function kt(t){const e=_t(t);return e+Math.ceil(e/2)}function Mt(t,e,n=!1){const r=t.length,i=_t(e),o=kt(e);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const s=qt(n?at(t):ct(t),e-It)+It;return n?lt(s,i):ut(s,i)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt(0),Gt=BigInt(1);function Wt(t,e){const n=e.negate();return t?n:e}function Yt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Kt(t,e){Yt(t,e);const n=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:Et(t),maxNumber:n,shiftBy:BigInt(t)}}function $t(t,e,n){const{windowSize:r,mask:i,maxNumber:o,shiftBy:s}=n;let c=Number(t&i),a=t>>s;c>r&&(c-=o,a+=Gt);const u=e*r;return{nextN:a,offset:u+Math.abs(c)-1,isZero:0===c,isNeg:c<0,isNegF:e%2!=0,offsetF:u}}const Jt=new WeakMap,Xt=new WeakMap;function Qt(t){return Xt.get(t)||1}function te(t,e,n,r){!function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))}(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}(r,e);const i=n.length,o=r.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,c=yt(BigInt(i));let a=1;c>12?a=c-3:c>4?a=c-2:c>0&&(a=2);const u=Et(a),l=new Array(Number(u)+1).fill(s);let d=s;for(let t=Math.floor((e.BITS-1)/a)*a;t>=0;t-=a){l.fill(s);for(let e=0;e<o;e++){const i=r[e],o=Number(i>>BigInt(t)&u);l[o]=l[o].add(n[e])}let e=s;for(let t=l.length-1,n=s;t>0;t--)n=n.add(l[t]),e=e.add(n);if(d=d.add(e),0!==t)for(let t=0;t<a;t++)d=d.double()}return d}function ee(t){return bt(t.Fp,Dt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Lt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */Error;const ne=BigInt(0),re=BigInt(1);BigInt(2);const ie=BigInt(3),oe=BigInt(4);function se(t){const e=function(t){const e=ee(t);bt(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:n,Fp:r,a:i}=e;if(n){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}(t),{Fp:n}=e,r=Zt(e.n,e.nBitLength),i=e.toBytes||((t,e,r)=>{const i=e.toAffine();return ft(Uint8Array.from([4]),n.toBytes(i.x),n.toBytes(i.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function s(t){const{a:r,b:i}=e,o=n.sqr(t),s=n.mul(o,t);return n.add(n.add(s,n.mul(t,r)),i)}function c(t,e){const r=n.sqr(e),i=s(t);return n.eql(r,i)}if(!c(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const a=n.mul(n.pow(e.a,ie),oe),u=n.mul(n.sqr(e.b),BigInt(27));if(n.is0(n.add(a,u)))throw new Error("bad curve params: a or b");function l(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:i,n:o}=e;if(n&&"bigint"!=typeof t){if(G(t)&&(t=X(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*r,"0")}let s;try{s="bigint"==typeof t?t:ct(dt("private key",t,r))}catch(e){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof t)}return i&&(s=qt(s,o)),mt("private key",s,re,o),s}function d(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const f=St(((t,e)=>{const{px:r,py:i,pz:o}=t;if(n.eql(o,n.ONE))return{x:r,y:i};const s=t.is0();null==e&&(e=s?n.ONE:n.inv(o));const c=n.mul(r,e),a=n.mul(i,e),u=n.mul(o,e);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:c,y:a}})),h=St((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:r,y:i}=t.toAffine();if(!n.isValid(r)||!n.isValid(i))throw new Error("bad point: x or y not FE");if(!c(r,i))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class g{constructor(t,e,r){if(null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e)||n.is0(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");this.px=t,this.py=e,this.pz=r,Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const i=t=>n.eql(t,n.ZERO);return i(e)&&i(r)?g.ZERO:new g(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=jt(n,t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(o(dt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(l(t))}static msm(t,e){return te(g,r,t,e)}_setWindowSize(t){y.setWindowSize(this,t)}assertValidity(){h(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){d(t);const{px:e,py:r,pz:i}=this,{px:o,py:s,pz:c}=t,a=n.eql(n.mul(e,c),n.mul(o,i)),u=n.eql(n.mul(r,c),n.mul(s,i));return a&&u}negate(){return new g(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,i=n.mul(r,ie),{px:o,py:s,pz:c}=this;let a=n.ZERO,u=n.ZERO,l=n.ZERO,d=n.mul(o,o),f=n.mul(s,s),h=n.mul(c,c),p=n.mul(o,s);return p=n.add(p,p),l=n.mul(o,c),l=n.add(l,l),a=n.mul(t,l),u=n.mul(i,h),u=n.add(a,u),a=n.sub(f,u),u=n.add(f,u),u=n.mul(a,u),a=n.mul(p,a),l=n.mul(i,l),h=n.mul(t,h),p=n.sub(d,h),p=n.mul(t,p),p=n.add(p,l),l=n.add(d,d),d=n.add(l,d),d=n.add(d,h),d=n.mul(d,p),u=n.add(u,d),h=n.mul(s,c),h=n.add(h,h),d=n.mul(h,p),a=n.sub(a,d),l=n.mul(h,f),l=n.add(l,l),l=n.add(l,l),new g(a,u,l)}add(t){d(t);const{px:r,py:i,pz:o}=this,{px:s,py:c,pz:a}=t;let u=n.ZERO,l=n.ZERO,f=n.ZERO;const h=e.a,p=n.mul(e.b,ie);let m=n.mul(r,s),y=n.mul(i,c),w=n.mul(o,a),E=n.add(r,i),B=n.add(s,c);E=n.mul(E,B),B=n.add(m,y),E=n.sub(E,B),B=n.add(r,o);let b=n.add(s,a);return B=n.mul(B,b),b=n.add(m,w),B=n.sub(B,b),b=n.add(i,o),u=n.add(c,a),b=n.mul(b,u),u=n.add(y,w),b=n.sub(b,u),f=n.mul(h,B),u=n.mul(p,w),f=n.add(u,f),u=n.sub(y,f),f=n.add(y,f),l=n.mul(u,f),y=n.add(m,m),y=n.add(y,m),w=n.mul(h,w),B=n.mul(p,B),y=n.add(y,w),w=n.sub(m,w),w=n.mul(h,w),B=n.add(B,w),m=n.mul(y,B),l=n.add(l,m),m=n.mul(b,B),u=n.mul(E,u),u=n.sub(u,m),m=n.mul(E,y),f=n.mul(b,f),f=n.add(f,m),new g(u,l,f)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return y.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:r,n:i}=e;mt("scalar",t,ne,i);const o=g.ZERO;if(t===ne)return o;if(this.is0()||t===re)return this;if(!r||y.hasPrecomputes(this))return y.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:s,k1:c,k2neg:a,k2:u}=r.splitScalar(t),l=o,d=o,f=this;for(;c>ne||u>ne;)c&re&&(l=l.add(f)),u&re&&(d=d.add(f)),f=f.double(),c>>=re,u>>=re;return s&&(l=l.negate()),a&&(d=d.negate()),d=new g(n.mul(d.px,r.beta),d.py,d.pz),l.add(d)}multiply(t){const{endo:r,n:i}=e;let o,s;if(mt("scalar",t,re,i),r){const{k1neg:e,k1:i,k2neg:c,k2:a}=r.splitScalar(t);let{p:u,f:l}=this.wNAF(i),{p:d,f:f}=this.wNAF(a);u=y.constTimeNegate(e,u),d=y.constTimeNegate(c,d),d=new g(n.mul(d.px,r.beta),d.py,d.pz),o=u.add(d),s=l.add(f)}else{const{p:e,f:n}=this.wNAF(t);o=e,s=n}return g.normalizeZ([o,s])[0]}multiplyAndAddUnsafe(t,e,n){const r=g.BASE,i=(t,e)=>e!==ne&&e!==re&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,n));return o.is0()?void 0:o}toAffine(t){return f(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===re)return!0;if(n)return n(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===re?this:n?n(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return Y("isCompressed",t),this.assertValidity(),i(g,this,t)}toHex(t=!0){return Y("isCompressed",t),X(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,n.ONE),g.ZERO=new g(n.ZERO,n.ONE,n.ZERO);const{endo:p,nBitLength:m}=e,y=(w=g,E=p?Math.ceil(m/2):m,{constTimeNegate:Wt,hasPrecomputes:t=>1!==Qt(t),unsafeLadder(t,e,n=w.ZERO){let r=t;for(;e>Vt;)e&Gt&&(n=n.add(r)),r=r.double(),e>>=Gt;return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=Kt(e,E),i=[];let o=t,s=o;for(let t=0;t<n;t++){s=o,i.push(s);for(let t=1;t<r;t++)s=s.add(o),i.push(s);o=s.double()}return i},wNAF(t,e,n){let r=w.ZERO,i=w.BASE;const o=Kt(t,E);for(let t=0;t<o.windows;t++){const{nextN:s,offset:c,isZero:a,isNeg:u,isNegF:l,offsetF:d}=$t(n,t,o);n=s,a?i=i.add(Wt(l,e[d])):r=r.add(Wt(u,e[c]))}return{p:r,f:i}},wNAFUnsafe(t,e,n,r=w.ZERO){const i=Kt(t,E);for(let t=0;t<i.windows&&n!==Vt;t++){const{nextN:o,offset:s,isZero:c,isNeg:a}=$t(n,t,i);if(n=o,!c){const t=e[s];r=r.add(a?t.negate():t)}}return r},getPrecomputes(t,e,n){let r=Jt.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&Jt.set(e,n(r))),r},wNAFCached(t,e,n){const r=Qt(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)},wNAFCachedUnsafe(t,e,n,r){const i=Qt(t);return 1===i?this.unsafeLadder(t,e,r):this.wNAFUnsafe(i,this.getPrecomputes(i,t,n),e,r)},setWindowSize(t,e){Yt(e,E),Xt.set(t,e),Jt.delete(t)}});var w,E;return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:l,weierstrassEquation:s,isWithinCurveOrder:function(t){return pt(t,re,e.n)}}}const ce=ct;function ae(t,e){if(le(t),le(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function ue(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function le(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function de(t,e,n){bt(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:i,m:o,hash:s,expand:c,DST:a}=n;W(t),le(e);const u="string"==typeof a?ht(a):a,l=r.toString(2).length,d=Math.ceil((l+i)/8),f=e*o*d;let h;if("xmd"===c)h=function(t,e,n,r){W(t),W(e),le(n),e.length>255&&(e=r(ft(ht("H2C-OVERSIZE-DST-"),e)));const{outputLen:i,blockLen:o}=r,s=Math.ceil(n/i);if(n>65535||s>255)throw new Error("expand_message_xmd: invalid lenInBytes");const c=ft(e,ae(e.length,1)),a=ae(0,o),u=ae(n,2),l=new Array(s),d=r(ft(a,t,u,ae(0,1),c));l[0]=r(ft(d,ae(1,1),c));for(let t=1;t<=s;t++){const e=[ue(d,l[t-1]),ae(t+1,1),c];l[t]=r(ft(...e))}return ft(...l).slice(0,n)}(t,u,f,s);else if("xof"===c)h=function(t,e,n,r,i){if(W(t),W(e),le(n),e.length>255){const t=Math.ceil(2*r/8);e=i.create({dkLen:t}).update(ht("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:n}).update(t).update(ae(n,2)).update(e).update(ae(e.length,1)).digest()}(t,u,f,i,s);else{if("_internal_pass"!==c)throw new Error('expand must be "xmd" or "xof"');h=t}const g=new Array(e);for(let t=0;t<e;t++){const e=new Array(o);for(let n=0;n<o;n++){const i=d*(n+t*o),s=h.subarray(i,i+d);e[n]=qt(ce(s),r)}g[t]=e}return g}function fe(t,e,n){if("function"!=typeof e)throw new Error("mapToCurve() must be defined");function r(n){return t.fromAffine(e(n))}function i(e){const n=e.clearCofactor();return n.equals(t.ZERO)?t.ZERO:(n.assertValidity(),n)}return{defaults:n,hashToCurve(t,e){const o=de(t,2,{...n,DST:n.DST,...e}),s=r(o[0]),c=r(o[1]);return i(s.add(c))},encodeToCurve:(t,e)=>i(r(de(t,1,{...n,DST:n.encodeDST,...e})[0])),mapToCurve(t){if(!Array.isArray(t))throw new Error("expected array of bigints");for(const e of t)if("bigint"!=typeof e)throw new Error("expected array of bigints");return i(r(t))}}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt(0),ge=BigInt(1),pe=BigInt(2),me=BigInt(3);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ye=BigInt(0),we=BigInt(1),Ee=BigInt(2),Be=BigInt(3);function be(t,e,n,r,i=1,o){const s=BigInt(void 0===o?r:o),c=n**BigInt(r),a=[];for(let o=0;o<i;o++){const i=BigInt(o+1),u=[];for(let o=0,a=we;o<r;o++){const r=(i*a-i)/s%c;u.push(t.pow(e,r)),a*=n}a.push(u)}return a}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ve=BigInt(1),Se=BigInt(2),xe=BigInt(3),Ie=BigInt(6),Re=BigInt("4965661367192848881"),Oe=yt(Re),Ae=Ie*Re**Se,Ne=Zt(BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617")),Pe={c0:BigInt("19485874751759354771024239261021720505790618469301721065564631296452457478373"),c1:BigInt("266929791119991161246907387137283842545076965332900288569378510910307636690")},{Fp:qe,Fp2:Te,Fp6:Fe,Fp4Square:ze,Fp12:Ce}=function(t){const{ORDER:e}=t,n=Zt(e),r=n.create(t.NONRESIDUE||BigInt(-1)),i=n.div(n.ONE,Ee),o=be(n,r,n.ORDER,2)[0],s=({c0:t,c1:e},{c0:r,c1:i})=>({c0:n.add(t,r),c1:n.add(e,i)}),c=({c0:t,c1:e},{c0:r,c1:i})=>({c0:n.sub(t,r),c1:n.sub(e,i)}),a=({c0:t,c1:e},r)=>{if("bigint"==typeof r)return{c0:n.mul(t,r),c1:n.mul(e,r)};const{c0:i,c1:o}=r;let s=n.mul(t,i),c=n.mul(e,o);return{c0:n.sub(s,c),c1:n.sub(n.mul(n.add(t,e),n.add(i,o)),n.add(s,c))}},u=({c0:t,c1:e})=>{const r=n.add(t,e),i=n.sub(t,e),o=n.add(t,t);return{c0:n.mul(r,i),c1:n.mul(o,e)}},l=t=>{if(2!==t.length)throw new Error("invalid tuple");const e=t.map((t=>n.create(t)));return{c0:e[0],c1:e[1]}},d=e*e,f=l(t.FP2_NONRESIDUE),h={ORDER:d,isLE:n.isLE,NONRESIDUE:f,BITS:yt(d),BYTES:Math.ceil(yt(d)/8),MASK:Et(yt(d)),ZERO:{c0:n.ZERO,c1:n.ZERO},ONE:{c0:n.ONE,c1:n.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>"bigint"==typeof t&&"bigint"==typeof e,is0:({c0:t,c1:e})=>n.is0(t)&&n.is0(e),eql:({c0:t,c1:e},{c0:r,c1:i})=>n.eql(t,r)&&n.eql(e,i),neg:({c0:t,c1:e})=>({c0:n.neg(t),c1:n.neg(e)}),pow:(t,e)=>Ht(h,t,e),invertBatch:t=>jt(h,t),add:s,sub:c,mul:a,sqr:u,addN:s,subN:c,mulN:a,sqrN:u,div:(t,e)=>h.mul(t,"bigint"==typeof e?n.inv(n.create(e)):h.inv(e)),inv:({c0:t,c1:e})=>{const r=n.inv(n.create(t*t+e*e));return{c0:n.mul(r,n.create(t)),c1:n.mul(r,n.create(-e))}},sqrt:e=>{if(t.Fp2sqrt)return t.Fp2sqrt(e);const{c0:o,c1:s}=e;if(n.is0(s))return 1===Ut(n,o)?h.create({c0:n.sqrt(o),c1:n.ZERO}):h.create({c0:n.ZERO,c1:n.sqrt(n.div(o,r))});const c=n.sqrt(n.sub(n.sqr(o),n.mul(n.sqr(s),r)));let a=n.mul(n.add(c,o),i);-1===Ut(n,a)&&(a=n.sub(a,c));const u=n.sqrt(a),l=h.create({c0:u,c1:n.div(n.mul(s,i),u)});if(!h.eql(h.sqr(l),e))throw new Error("Cannot find square root");const d=l,f=h.neg(d),{re:g,im:p}=h.reim(d),{re:m,im:y}=h.reim(f);return p>y||p===y&&g>m?d:f},isOdd:t=>{const{re:e,im:n}=h.reim(t);return BigInt(e%Ee||e===ye&&n%Ee)==we},fromBytes(t){if(t.length!==h.BYTES)throw new Error("fromBytes invalid length="+t.length);return{c0:n.fromBytes(t.subarray(0,n.BYTES)),c1:n.fromBytes(t.subarray(n.BYTES))}},toBytes:({c0:t,c1:e})=>ft(n.toBytes(t),n.toBytes(e)),cmov:({c0:t,c1:e},{c0:r,c1:i},o)=>({c0:n.cmov(t,r,o),c1:n.cmov(e,i,o)}),reim:({c0:t,c1:e})=>({re:t,im:e}),mulByNonresidue:({c0:t,c1:e})=>h.mul({c0:t,c1:e},f),mulByB:t.Fp2mulByB,fromBigTuple:l,frobeniusMap:({c0:t,c1:e},r)=>({c0:t,c1:n.mul(e,o[r%2])})},g=({c0:t,c1:e,c2:n},{c0:r,c1:i,c2:o})=>({c0:h.add(t,r),c1:h.add(e,i),c2:h.add(n,o)}),p=({c0:t,c1:e,c2:n},{c0:r,c1:i,c2:o})=>({c0:h.sub(t,r),c1:h.sub(e,i),c2:h.sub(n,o)}),m=({c0:t,c1:e,c2:n},r)=>{if("bigint"==typeof r)return{c0:h.mul(t,r),c1:h.mul(e,r),c2:h.mul(n,r)};const{c0:i,c1:o,c2:s}=r,c=h.mul(t,i),a=h.mul(e,o),u=h.mul(n,s);return{c0:h.add(c,h.mulByNonresidue(h.sub(h.mul(h.add(e,n),h.add(o,s)),h.add(a,u)))),c1:h.add(h.sub(h.mul(h.add(t,e),h.add(i,o)),h.add(c,a)),h.mulByNonresidue(u)),c2:h.sub(h.add(a,h.mul(h.add(t,n),h.add(i,s))),h.add(c,u))}},y=({c0:t,c1:e,c2:n})=>{let r=h.sqr(t),i=h.mul(h.mul(t,e),Ee),o=h.mul(h.mul(e,n),Ee),s=h.sqr(n);return{c0:h.add(h.mulByNonresidue(o),r),c1:h.add(h.mulByNonresidue(s),i),c2:h.sub(h.sub(h.add(h.add(i,h.sqr(h.add(h.sub(t,e),n))),o),r),s)}},[w,E]=be(h,f,n.ORDER,6,2,3),B={ORDER:h.ORDER,isLE:h.isLE,BITS:3*h.BITS,BYTES:3*h.BYTES,MASK:Et(3*h.BITS),ZERO:{c0:h.ZERO,c1:h.ZERO,c2:h.ZERO},ONE:{c0:h.ONE,c1:h.ZERO,c2:h.ZERO},create:t=>t,isValid:({c0:t,c1:e,c2:n})=>h.isValid(t)&&h.isValid(e)&&h.isValid(n),is0:({c0:t,c1:e,c2:n})=>h.is0(t)&&h.is0(e)&&h.is0(n),neg:({c0:t,c1:e,c2:n})=>({c0:h.neg(t),c1:h.neg(e),c2:h.neg(n)}),eql:({c0:t,c1:e,c2:n},{c0:r,c1:i,c2:o})=>h.eql(t,r)&&h.eql(e,i)&&h.eql(n,o),sqrt:vt,div:(t,e)=>B.mul(t,"bigint"==typeof e?n.inv(n.create(e)):B.inv(e)),pow:(t,e)=>Ht(B,t,e),invertBatch:t=>jt(B,t),add:g,sub:p,mul:m,sqr:y,addN:g,subN:p,mulN:m,sqrN:y,inv:({c0:t,c1:e,c2:n})=>{let r=h.sub(h.sqr(t),h.mulByNonresidue(h.mul(n,e))),i=h.sub(h.mulByNonresidue(h.sqr(n)),h.mul(t,e)),o=h.sub(h.sqr(e),h.mul(t,n)),s=h.inv(h.add(h.mulByNonresidue(h.add(h.mul(n,i),h.mul(e,o))),h.mul(t,r)));return{c0:h.mul(s,r),c1:h.mul(s,i),c2:h.mul(s,o)}},fromBytes:t=>{if(t.length!==B.BYTES)throw new Error("fromBytes invalid length="+t.length);return{c0:h.fromBytes(t.subarray(0,h.BYTES)),c1:h.fromBytes(t.subarray(h.BYTES,2*h.BYTES)),c2:h.fromBytes(t.subarray(2*h.BYTES))}},toBytes:({c0:t,c1:e,c2:n})=>ft(h.toBytes(t),h.toBytes(e),h.toBytes(n)),cmov:({c0:t,c1:e,c2:n},{c0:r,c1:i,c2:o},s)=>({c0:h.cmov(t,r,s),c1:h.cmov(e,i,s),c2:h.cmov(n,o,s)}),fromBigSix:t=>{if(!Array.isArray(t)||6!==t.length)throw new Error("invalid Fp6 usage");return{c0:h.fromBigTuple(t.slice(0,2)),c1:h.fromBigTuple(t.slice(2,4)),c2:h.fromBigTuple(t.slice(4,6))}},frobeniusMap:({c0:t,c1:e,c2:n},r)=>({c0:h.frobeniusMap(t,r),c1:h.mul(h.frobeniusMap(e,r),w[r%6]),c2:h.mul(h.frobeniusMap(n,r),E[r%6])}),mulByFp2:({c0:t,c1:e,c2:n},r)=>({c0:h.mul(t,r),c1:h.mul(e,r),c2:h.mul(n,r)}),mulByNonresidue:({c0:t,c1:e,c2:n})=>({c0:h.mulByNonresidue(n),c1:t,c2:e}),mul1:({c0:t,c1:e,c2:n},r)=>({c0:h.mulByNonresidue(h.mul(n,r)),c1:h.mul(t,r),c2:h.mul(e,r)}),mul01({c0:t,c1:e,c2:n},r,i){let o=h.mul(t,r),s=h.mul(e,i);return{c0:h.add(h.mulByNonresidue(h.sub(h.mul(h.add(e,n),i),s)),o),c1:h.sub(h.sub(h.mul(h.add(r,i),h.add(t,e)),o),s),c2:h.add(h.sub(h.mul(h.add(t,n),r),o),s)}}},b=be(h,f,n.ORDER,12,1,6)[0],v=({c0:t,c1:e},{c0:n,c1:r})=>({c0:B.add(t,n),c1:B.add(e,r)}),S=({c0:t,c1:e},{c0:n,c1:r})=>({c0:B.sub(t,n),c1:B.sub(e,r)}),x=({c0:t,c1:e},n)=>{if("bigint"==typeof n)return{c0:B.mul(t,n),c1:B.mul(e,n)};let{c0:r,c1:i}=n,o=B.mul(t,r),s=B.mul(e,i);return{c0:B.add(o,B.mulByNonresidue(s)),c1:B.sub(B.mul(B.add(t,e),B.add(r,i)),B.add(o,s))}},I=({c0:t,c1:e})=>{let n=B.mul(t,e);return{c0:B.sub(B.sub(B.mul(B.add(B.mulByNonresidue(e),t),B.add(t,e)),n),B.mulByNonresidue(n)),c1:B.add(n,n)}},R={ORDER:h.ORDER,isLE:B.isLE,BITS:2*B.BITS,BYTES:2*B.BYTES,MASK:Et(2*B.BITS),ZERO:{c0:B.ZERO,c1:B.ZERO},ONE:{c0:B.ONE,c1:B.ZERO},create:t=>t,isValid:({c0:t,c1:e})=>B.isValid(t)&&B.isValid(e),is0:({c0:t,c1:e})=>B.is0(t)&&B.is0(e),neg:({c0:t,c1:e})=>({c0:B.neg(t),c1:B.neg(e)}),eql:({c0:t,c1:e},{c0:n,c1:r})=>B.eql(t,n)&&B.eql(e,r),sqrt:vt,inv:({c0:t,c1:e})=>{let n=B.inv(B.sub(B.sqr(t),B.mulByNonresidue(B.sqr(e))));return{c0:B.mul(t,n),c1:B.neg(B.mul(e,n))}},div:(t,e)=>R.mul(t,"bigint"==typeof e?n.inv(n.create(e)):R.inv(e)),pow:(t,e)=>Ht(R,t,e),invertBatch:t=>jt(R,t),add:v,sub:S,mul:x,sqr:I,addN:v,subN:S,mulN:x,sqrN:I,fromBytes:t=>{if(t.length!==R.BYTES)throw new Error("fromBytes invalid length="+t.length);return{c0:B.fromBytes(t.subarray(0,B.BYTES)),c1:B.fromBytes(t.subarray(B.BYTES))}},toBytes:({c0:t,c1:e})=>ft(B.toBytes(t),B.toBytes(e)),cmov:({c0:t,c1:e},{c0:n,c1:r},i)=>({c0:B.cmov(t,n,i),c1:B.cmov(e,r,i)}),fromBigTwelve:t=>({c0:B.fromBigSix(t.slice(0,6)),c1:B.fromBigSix(t.slice(6,12))}),frobeniusMap(t,e){const{c0:n,c1:r,c2:i}=B.frobeniusMap(t.c1,e),o=b[e%12];return{c0:B.frobeniusMap(t.c0,e),c1:B.create({c0:h.mul(n,o),c1:h.mul(r,o),c2:h.mul(i,o)})}},mulByFp2:({c0:t,c1:e},n)=>({c0:B.mulByFp2(t,n),c1:B.mulByFp2(e,n)}),conjugate:({c0:t,c1:e})=>({c0:t,c1:B.neg(e)}),mul014:({c0:t,c1:e},n,r,i)=>{let o=B.mul01(t,n,r),s=B.mul1(e,i);return{c0:B.add(B.mulByNonresidue(s),o),c1:B.sub(B.sub(B.mul01(B.add(e,t),n,h.add(r,i)),o),s)}},mul034:({c0:t,c1:e},n,r,i)=>{const o=B.create({c0:h.mul(t.c0,n),c1:h.mul(t.c1,n),c2:h.mul(t.c2,n)}),s=B.mul01(e,r,i),c=B.mul01(B.add(t,e),h.add(n,r),i);return{c0:B.add(B.mulByNonresidue(s),o),c1:B.sub(c,B.add(o,s))}},_cyclotomicSquare:t.Fp12cyclotomicSquare,_cyclotomicExp:t.Fp12cyclotomicExp,finalExponentiate:t.Fp12finalExponentiate};return{Fp:n,Fp2:h,Fp6:B,Fp4Square:function(t,e){const n=h.sqr(t),r=h.sqr(e);return{first:h.add(h.mulByNonresidue(r),n),second:h.sub(h.sub(h.sqr(h.add(t,e)),n),r)}},Fp12:R}}({ORDER:BigInt("21888242871839275222246405745257275088696311157297823662689037894645226208583"),FP2_NONRESIDUE:[BigInt(9),ve],Fp2mulByB:t=>Te.mul(t,Pe),Fp12cyclotomicSquare:({c0:t,c1:e})=>{const{c0:n,c1:r,c2:i}=t,{c0:o,c1:s,c2:c}=e,{first:a,second:u}=ze(n,s),{first:l,second:d}=ze(o,i),{first:f,second:h}=ze(r,c);let g=Te.mulByNonresidue(h);return{c0:Fe.create({c0:Te.add(Te.mul(Te.sub(a,n),Se),a),c1:Te.add(Te.mul(Te.sub(l,r),Se),l),c2:Te.add(Te.mul(Te.sub(f,i),Se),f)}),c1:Fe.create({c0:Te.add(Te.mul(Te.add(g,o),Se),g),c1:Te.add(Te.mul(Te.add(u,s),Se),u),c2:Te.add(Te.mul(Te.add(d,c),Se),d)})}},Fp12cyclotomicExp(t,e){let n=Ce.ONE;for(let r=Oe-1;r>=0;r--)n=Ce._cyclotomicSquare(n),wt(e,r)&&(n=Ce.mul(n,t));return n},Fp12finalExponentiate:t=>{const e=t=>Ce.conjugate(Ce._cyclotomicExp(t,Re)),n=Ce.mul(Ce.conjugate(t),Ce.inv(t)),r=Ce.mul(Ce.frobeniusMap(n,2),n),i=Ce._cyclotomicSquare(e(r)),o=Ce.mul(Ce._cyclotomicSquare(i),i),s=e(o),c=e(Ce._cyclotomicSquare(s)),a=Ce.mul(Ce.mul(Ce.conjugate(c),s),Ce.conjugate(o)),u=Ce.mul(a,i);return Ce.mul(Ce.frobeniusMap(Ce.mul(Ce.conjugate(r),u),3),Ce.mul(Ce.frobeniusMap(a,2),Ce.mul(Ce.frobeniusMap(u,1),Ce.mul(Ce.mul(a,s),r))))}}),{G2psi:De,psi:He}=function(t,e,n){const r=e.pow(n,(t.ORDER-we)/Be),i=e.pow(n,(t.ORDER-we)/Ee);function o(t,n){return[e.mul(e.frobeniusMap(t,1),r),e.mul(e.frobeniusMap(n,1),i)]}const s=e.pow(n,(t.ORDER**Ee-we)/Be),c=e.pow(n,(t.ORDER**Ee-we)/Ee);if(!e.eql(c,e.neg(e.ONE)))throw new Error("psiFrobenius: PSI2_Y!==-1");function a(t,n){return[e.mul(t,s),e.neg(n)]}const u=t=>(e,n)=>{const r=n.toAffine(),i=t(r.x,r.y);return e.fromAffine({x:i[0],y:i[1]})};return{psi:o,psi2:a,G2psi:u(o),G2psi2:u(a),PSI_X:r,PSI_Y:i,PSI2_X:s,PSI2_Y:c}}(qe,Te,Te.NONRESIDUE),je=Object.freeze({DST:"BN254G2_XMD:SHA-256_SVDW_RO_",encodeDST:"BN254G2_XMD:SHA-256_SVDW_RO_",p:qe.ORDER,m:2,k:128,expand:"xmd",hash:Z}),Ue=function(t){const{Fp:e,Fr:n,Fp2:r,Fp6:i,Fp12:o}=t.fields,s=t.params.xNegative,c=t.params.twistType,a=se({n:n.ORDER,...t.G1}),u=Object.assign(a,fe(a.ProjectivePoint,t.G1.mapToCurve,{...t.htfDefaults,...t.G1.htfDefaults})),l=se({n:n.ORDER,...t.G2}),d=Object.assign(l,fe(l.ProjectivePoint,t.G2.mapToCurve,{...t.htfDefaults,...t.G2.htfDefaults}));let f;if("multiplicative"===c)f=(t,e,n,i,s,c)=>o.mul014(i,t,r.mul(e,s),r.mul(n,c));else{if("divisive"!==c)throw new Error("bls: unknown twist type");f=(t,e,n,i,s,c)=>o.mul034(i,r.mul(n,c),r.mul(e,s),t)}const h=r.div(r.ONE,r.mul(r.ONE,pe));function g(t,e,n,i){const o=r.sqr(n),s=r.sqr(i),c=r.mulByB(r.mul(s,me)),a=r.mul(c,me),u=r.sub(r.sub(r.sqr(r.add(n,i)),s),o),l=r.sub(c,o),d=r.mul(r.sqr(e),me),f=r.neg(u);return t.push([l,d,f]),{Rx:e=r.mul(r.mul(r.mul(r.sub(o,a),e),n),h),Ry:n=r.sub(r.sqr(r.mul(r.add(o,a),h)),r.mul(r.sqr(c),me)),Rz:i=r.mul(o,u)}}function p(t,e,n,i,o,s){const c=r.sub(n,r.mul(s,i)),a=r.sub(e,r.mul(o,i)),u=r.sub(r.mul(c,o),r.mul(a,s)),l=r.neg(c),d=a;t.push([u,l,d]);const f=r.sqr(a),h=r.mul(f,a),g=r.mul(f,e),p=r.add(r.sub(h,r.mul(g,pe)),r.mul(r.sqr(c),i));return{Rx:e=r.mul(a,p),Ry:n=r.sub(r.mul(r.sub(g,p),c),r.mul(h,n)),Rz:i=r.mul(i,h)}}const m=function(t){const e=[];for(;t>ge;t>>=ge)(t&ge)===he?e.unshift(0):(t&me)===me?(e.unshift(-1),t+=ge):e.unshift(1);return e}(t.params.ateLoopSize),y=St((e=>{const n=e,{x:i,y:o}=n.toAffine(),s=i,c=o,a=r.neg(o);let u=s,l=c,d=r.ONE;const f=[];for(const t of m){const e=[];({Rx:u,Ry:l,Rz:d}=g(e,u,l,d)),t&&({Rx:u,Ry:l,Rz:d}=p(e,u,l,d,s,-1===t?a:c)),f.push(e)}if(t.postPrecompute){const e=f[f.length-1];t.postPrecompute(u,l,d,s,c,p.bind(null,e))}return f}));function w(t,e=!1){let n=o.ONE;if(t.length){const e=t[0][0].length;for(let r=0;r<e;r++){n=o.sqr(n);for(const[e,i,o]of t)for(const[t,s,c]of e[r])n=f(t,s,c,n,i,o)}}return s&&(n=o.conjugate(n)),e?o.finalExponentiate(n):n}function E(t,e=!0){const n=[];u.ProjectivePoint.normalizeZ(t.map((({g1:t})=>t))),d.ProjectivePoint.normalizeZ(t.map((({g2:t})=>t)));for(const{g1:e,g2:r}of t){if(e.equals(u.ProjectivePoint.ZERO)||r.equals(d.ProjectivePoint.ZERO))throw new Error("pairing is not available for ZERO point");e.assertValidity(),r.assertValidity();const t=e.toAffine();n.push([y(r),t.x,t.y])}return w(n,e)}const B={randomPrivateKey:()=>{const e=kt(n.ORDER);return Mt(t.randomBytes(e),n.ORDER)},calcPairingPrecomputes:y},{ShortSignature:b}=t.G1,{Signature:v}=t.G2;function S(t){return t instanceof u.ProjectivePoint?t:u.ProjectivePoint.fromHex(t)}function x(t,e){return t instanceof u.ProjectivePoint?t:u.hashToCurve(dt("point",t),e)}function I(t){return t instanceof d.ProjectivePoint?t:v.fromHex(t)}function R(t,e){return t instanceof d.ProjectivePoint?t:d.hashToCurve(dt("point",t),e)}function O(t){if(!Array.isArray(t)||0===t.length)throw new Error("expected non-empty array")}return u.ProjectivePoint.BASE._setWindowSize(4),{getPublicKey:function(t){return u.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},getPublicKeyForShortSignatures:function(t){return d.ProjectivePoint.fromPrivateKey(t).toRawBytes(!0)},sign:function(t,e,n){const r=R(t,n);r.assertValidity();const i=r.multiply(u.normPrivateKeyToScalar(e));return t instanceof d.ProjectivePoint?i:v.toRawBytes(i)},signShortSignature:function(t,e,n){const r=x(t,n);r.assertValidity();const i=r.multiply(u.normPrivateKeyToScalar(e));return t instanceof u.ProjectivePoint?i:b.toRawBytes(i)},verify:function(t,e,n,r){const i=S(n),s=R(e,r),c=u.ProjectivePoint.BASE,a=I(t),l=E([{g1:i.negate(),g2:s},{g1:c,g2:a}]);return o.eql(l,o.ONE)},verifyBatch:function(t,e,n,r){if(O(e),n.length!==e.length)throw new Error("amount of public keys and messages should be equal");const i=I(t),s=e.map((t=>R(t,r))),c=n.map(S),a=new Map;for(let t=0;t<c.length;t++){const e=c[t],n=s[t];let r=a.get(n);void 0===r&&(r=[],a.set(n,r)),r.push(e)}const l=[];try{for(const[t,e]of a){const n=e.reduce(((t,e)=>t.add(e)));l.push({g1:n,g2:t})}return l.push({g1:u.ProjectivePoint.BASE.negate(),g2:i}),o.eql(E(l),o.ONE)}catch{return!1}},verifyShortSignature:function(t,e,n,r){const i=I(n),s=x(e,r),c=d.ProjectivePoint.BASE,a=E([{g1:s,g2:i},{g1:S(t),g2:c.negate()}]);return o.eql(a,o.ONE)},aggregatePublicKeys:function(t){O(t);const e=t.map(S).reduce(((t,e)=>t.add(e)),u.ProjectivePoint.ZERO);return t[0]instanceof u.ProjectivePoint?(e.assertValidity(),e):e.toRawBytes(!0)},aggregateSignatures:function(t){O(t);const e=t.map(I).reduce(((t,e)=>t.add(e)),d.ProjectivePoint.ZERO);return t[0]instanceof d.ProjectivePoint?(e.assertValidity(),e):v.toRawBytes(e)},aggregateShortSignatures:function(t){O(t);const e=t.map(S).reduce(((t,e)=>t.add(e)),u.ProjectivePoint.ZERO);return t[0]instanceof u.ProjectivePoint?(e.assertValidity(),e):b.toRawBytes(e)},millerLoopBatch:w,pairing:function(t,e,n=!0){return E([{g1:t,g2:e}],n)},pairingBatch:E,G1:u,G2:d,Signature:v,ShortSignature:b,fields:{Fr:n,Fp:e,Fp2:r,Fp6:i,Fp12:o},params:{ateLoopSize:t.params.ateLoopSize,r:t.params.r,G1b:t.G1.b,G2b:t.G2.b},utils:B}}({fields:{Fp:qe,Fp2:Te,Fp6:Fe,Fp12:Ce,Fr:Ne},G1:{Fp:qe,h:BigInt(1),Gx:BigInt(1),Gy:BigInt(2),a:qe.ZERO,b:xe,htfDefaults:{...je,m:1,DST:"BN254G2_XMD:SHA-256_SVDW_RO_"},wrapPrivateKey:!0,allowInfinityPoint:!0,mapToCurve:vt,fromBytes:vt,toBytes:vt,ShortSignature:{fromHex:vt,toRawBytes:vt,toHex:vt}},G2:{Fp:Te,h:BigInt("21888242871839275222246405745257275088844257914179612981679871602714643921549"),Gx:Te.fromBigTuple([BigInt("10857046999023057135944570762232829481370756359578518086990519993285655852781"),BigInt("11559732032986387107991004021392285783925812861821192530917403151452391805634")]),Gy:Te.fromBigTuple([BigInt("8495653923123431417604973247489272438418190587263600148770280649306958101930"),BigInt("4082367875863433681332203403145435568316851327593401208105741076214120093531")]),a:Te.ZERO,b:Pe,hEff:BigInt("21888242871839275222246405745257275088844257914179612981679871602714643921549"),htfDefaults:{...je},wrapPrivateKey:!0,allowInfinityPoint:!0,isTorsionFree:(t,e)=>e.multiplyUnsafe(Ae).equals(De(t,e)),mapToCurve:vt,fromBytes:vt,toBytes:vt,Signature:{fromHex:vt,toRawBytes:vt,toHex:vt}},params:{ateLoopSize:Re*Ie+Se,r:Ne.ORDER,xNegative:!1,twistType:"divisive"},htfDefaults:je,hash:Z,randomBytes:z,postPrecompute:(t,e,n,r,i,o)=>{const s=He(r,i);({Rx:t,Ry:e,Rz:n}=o(t,e,n,s[0],s[1]));const c=He(s[0],s[1]);o(t,e,n,c[0],Te.neg(c[1]))}});!function(t){const e=function(t){const e=ee(t);return bt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r,nByteLength:i,nBitLength:o}=e,s=n.BYTES+1,c=2*n.BYTES+1;function a(t){return qt(t,r)}function u(t){return Tt(t,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:d,weierstrassEquation:f,isWithinCurveOrder:h}=se({...e,toBytes(t,e,r){const i=e.toAffine(),o=n.toBytes(i.x),s=ft;return Y("isCompressed",r),r?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,n.toBytes(i.y))},fromBytes(t){const e=t.length,r=t[0],i=t.subarray(1);if(e!==s||2!==r&&3!==r){if(e===c&&4===r){return{x:n.fromBytes(i.subarray(0,n.BYTES)),y:n.fromBytes(i.subarray(n.BYTES,2*n.BYTES))}}throw new Error("invalid Point, expected length of "+s+", or uncompressed "+c+", got "+e)}{const t=ct(i);if(!pt(t,re,n.ORDER))throw new Error("Point is not on curve");const e=f(t);let o;try{o=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!==((o&re)===re)&&(o=n.neg(o)),{x:t,y:o}}}});function g(t){return t>r>>re}const p=(t,e,n)=>ct(t.slice(e,n));class m{constructor(t,e,n){mt("r",t,re,r),mt("s",e,re,r),this.r=t,this.s=e,null!=n&&(this.recovery=n),Object.freeze(this)}static fromCompact(t){const e=i;return dt("compactSignature",t,2*e),new m(p(t,0,e),p(t,e,2*e))}static fromDER(t){const{r:e,s:n}=DER.toSig(dt("DER",t));return new m(e,n)}assertValidity(){}addRecoveryBit(t){return new m(this.r,this.s,t)}recoverPublicKey(t){const{r:r,s:i,recovery:o}=this,s=B(dt("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const c=2===o||3===o?r+e.n:r;if(c>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const d=1&o?"03":"02",f=l.fromHex(d+numToSizedHex(c,n.BYTES)),h=u(c),g=a(-s*h),p=a(i*h),m=l.BASE.multiplyAndAddUnsafe(f,g,p);if(!m)throw new Error("point at infinify");return m.assertValidity(),m}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new m(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return st(this.toDERHex())}toDERHex(){return DER.hexFromSig(this)}toCompactRawBytes(){return st(this.toCompactHex())}toCompactHex(){const t=i;return numToSizedHex(this.r,t)+numToSizedHex(this.s,t)}}const y={isValidPrivateKey(t){try{return d(t),!0}catch(t){return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const t=kt(e.n);return Mt(e.randomBytes(t),e.n)},precompute:(t=8,e=l.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function w(t){if("bigint"==typeof t)return!1;if(t instanceof l)return!0;const r=dt("key",t).length,o=n.BYTES,s=o+1,c=2*o+1;return e.allowedPrivateKeyLengths||i===s?void 0:r===s||r===c}const E=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=ct(t),n=8*t.length-o;return n>0?e>>BigInt(n):e},B=e.bits2int_modN||function(t){return a(E(t))},b=Et(o);function v(t){return mt("num < 2^"+o,t,ne,b),ut(t,i)}function S(t,r,i=x){if(["recovered","canonical"].some((t=>t in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:s}=e;let{lowS:c,prehash:f,extraEntropy:p}=i;null==c&&!0,dt("msgHash",t),validateSigVerOpts(i),f&&dt("prehashed msgHash",o(t));const y=B(t),w=d(r),b=[v(w),v(y)];if(null!=p&&!1!==p){const t=!0===p?s(n.BYTES):p;b.push(dt("extraEntropy",t))}const S=ft(...b),I=y;return{seed:S,k2sig:function(t){const e=E(t);if(!h(e))return;const n=u(e),r=l.BASE.multiply(e).toAffine(),i=a(r.x);if(i===ne)return;const o=a(n*a(I+i*w));if(o===ne)return;let s=(r.x===i?0:2)|Number(r.y&re),d=o;return c&&g(o)&&(function(t){return g(t)?a(-t):t}(o),1),new m(i,d,s)}}}const x={lowS:e.lowS,prehash:!1},I={lowS:e.lowS,prehash:!1};l.BASE._setWindowSize(8)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */({a:BigInt(0),b:BigInt(3),Fp:qe,n:BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"),Gx:BigInt(1),Gy:BigInt(2),h:BigInt(1),...function(t){return{hash:t,hmac:(e,...n)=>k(t,e,function(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];R(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}(...n)),randomBytes:z}}(Z)});const Le="groth16",Ze=new TextDecoder,_e=BigInt(0),ke=Ue.fields.Fp2,Me=Ue.fields.Fp12;async function Ve(t,e,n){const r=await B(n),i=(new TextDecoder).decode(t),s=JSON.parse(i),c=await r.calculateWTNSBin(s,0),{proof:a,publicSignals:u}=await o.prove(e,c);return{proof:a,pub_signals:u}}const[Ge,We]=[Ue.G1.ProjectivePoint,Ue.G2.ProjectivePoint],Ye=([t,e])=>Ge.fromAffine({x:BigInt(t),y:BigInt(e)}),Ke=([[t,e],[n,r]])=>We.fromAffine({x:ke.fromBigTuple([BigInt(t),BigInt(e)]),y:ke.fromBigTuple([BigInt(n),BigInt(r)])});async function $e(e,n,r,i){if(i(n.pub_signals).challenge!==t(e))throw new Error("challenge is not equal to message hash");return Je(n,JSON.parse(Ze.decode(r)))}function Je(t,e){if(!e.IC)throw new Error("verification file doesn't exist for circuit");const{proof:n,pub_signals:r}=t;if(r.length+1!==e.IC.length)throw new Error(`Invalid number of public signals, expected ${e.IC.length-1} but got ${r.length}`);let i=Ge.ZERO;for(let t=0;t<r.length;t++){if(BigInt(r[t])<_e||BigInt(r[t])>=Ue.G1.CURVE.n)throw new Error(`Input value is not in the field ${Ue.G1.CURVE.n}`);if(BigInt(r[t])!==_e){const[n,o]=e.IC[t+1].map(BigInt);i=i.add(Ge.fromAffine({x:n,y:o}).multiply(BigInt(r[t])))}}i=i.add(Ye(e.IC[0]));const o=Ue.pairingBatch([{g1:Ye(n.pi_a).negate(),g2:Ke(n.pi_b)},{g1:i,g2:Ke(e.vk_gamma_2)},{g1:Ye(n.pi_c),g2:Ke(e.vk_delta_2)},{g1:Ye(e.vk_alpha_1),g2:Ke(e.vk_beta_2)}]);return Me.eql(o,Me.ONE)}const Xe=new class{constructor(t){this.methodAlg=t}get alg(){return this.methodAlg.alg}get circuitId(){return this.methodAlg.circuitId}unmarshall(t){const e={};if(3!=t.length)throw new Error(`invalid number of Output values expected 3 got ${t.length}`);return e.challenge=BigInt(t[0]),e.userState=BigInt(t[1]),e.userId=n.fromBigInt(BigInt(t[2])),e}async verify(t,e,n){return $e(t,e,n,this.unmarshall)}prove(t,e,n){return Ve(t,e,n)}}(new l(Le,"auth"));class Qe{constructor(t){this.methodAlg=t}get alg(){return this.methodAlg.alg}get circuitId(){return this.methodAlg.circuitId}async verify(t,e,n){return $e(t,e,n,this.unmarshall)}async prove(t,e,n){const r=await Ve(t,e,n);return await this.terminateCurve(),r}async terminateCurve(){(await c(Qe.curveName)).terminate()}unmarshall(t){if(3!==t.length)throw new Error(`invalid number of Output values expected 3 got ${t.length}`);return{userID:n.fromBigInt(BigInt(t[0])),challenge:BigInt(t[1]),GISTRoot:s.fromString(t[2])}}}Qe.curveName="bn128";const tn=new Qe(new l(Le,"authV2"));f(Xe.methodAlg,(()=>Xe)),f(tn.methodAlg,(()=>tn));const en={registerProvingMethod:f,getProvingMethod:h,provingMethodGroth16AuthInstance:Xe,provingMethodGroth16AuthV2Instance:tn};export{g as Header,l as ProvingMethodAlg,E as Token,u as hash,en as proving,Je as verifyGroth16Proof};
//# sourceMappingURL=index.js.map
