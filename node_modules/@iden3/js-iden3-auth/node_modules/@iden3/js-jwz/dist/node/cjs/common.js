"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyGroth16Proof = exports.verify = exports.prove = exports.AuthV2Circuit = exports.AuthCircuit = exports.Groth16 = void 0;
const witness_calculator_1 = require("./witness_calculator");
const snarkjs_1 = require("snarkjs");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const bn254_1 = require("@noble/curves/bn254");
exports.Groth16 = 'groth16';
exports.AuthCircuit = 'auth';
exports.AuthV2Circuit = 'authV2';
const textDecoder = new TextDecoder();
const ZERO_BIGINT = BigInt(0);
const Fp2 = bn254_1.bn254.fields.Fp2;
const Fp12 = bn254_1.bn254.fields.Fp12;
async function prove(inputs, provingKey, wasm) {
    const witnessCalculator = await (0, witness_calculator_1.witnessBuilder)(wasm);
    const jsonString = new TextDecoder().decode(inputs);
    const parsedData = JSON.parse(jsonString);
    const wtnsBytes = await witnessCalculator.calculateWTNSBin(parsedData, 0);
    const { proof, publicSignals } = await snarkjs_1.groth16.prove(provingKey, wtnsBytes);
    return {
        proof: proof,
        pub_signals: publicSignals
    };
}
exports.prove = prove;
const [G1PP, G2PP] = [bn254_1.bn254.G1.ProjectivePoint, bn254_1.bn254.G2.ProjectivePoint];
const toG1 = ([x, y]) => G1PP.fromAffine({ x: BigInt(x), y: BigInt(y) });
const toG2 = ([[x0, y0], [x1, y1]]) => {
    return G2PP.fromAffine({
        x: Fp2.fromBigTuple([BigInt(x0), BigInt(y0)]),
        y: Fp2.fromBigTuple([BigInt(x1), BigInt(y1)])
    });
};
async function verify(messageHash, proof, verificationKey, unmarshall) {
    const outputs = unmarshall(proof.pub_signals);
    if (outputs.challenge !== (0, js_iden3_core_1.fromBigEndian)(messageHash)) {
        throw new Error('challenge is not equal to message hash');
    }
    const vk = JSON.parse(textDecoder.decode(verificationKey));
    return verifyGroth16Proof(proof, vk);
}
exports.verify = verify;
function verifyGroth16Proof(zkp, vk) {
    if (!vk.IC) {
        throw new Error(`verification file doesn't exist for circuit`);
    }
    const { proof, pub_signals } = zkp;
    if (pub_signals.length + 1 !== vk.IC.length) {
        throw new Error(`Invalid number of public signals, expected ${vk.IC.length - 1} but got ${pub_signals.length}`);
    }
    let cpub = G1PP.ZERO;
    for (let i = 0; i < pub_signals.length; i++) {
        // check input inside field
        if (BigInt(pub_signals[i]) < ZERO_BIGINT || BigInt(pub_signals[i]) >= bn254_1.bn254.G1.CURVE.n) {
            throw new Error(`Input value is not in the field ${bn254_1.bn254.G1.CURVE.n}`);
        }
        // Skip multiplication by 0 since it contributes nothing to the sum
        if (BigInt(pub_signals[i]) !== ZERO_BIGINT) {
            const [x, y] = vk.IC[i + 1].map(BigInt);
            cpub = cpub.add(G1PP.fromAffine({ x, y }).multiply(BigInt(pub_signals[i])));
        }
    }
    cpub = cpub.add(toG1(vk.IC[0]));
    const newRes = bn254_1.bn254.pairingBatch([
        { g1: toG1(proof.pi_a).negate(), g2: toG2(proof.pi_b) },
        { g1: cpub, g2: toG2(vk.vk_gamma_2) },
        { g1: toG1(proof.pi_c), g2: toG2(vk.vk_delta_2) },
        { g1: toG1(vk.vk_alpha_1), g2: toG2(vk.vk_beta_2) }
    ]);
    return Fp12.eql(newRes, Fp12.ONE);
}
exports.verifyGroth16Proof = verifyGroth16Proof;
