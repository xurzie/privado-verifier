{"version":3,"file":"common.js","sourceRoot":"","sources":["../../src/common.ts"],"names":[],"mappings":"","sourcesContent":["/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\nimport type {\n  FunctionFragment,\n  Typed,\n  EventFragment,\n  ContractTransaction,\n  ContractTransactionResponse,\n  DeferredTopicFilter,\n  EventLog,\n  TransactionRequest,\n  LogDescription\n} from 'ethers';\n\nexport interface TypedDeferredTopicFilter<_TCEvent extends TypedContractEvent>\n  extends DeferredTopicFilter {}\n\nexport interface TypedContractEvent<\n  InputTuple extends Array<any> = any,\n  OutputTuple extends Array<any> = any,\n  OutputObject = any\n> {\n  (...args: Partial<InputTuple>): TypedDeferredTopicFilter<\n    TypedContractEvent<InputTuple, OutputTuple, OutputObject>\n  >;\n  name: string;\n  fragment: EventFragment;\n  getFragment(...args: Partial<InputTuple>): EventFragment;\n}\n\ntype __TypechainAOutputTuple<T> = T extends TypedContractEvent<infer _U, infer W> ? W : never;\ntype __TypechainOutputObject<T> = T extends TypedContractEvent<infer _U, infer _W, infer V>\n  ? V\n  : never;\n\nexport interface TypedEventLog<TCEvent extends TypedContractEvent> extends Omit<EventLog, 'args'> {\n  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;\n}\n\nexport interface TypedLogDescription<TCEvent extends TypedContractEvent>\n  extends Omit<LogDescription, 'args'> {\n  args: __TypechainAOutputTuple<TCEvent> & __TypechainOutputObject<TCEvent>;\n}\n\nexport type TypedListener<TCEvent extends TypedContractEvent> = (\n  ...listenerArg: [...__TypechainAOutputTuple<TCEvent>, TypedEventLog<TCEvent>, ...undefined[]]\n) => void;\n\nexport type MinEthersFactory<C, ARGS> = {\n  deploy(...a: ARGS[]): Promise<C>;\n};\n\nexport type GetContractTypeFromFactory<F> = F extends MinEthersFactory<infer C, any> ? C : never;\nexport type GetARGsTypeFromFactory<F> = F extends MinEthersFactory<any, any>\n  ? Parameters<F['deploy']>\n  : never;\n\nexport type StateMutability = 'nonpayable' | 'payable' | 'view';\n\nexport type BaseOverrides = Omit<TransactionRequest, 'to' | 'data'>;\nexport type NonPayableOverrides = Omit<BaseOverrides, 'value' | 'blockTag' | 'enableCcipRead'>;\nexport type PayableOverrides = Omit<BaseOverrides, 'blockTag' | 'enableCcipRead'>;\nexport type ViewOverrides = Omit<TransactionRequest, 'to' | 'data'>;\nexport type Overrides<S extends StateMutability> = S extends 'nonpayable'\n  ? NonPayableOverrides\n  : S extends 'payable'\n  ? PayableOverrides\n  : ViewOverrides;\n\nexport type PostfixOverrides<A extends Array<any>, S extends StateMutability> =\n  | A\n  | [...A, Overrides<S>];\nexport type ContractMethodArgs<A extends Array<any>, S extends StateMutability> = PostfixOverrides<\n  { [I in keyof A]-?: A[I] | Typed },\n  S\n>;\n\nexport type DefaultReturnType<R> = R extends Array<any> ? R[0] : R;\n\n// export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = R | ContractTransactionResponse> {\nexport interface TypedContractMethod<\n  A extends Array<any> = Array<any>,\n  R = any,\n  S extends StateMutability = 'payable'\n> {\n  (...args: ContractMethodArgs<A, S>): S extends 'view'\n    ? Promise<DefaultReturnType<R>>\n    : Promise<ContractTransactionResponse>;\n\n  name: string;\n\n  fragment: FunctionFragment;\n\n  getFragment(...args: ContractMethodArgs<A, S>): FunctionFragment;\n\n  populateTransaction(...args: ContractMethodArgs<A, S>): Promise<ContractTransaction>;\n  staticCall(...args: ContractMethodArgs<A, 'view'>): Promise<DefaultReturnType<R>>;\n  send(...args: ContractMethodArgs<A, S>): Promise<ContractTransactionResponse>;\n  estimateGas(...args: ContractMethodArgs<A, S>): Promise<bigint>;\n  staticCallResult(...args: ContractMethodArgs<A, 'view'>): Promise<R>;\n}\n"]}