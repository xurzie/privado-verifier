{
  "version": 3,
  "sources": ["../../../src/constants/hash.ts", "../../../src/constants/node.ts", "../../../src/constants/data.ts", "../../../src/constants/proof.ts", "../../../src/constants/field.ts", "../../../src/lib/utils/crypto.ts", "../../../src/lib/utils/bytes.ts", "../../../src/lib/utils/merkletree.ts", "../../../src/lib/utils/bigint.ts", "../../../src/lib/hash/hash.ts", "../../../src/lib/db/inMemory.ts", "../../../src/lib/utils/node.ts", "../../../src/lib/node/node.ts", "../../../src/lib/db/localStorage.ts", "../../../src/lib/db/indexedDB.ts", "../../../src/lib/entry/elemBytes.ts", "../../../src/lib/entry/data.ts", "../../../src/lib/entry/entry.ts", "../../../src/lib/errors/merkletree.ts", "../../../src/lib/errors/db.ts", "../../../src/lib/merkletree/circom.ts", "../../../src/lib/errors/proof.ts", "../../../src/lib/merkletree/proof.ts", "../../../src/lib/merkletree/merkletree.ts"],
  "sourcesContent": ["export const HASH_BYTES_LENGTH = 32;\n", "// middle node.ts with children\nimport { NodeType } from '../types';\n\nexport const NODE_TYPE_MIDDLE: NodeType = 0;\n// Leaf node.ts with a key and a value\nexport const NODE_TYPE_LEAF: NodeType = 1;\n// empty node.ts\nexport const NODE_TYPE_EMPTY: NodeType = 2;\n\nexport const NODE_VALUE_BYTE_ARR_LENGTH = 65;\n\nexport const EMPTY_NODE_VALUE = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n\nexport const EMPTY_NODE_STRING = 'empty';\n", "export const ELEM_BYTES_LEN = 32;\nexport const DATA_LEN = 8;\nexport const DATA_LEN_BYTES = DATA_LEN * ELEM_BYTES_LEN;\n", "import { ELEM_BYTES_LEN } from './data';\nexport const PROOF_FLAG_LEN = 2;\nexport const NOT_EMPTIES_LEN = ELEM_BYTES_LEN - PROOF_FLAG_LEN;\n", "const qString = '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport const FIELD_SIZE = BigInt(qString);\nexport const MAX_NUM_IN_FIELD = FIELD_SIZE - BigInt('1');\n", "import { FIELD_SIZE } from '../../constants/field';\n\nexport const checkBigIntInField = (bigNum: bigint): boolean => {\n  return bigNum < FIELD_SIZE;\n};\n", "import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types/bytes';\nimport { checkBigIntInField } from './crypto';\n\nexport const bytesEqual: (b1: Bytes, b2: Bytes) => boolean = (b1, b2) => {\n  return b1.every((ele, idx) => ele === b2[idx]);\n};\n\n// TODO: might be make this generic over typed arrays?\nexport const swapEndianness = (bytes: Bytes): Bytes => {\n  return bytes.slice().reverse();\n};\n\nexport const bytes2BinaryString = (bytes: Bytes): string => {\n  return '0b' + bytes.reduce((acc, i) => acc + i.toString(2).padStart(8, '0'), '');\n};\n\nexport const testBit = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[parseInt((n / 8).toString())] & (1 << n % 8)) !== 0;\n};\n\nexport const testBitBigEndian = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] & (1 << n % 8)) !== 0;\n};\n\n// SetBitBigEndian sets the bit n in the bitmap to 1, in Big Endian.\nexport const setBitBigEndian = (bitMap: Bytes, n: number): void => {\n  bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] |= 1 << n % 8;\n};\n\nconst hexTable = '0123456789abcdef';\nexport const bytes2Hex = (u: Bytes): string => {\n  const arr = new Array(u.length * 2);\n  let j = 0;\n  u.forEach((v) => {\n    arr[j] = hexTable[parseInt((v >> 4).toString(10))];\n    arr[j + 1] = hexTable[parseInt((v & 15).toString(10))];\n    j += 2;\n  });\n\n  return arr.join('');\n};\n\n// NOTE: `bytes` should be big endian\n// bytes received from Hash.value getter are safe to use since their endianness is swapped, for the same reason the private Hash.bytes { stored in little endian } should never be used\nexport const newBigIntFromBytes = (bytes: Bytes): bigint => {\n  if (bytes.length !== HASH_BYTES_LENGTH) {\n    throw `Expected 32 bytes, found ${bytes.length} bytes`;\n  }\n\n  const bigNum = BigInt(bytes2BinaryString(bytes));\n  if (!checkBigIntInField(bigNum)) {\n    throw 'NewBigIntFromHashBytes: Value not inside the Finite Field';\n  }\n\n  return bigNum;\n};\n\nexport const str2Bytes = (str: string): Bytes =>\n  new Uint8Array(str.length * 2).map((_, i) => str.charCodeAt(i));\n", "// const siblingBytes = bs.slice(this.notEmpties.length + PROOF_FLAG_LEN);\nimport { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\nimport { Path, Siblings } from '../../types/merkletree';\nimport { testBit } from './bytes';\n\nexport const getPath = (numLevels: number, k: Bytes): Path => {\n  const path = new Array<boolean>(numLevels);\n\n  for (let idx = 0; idx < numLevels; idx += 1) {\n    path[idx] = testBit(k, idx);\n  }\n  return path;\n};\n\nexport const siblings2Bytes = (siblings: Siblings): Bytes => {\n  const siblingBytesBuff = new ArrayBuffer(HASH_BYTES_LENGTH * siblings.length);\n  const siblingBytes = new Uint8Array(siblingBytesBuff);\n  siblings.forEach((v, i) => {\n    siblingBytes.set(v.value, i * HASH_BYTES_LENGTH);\n  });\n\n  return siblingBytes;\n};\n", "import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\n\nexport const bigint2Array = (bigNum: bigint, radix?: number): Array<number> => {\n  return bigNum\n    .toString(radix ? radix : 10)\n    .split('')\n    .map((n) => {\n      return parseInt(n);\n    });\n};\n\nexport const bigIntToUINT8Array = (bigNum: bigint): Bytes => {\n  const n256 = BigInt(256);\n  const bytes = new Uint8Array(HASH_BYTES_LENGTH);\n  let i = 0;\n  while (bigNum > BigInt(0)) {\n    bytes[HASH_BYTES_LENGTH - 1 - i] = Number(bigNum % n256);\n    bigNum = bigNum / n256;\n    i += 1;\n  }\n  return bytes;\n};\n", "import { HASH_BYTES_LENGTH } from '../../constants';\nimport {\n  bytesEqual,\n  swapEndianness,\n  bytes2Hex,\n  bytes2BinaryString,\n  checkBigIntInField,\n  bigIntToUINT8Array\n} from '../utils';\nimport { Bytes, IHash, Siblings } from '../../types';\nimport { Hex, poseidon } from '@iden3/js-crypto';\n\nexport class Hash implements IHash {\n  // little endian\n  bytes: Bytes;\n\n  constructor(_bytes?: Bytes) {\n    if (_bytes?.length) {\n      if (_bytes.length !== HASH_BYTES_LENGTH) {\n        throw new Error(`Expected ${HASH_BYTES_LENGTH} bytes, found ${_bytes.length} bytes`);\n      }\n      this.bytes = _bytes;\n    } else {\n      this.bytes = new Uint8Array(HASH_BYTES_LENGTH);\n    }\n  }\n\n  // returns a new copy, in little endian\n  get value(): Bytes {\n    return this.bytes;\n  }\n\n  // bytes should be in big-endian\n  set value(bytes: Bytes) {\n    if (bytes.length !== HASH_BYTES_LENGTH) {\n      throw `Expected 32 bytes, found ${bytes.length} bytes`;\n    }\n    this.bytes = swapEndianness(bytes);\n  }\n\n  string(): string {\n    return this.bigInt().toString(10);\n  }\n\n  hex(): string {\n    return bytes2Hex(this.bytes);\n  }\n\n  equals(hash: Hash): boolean {\n    return bytesEqual(this.value, hash.value);\n  }\n\n  bigInt(): bigint {\n    const bytes = swapEndianness(this.value);\n    return BigInt(bytes2BinaryString(bytes));\n  }\n\n  static fromString(s: string): Hash {\n    try {\n      return Hash.fromBigInt(BigInt(s));\n    } catch (e) {\n      const deserializedHash = JSON.parse(s);\n      const bytes = Uint8Array.from(Object.values(deserializedHash.bytes));\n      return new Hash(bytes);\n    }\n  }\n  static fromBigInt(i: bigint): Hash {\n    if (!checkBigIntInField(i)) {\n      throw new Error('NewBigIntFromHashBytes: Value not inside the Finite Field');\n    }\n\n    const bytes = bigIntToUINT8Array(i);\n\n    return new Hash(swapEndianness(bytes));\n  }\n\n  static fromHex(h: string | undefined): Hash {\n    if (!h) {\n      return ZERO_HASH;\n    }\n    return new Hash(Hex.decodeString(h));\n  }\n\n  toJSON() {\n    return this.string();\n  }\n}\n\nexport const ZERO_HASH = new Hash();\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromBigInt = (bigNum: bigint): Hash => {\n  return Hash.fromBigInt(bigNum);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromHex = (h: string): Hash => {\n  return Hash.fromHex(h);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigString instead\n */\nexport const newHashFromString = (decimalString: string): Hash => {\n  return Hash.fromString(decimalString);\n};\n\nexport const hashElems = (e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash(e);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const hashElemsKey = (k: bigint, e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash([...e, k]);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const circomSiblingsFromSiblings = (siblings: Siblings, levels: number): Siblings => {\n  for (let i = siblings.length; i < levels; i += 1) {\n    siblings.push(ZERO_HASH);\n  }\n  return siblings;\n};\n", "// in Memory Database implementation\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class InMemoryDB implements ITreeStorage {\n  prefix: Bytes;\n  private _kvMap: {\n    [k in string]: Node;\n  };\n  private _currentRoot: Hash;\n\n  constructor(_prefix: Bytes) {\n    this.prefix = _prefix;\n    this._kvMap = {};\n    this._currentRoot = ZERO_HASH;\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    const val = this._kvMap[kBytes.toString()] ? this._kvMap[kBytes.toString()] : undefined;\n    return val;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    this._kvMap[kBytes.toString()] = n;\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this._currentRoot = r;\n  }\n}\n", "// LeafKey computes the key of a leaf node given the hIndex and hValue of the\n// entry of the leaf.\nimport { Hash, hashElemsKey } from '../hash/hash';\n\nimport { NODE_VALUE_BYTE_ARR_LENGTH } from '../../constants';\nimport { bigIntToUINT8Array } from './bigint';\nimport { Bytes, NodeType } from '../../types';\n\nexport const leafKey = async (k: Hash, v: Hash): Promise<Hash> => {\n  return hashElemsKey(BigInt(1), [k.bigInt(), v.bigInt()]);\n};\n\nexport const nodeValue = (type: NodeType, a: Hash, b: Hash): Bytes => {\n  const bytes = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n  const kBytes = bigIntToUINT8Array(a.bigInt());\n  const vBytes = bigIntToUINT8Array(b.bigInt());\n  bytes[0] = type;\n\n  for (let idx = 1; idx < 33; idx += 1) {\n    bytes[idx] = kBytes[idx - 1];\n  }\n\n  for (let idx = 33; idx <= NODE_VALUE_BYTE_ARR_LENGTH; idx += 1) {\n    bytes[idx] = vBytes[idx - 33];\n  }\n\n  return bytes;\n};\n", "import { Bytes, Node, NodeType } from '../../types';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\n\nimport {\n  EMPTY_NODE_STRING,\n  EMPTY_NODE_VALUE,\n  NODE_TYPE_EMPTY,\n  NODE_TYPE_LEAF,\n  NODE_TYPE_MIDDLE\n} from '../../constants';\nimport { leafKey, nodeValue } from '../utils/node';\n\nexport class NodeLeaf implements Node {\n  type: NodeType;\n  entry: [Hash, Hash];\n  // cache used to avoid recalculating key\n  private _key: Hash;\n\n  constructor(k: Hash, v: Hash) {\n    this.type = NODE_TYPE_LEAF;\n    this.entry = [k, v];\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this._key === ZERO_HASH) {\n      return await leafKey(this.entry[0], this.entry[1]);\n    }\n    return this._key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.entry[0], this.entry[1]);\n  }\n\n  get string(): string {\n    return `Leaf I:${this.entry[0]} D:${this.entry[1]}`;\n  }\n}\n\nexport class NodeMiddle implements Node {\n  type: NodeType;\n  childL: Hash;\n  childR: Hash;\n  private _key: Hash;\n\n  constructor(cL: Hash, cR: Hash) {\n    this.type = NODE_TYPE_MIDDLE;\n    this.childL = cL;\n    this.childR = cR;\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this._key === ZERO_HASH) {\n      return hashElems([this.childL.bigInt(), this.childR.bigInt()]);\n    }\n    return this._key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.childL, this.childR);\n  }\n\n  get string(): string {\n    return `Middle L:${this.childL} R:${this.childR}`;\n  }\n}\n\nexport class NodeEmpty implements Node {\n  type: NodeType;\n  private _key: Hash;\n\n  constructor() {\n    this.type = NODE_TYPE_EMPTY;\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    return ZERO_HASH;\n  }\n\n  get value(): Bytes {\n    return EMPTY_NODE_VALUE;\n  }\n\n  get string(): string {\n    return EMPTY_NODE_STRING;\n  }\n}\n", "/* eslint-disable no-case-declarations */\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytes2Hex } from '../utils';\n\nexport class LocalStorageDB implements ITreeStorage {\n  private _currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes) {\n    const rootStr = localStorage.getItem(bytes2Hex(_prefix));\n    if (rootStr) {\n      const bytes: number[] = JSON.parse(rootStr);\n\n      this._currentRoot = new Hash(Uint8Array.from(bytes));\n    } else {\n      this._currentRoot = ZERO_HASH;\n    }\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const val = localStorage.getItem(key);\n\n    if (val === null) {\n      return undefined;\n    }\n\n    const obj = JSON.parse(val);\n    switch (obj.type) {\n      case NODE_TYPE_EMPTY:\n        return new NodeEmpty();\n      case NODE_TYPE_MIDDLE:\n        const cL = new Hash(Uint8Array.from(obj.childL));\n        const cR = new Hash(Uint8Array.from(obj.childR));\n\n        return new NodeMiddle(cL, cR);\n      case NODE_TYPE_LEAF:\n        const k = new Hash(Uint8Array.from(obj.entry[0]));\n        const v = new Hash(Uint8Array.from(obj.entry[1]));\n\n        return new NodeLeaf(k, v);\n    }\n\n    throw `error: value found for key ${bytes2Hex(kBytes)} is not of type Node`;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const toSerialize: Record<string, unknown> = {\n      type: n.type\n    };\n    if (n instanceof NodeMiddle) {\n      toSerialize.childL = Array.from(n.childL.bytes);\n      toSerialize.childR = Array.from(n.childR.bytes);\n    } else if (n instanceof NodeLeaf) {\n      toSerialize.entry = [Array.from(n.entry[0].bytes), Array.from(n.entry[1].bytes)];\n    }\n    const val = JSON.stringify(toSerialize);\n    localStorage.setItem(key, val);\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this._currentRoot = r;\n    localStorage.setItem(bytes2Hex(this._prefix), JSON.stringify(Array.from(r.bytes)));\n  }\n}\n", "import { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { bytes2Hex } from '../utils';\nimport { get, set, UseStore, createStore } from 'idb-keyval';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\n\nexport class IndexedDBStorage implements ITreeStorage {\n  public static readonly storageName = 'merkle-tree';\n\n  private readonly _prefixHash: string;\n  private readonly _store: UseStore;\n\n  private _currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes, databaseName?: string) {\n    this._currentRoot = ZERO_HASH;\n    this._prefixHash = bytes2Hex(_prefix);\n    this._store = createStore(\n      `${databaseName ?? IndexedDBStorage.storageName}-db`,\n      IndexedDBStorage.storageName\n    );\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const obj = await get(key, this._store);\n    if (obj === null || obj === undefined) {\n      return undefined;\n    }\n    if (obj.type === NODE_TYPE_EMPTY) {\n      return new NodeEmpty();\n    }\n    if (obj.type === NODE_TYPE_MIDDLE) {\n      const cL = new Hash(Uint8Array.from(obj.childL.bytes));\n      const cR = new Hash(Uint8Array.from(obj.childR.bytes));\n      return new NodeMiddle(cL, cR);\n    }\n    if (obj.type === NODE_TYPE_LEAF) {\n      const k = new Hash(Uint8Array.from(obj.entry[0].bytes));\n      const v = new Hash(Uint8Array.from(obj.entry[1].bytes));\n\n      return new NodeLeaf(k, v);\n    }\n    throw new Error(`error: value found for key ${key} is not of type Node`);\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    await set(key, n, this._store);\n  }\n\n  async getRoot(): Promise<Hash> {\n    if (!this._currentRoot.equals(ZERO_HASH)) {\n      return this._currentRoot;\n    }\n    const root = await get(this._prefixHash, this._store);\n\n    if (!root) {\n      this._currentRoot = ZERO_HASH;\n    } else {\n      this._currentRoot = new Hash(root.bytes);\n    }\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    await set(this._prefixHash, r, this._store);\n    this._currentRoot = r;\n  }\n}\n", "import { ELEM_BYTES_LEN } from '../../constants';\nimport { Bytes } from '../../types';\nimport { bytes2Hex, newBigIntFromBytes, swapEndianness } from '../utils';\n\nexport class ElemBytes {\n  // Little Endian\n  private _bytes: Bytes;\n\n  constructor() {\n    this._bytes = new Uint8Array(ELEM_BYTES_LEN);\n  }\n\n  get value(): Bytes {\n    return this._bytes;\n  }\n\n  set value(b: Bytes) {\n    this._bytes = b;\n  }\n\n  bigInt(): bigint {\n    return newBigIntFromBytes(swapEndianness(this._bytes));\n  }\n\n  string(): string {\n    const hexStr = bytes2Hex(this._bytes.slice(0, 4));\n    return `${hexStr}...`;\n  }\n}\n", "import { ElemBytes } from './elemBytes';\nimport { DATA_LEN, DATA_LEN_BYTES, ELEM_BYTES_LEN } from '../../constants';\nimport { bytesEqual } from '../utils';\nimport { Bytes } from '../../types';\n\nexport class Data {\n  private _value: Array<ElemBytes>;\n\n  constructor() {\n    this._value = new Array<ElemBytes>(DATA_LEN);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this._value;\n  }\n\n  set value(_v: ElemBytes[]) {\n    if (_v.length !== DATA_LEN) {\n      throw `expected bytes length to be ${DATA_LEN}, got ${_v.length}`;\n    }\n    this._value = _v;\n  }\n\n  bytes(): Bytes {\n    const b = new Uint8Array(DATA_LEN * ELEM_BYTES_LEN);\n\n    for (let idx = 0; idx < DATA_LEN; idx += 1) {\n      this._value[idx].value.forEach((v, _idx) => {\n        b[idx * ELEM_BYTES_LEN + _idx] = v;\n      });\n    }\n    return b;\n  }\n\n  equal(d2: Data): boolean {\n    return (\n      bytesEqual(this._value[0].value, d2.value[0].value) &&\n      bytesEqual(this._value[1].value, d2.value[1].value) &&\n      bytesEqual(this._value[2].value, d2.value[2].value) &&\n      bytesEqual(this._value[3].value, d2.value[3].value)\n    );\n  }\n}\n\nexport const newDataFromBytes = (bytes: Bytes): Data => {\n  if (bytes.length !== DATA_LEN_BYTES) {\n    throw `expected bytes length to be ${DATA_LEN_BYTES}, got ${bytes.length}`;\n  }\n  const d = new Data();\n  const arr = new Array<ElemBytes>(DATA_LEN_BYTES);\n\n  for (let i = 0; i < DATA_LEN; i += 1) {\n    const tmp = new ElemBytes();\n    tmp.value = bytes.slice(i * ELEM_BYTES_LEN, (i + 1) * DATA_LEN_BYTES);\n    arr[i] = tmp;\n  }\n\n  d.value = arr;\n  return d;\n};\n", "import { Data } from '../entry/data';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\nimport { checkBigIntInField } from '../utils';\n\nimport { ElemBytes } from './elemBytes';\n\nexport class Entry {\n  private _data: Data;\n  private _hIndex: Hash;\n  private _hValue: Hash;\n\n  constructor(_data?: Data) {\n    this._data = _data ? _data : new Data();\n    this._hIndex = ZERO_HASH;\n    this._hValue = ZERO_HASH;\n  }\n\n  get data(): Data {\n    return this._data;\n  }\n\n  get index(): Array<ElemBytes> {\n    return this._data.value.slice(0, 4);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this._data.value.slice(4, 8);\n  }\n\n  async hIndex(): Promise<Hash> {\n    if (this._hIndex === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.index));\n    }\n    return this._hIndex;\n  }\n\n  async hValue(): Promise<Hash> {\n    if (this._hValue === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.value));\n    }\n    return this._hValue;\n  }\n\n  hiHv(): Promise<{ hi: Hash; hv: Hash }> {\n    return (async () => {\n      const hi = await this.hIndex();\n      const hv = await this.hValue();\n      return { hi, hv };\n    })();\n  }\n\n  bytes(): Array<ElemBytes> {\n    return this._data.value;\n  }\n\n  equal(e2: Entry): boolean {\n    return this._data.equal(e2.data);\n  }\n\n  clone(): Entry {\n    return new Entry(this._data);\n  }\n}\n\nexport const elemBytesToBigInts = (es: Array<ElemBytes>): Array<bigint> => {\n  const bigInts = es.map((e) => {\n    return e.bigInt();\n  });\n\n  return bigInts;\n};\n\nexport const checkEntryInField = (e: Entry): boolean => {\n  const bigInts = elemBytesToBigInts(e.data.value);\n  let flag = true;\n\n  bigInts.forEach((b) => {\n    if (!checkBigIntInField(b)) {\n      flag = false;\n    }\n  });\n\n  return flag;\n};\n", "export const ErrNodeKeyAlreadyExists = 'key already exists';\n// ErrKeyNotFound is used when a key is not found in the MerkleTree.\nexport const ErrKeyNotFound = 'Key not found in the MerkleTree';\n// ErrNodeBytesBadSize is used when the data of a node has an incorrect\n// size and can't be parsed.\nexport const ErrNodeBytesBadSize = 'node data has incorrect size in the DB';\n// ErrReachedMaxLevel is used when a traversal of the MT reaches the\n// maximum level.\nexport const ErrReachedMaxLevel = 'reached maximum level of the merkle tree';\n// ErrInvalidNodeFound is used when an invalid node is found and can't\n// be parsed.\nexport const ErrInvalidNodeFound = 'found an invalid node in the DB';\n// ErrInvalidProofBytes is used when a serialized proof is invalid.\nexport const ErrInvalidProofBytes = 'the serialized proof is invalid';\n// ErrInvalidDBValue is used when a value in the key value DB is\n// invalid (for example, it doesn't contain a byte header and a []byte\n// body of at least len=1.\nexport const ErrInvalidDBValue = 'the value in the DB is invalid';\n// ErrEntryIndexAlreadyExists is used when the entry index already\n// exists in the tree.\nexport const ErrEntryIndexAlreadyExists = 'the entry index already exists in the tree';\n// ErrNotWritable is used when the MerkleTree is not writable and a\n// write function is called\nexport const ErrNotWritable = 'Merkle Tree not writable';\n", "export const ErrNotFound = 'key not found';\n", "import { ICircomProcessorProof, ICircomVerifierProof, Siblings } from '../../types/merkletree';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class CircomVerifierProof implements ICircomVerifierProof {\n  root: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  isOld0: boolean;\n  key: Hash;\n  value: Hash;\n  // 0: inclusion, 1: non inclusion\n  fnc: number;\n\n  constructor(\n    _root: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _key: Hash = ZERO_HASH,\n    _value: Hash = ZERO_HASH,\n    _fnc = 0\n  ) {\n    this.root = _root;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.isOld0 = _isOld0;\n    this.key = _key;\n    this.value = _value;\n    this.fnc = _fnc;\n  }\n}\n\nexport class CircomProcessorProof implements ICircomProcessorProof {\n  oldRoot: Hash;\n  newRoot: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  newKey: Hash;\n  newValue: Hash;\n  isOld0: boolean;\n  // 0: NOP, 1: Update, 2: Insert, 3: Delete\n  fnc: number;\n\n  constructor(\n    _oldRoot: Hash = ZERO_HASH,\n    _newRoot: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _newKey: Hash = ZERO_HASH,\n    _newValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _fnc = 0\n  ) {\n    this.oldRoot = _oldRoot;\n    this.newRoot = _newRoot;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.newKey = _newKey;\n    this.newValue = _newValue;\n    this.isOld0 = _isOld0;\n    this.fnc = _fnc;\n  }\n}\n", "export const ErrNodeAuxNonExistAgainstHIndex =\n  'non-existence proof being checked against hIndex equal to nodeAux';\n", "import { NodeAux, Siblings } from '../../types/merkletree';\nimport { ELEM_BYTES_LEN, NOT_EMPTIES_LEN, PROOF_FLAG_LEN } from '../../constants';\nimport { bytesEqual, getPath, setBitBigEndian, siblings2Bytes, testBitBigEndian } from '../utils';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NodeMiddle } from '../node/node';\nimport { leafKey } from '../utils/node';\nimport { ErrNodeAuxNonExistAgainstHIndex } from '../errors/proof';\nimport { Bytes } from '../../types';\n\nexport interface ProofJSON {\n  existence: boolean;\n  siblings: string[];\n  node_aux?: NodeAuxJSON; // this is a right representation of auxiliary node field according to the specification, nodeAux will be deprecated.\n  /**\n   * @deprecated old version is deprecated, do not use it.\n   */\n  nodeAux?: NodeAuxJSON; // old version of representation of auxiliary node.\n}\n\nexport interface NodeAuxJSON {\n  key: string;\n  value: string;\n}\n\nexport class Proof {\n  existence: boolean;\n  private depth: number;\n  // notEmpties is a bitmap of non-empty siblings found in siblings\n  private notEmpties: Bytes;\n  private siblings: Siblings;\n  nodeAux: NodeAux | undefined;\n\n  constructor(obj?: { siblings: Siblings; nodeAux: NodeAux | undefined; existence: boolean }) {\n    this.existence = obj?.existence ?? false;\n    this.depth = 0;\n    this.nodeAux = obj?.nodeAux;\n\n    const { siblings, notEmpties } = this.reduceSiblings(obj?.siblings);\n    this.siblings = siblings;\n    this.notEmpties = notEmpties;\n  }\n\n  bytes(): Bytes {\n    let bsLen = PROOF_FLAG_LEN + this.notEmpties.length + ELEM_BYTES_LEN * this.siblings.length;\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bsLen += 2 * ELEM_BYTES_LEN;\n    }\n\n    const arrBuff = new ArrayBuffer(bsLen);\n    const bs = new Uint8Array(arrBuff);\n\n    if (!this.existence) {\n      bs[0] |= 1;\n    }\n    bs[1] = this.depth;\n    bs.set(this.notEmpties, PROOF_FLAG_LEN);\n    const siblingBytes = siblings2Bytes(this.siblings);\n    bs.set(siblingBytes, this.notEmpties.length + PROOF_FLAG_LEN);\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bs[0] |= 2;\n      bs.set(this.nodeAux.key.value, bs.length - 2 * ELEM_BYTES_LEN);\n      bs.set(this.nodeAux.value.value, bs.length - 1 * ELEM_BYTES_LEN);\n    }\n    return bs;\n  }\n\n  toJSON() {\n    return {\n      existence: this.existence,\n      siblings: this.allSiblings().map((s) => s.toJSON()),\n      node_aux: this.nodeAux\n        ? {\n            key: this.nodeAux.key.toJSON(),\n            value: this.nodeAux.value.toJSON()\n          }\n        : undefined\n    };\n  }\n\n  private reduceSiblings(siblings?: Siblings): { notEmpties: Uint8Array; siblings: Siblings } {\n    const reducedSiblings: Siblings = [];\n    const notEmpties = new Uint8Array(NOT_EMPTIES_LEN);\n\n    if (!siblings) {\n      return { siblings: reducedSiblings, notEmpties };\n    }\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if (JSON.stringify(siblings[i]) !== JSON.stringify(ZERO_HASH)) {\n        setBitBigEndian(notEmpties, i);\n        reducedSiblings.push(sibling);\n        this.depth = i + 1;\n      }\n    }\n    return { notEmpties, siblings: reducedSiblings };\n  }\n\n  public static fromJSON(obj: ProofJSON): Proof {\n    let nodeAux: NodeAux | undefined = undefined;\n    const nodeAuxJson: NodeAuxJSON | undefined = obj.node_aux ?? obj.nodeAux; // we keep backward compatibility and support both representations\n    if (nodeAuxJson) {\n      nodeAux = {\n        key: Hash.fromString(nodeAuxJson.key),\n        value: Hash.fromString(nodeAuxJson.value)\n      };\n    }\n    const existence = obj.existence ?? false;\n\n    const siblings: Siblings = obj.siblings.map((s) => Hash.fromString(s));\n\n    return new Proof({ existence, nodeAux, siblings });\n  }\n\n  allSiblings(): Siblings {\n    return Proof.buildAllSiblings(this.depth, this.notEmpties, this.siblings);\n  }\n\n  public static buildAllSiblings(\n    depth: number,\n    notEmpties: Uint8Array,\n    siblings: Hash[]\n  ): Siblings {\n    let sibIdx = 0;\n    const allSiblings: Siblings = [];\n\n    for (let i = 0; i < depth; i += 1) {\n      if (testBitBigEndian(notEmpties, i)) {\n        allSiblings.push(siblings[sibIdx]);\n        sibIdx += 1;\n      } else {\n        allSiblings.push(ZERO_HASH);\n      }\n    }\n    return allSiblings;\n  }\n}\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use proof.allSiblings instead\n */\n// eslint-disable-next-line @cspell/spellchecker\nexport const siblignsFroomProof = (proof: Proof): Siblings => {\n  return proof.allSiblings();\n};\n\nexport const verifyProof = async (\n  rootKey: Hash,\n  proof: Proof,\n  k: bigint,\n  v: bigint\n): Promise<boolean> => {\n  try {\n    const rFromProof = await rootFromProof(proof, k, v);\n    return bytesEqual(rootKey.value, rFromProof.value);\n  } catch (err) {\n    if (err === ErrNodeAuxNonExistAgainstHIndex) {\n      return false;\n    }\n    throw err;\n  }\n};\n\nexport const rootFromProof = async (proof: Proof, k: bigint, v: bigint): Promise<Hash> => {\n  const kHash = Hash.fromBigInt(k);\n  const vHash = Hash.fromBigInt(v);\n  let midKey: Hash;\n\n  if (proof.existence) {\n    midKey = await leafKey(kHash, vHash);\n  } else {\n    if (typeof proof.nodeAux === 'undefined') {\n      midKey = ZERO_HASH;\n    } else {\n      const nodeAux = proof.nodeAux as unknown as NodeAux;\n      if (bytesEqual(kHash.value, nodeAux.key.value)) {\n        throw ErrNodeAuxNonExistAgainstHIndex;\n      }\n      midKey = await leafKey(nodeAux.key, nodeAux.value);\n    }\n  }\n\n  const siblings = proof.allSiblings();\n\n  const path = getPath(siblings.length, kHash.value);\n\n  for (let i = siblings.length - 1; i >= 0; i -= 1) {\n    if (path[i]) {\n      midKey = await new NodeMiddle(siblings[i], midKey).getKey();\n    } else {\n      midKey = await new NodeMiddle(midKey, siblings[i]).getKey();\n    }\n  }\n\n  return midKey;\n};\n", "import { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH, circomSiblingsFromSiblings } from '../hash/hash';\n\nimport { Node } from '../../types';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytesEqual, getPath } from '../utils';\nimport { NodeAux, Siblings } from '../../types/merkletree';\nimport { checkBigIntInField } from '../utils/crypto';\nimport { CircomProcessorProof, CircomVerifierProof } from './circom';\nimport {\n  ErrEntryIndexAlreadyExists,\n  ErrInvalidNodeFound,\n  ErrKeyNotFound,\n  ErrNotFound,\n  ErrNotWritable,\n  ErrReachedMaxLevel\n} from '../errors';\nimport { Proof } from './proof';\nimport { Entry, checkEntryInField } from '../entry';\n\nexport class Merkletree {\n  private _db: ITreeStorage;\n  private _root!: Hash;\n  private _writable: boolean;\n  private _maxLevel: number;\n\n  constructor(_db: ITreeStorage, _writable: boolean, _maxLevels: number) {\n    this._db = _db;\n    this._writable = _writable;\n    this._maxLevel = _maxLevels;\n  }\n\n  async root(): Promise<Hash> {\n    if (!this._root) {\n      this._root = await this._db.getRoot();\n    }\n    return this._root;\n  }\n\n  get maxLevels(): number {\n    return this._maxLevel;\n  }\n\n  async add(k: bigint, v: bigint): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    this._root = await this.root();\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const newNodeLeaf = new NodeLeaf(kHash, vHash);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this._root, 0, path);\n    this._root = newRootKey;\n    await this._db.setRoot(this._root);\n  }\n\n  async updateNode(n: Node): Promise<Hash> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n\n    await this._db.put(k.value, n);\n    return k;\n  }\n\n  async addNode(n: Node): Promise<Hash> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n    // if (typeof this.#db.get(k.value) !== 'undefined') {\n    //   throw ErrNodeKeyAlreadyExists;\n    // }\n\n    await this._db.put(k.value, n);\n    return k;\n  }\n\n  async addEntry(e: Entry): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkEntryInField(e)) {\n      throw 'elements not inside the finite field over r';\n    }\n    this._root = await this._db.getRoot();\n    const hIndex = await e.hIndex();\n    const hValue = await e.hValue();\n\n    const newNodeLeaf = new NodeLeaf(hIndex, hValue);\n    const path = getPath(this.maxLevels, hIndex.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this._root, 0, path);\n    this._root = newRootKey;\n    await this._db.setRoot(this._root);\n  }\n\n  async pushLeaf(\n    newLeaf: Node,\n    oldLeaf: Node,\n    lvl: number,\n    pathNewLeaf: Array<boolean>,\n    pathOldLeaf: Array<boolean>\n  ): Promise<Hash> {\n    if (lvl > this._maxLevel - 2) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    let newNodeMiddle: NodeMiddle;\n\n    if (pathNewLeaf[lvl] === pathOldLeaf[lvl]) {\n      const nextKey = await this.pushLeaf(newLeaf, oldLeaf, lvl + 1, pathNewLeaf, pathOldLeaf);\n      if (pathNewLeaf[lvl]) {\n        newNodeMiddle = new NodeMiddle(new Hash(), nextKey);\n      } else {\n        newNodeMiddle = new NodeMiddle(nextKey, new Hash());\n      }\n\n      return await this.addNode(newNodeMiddle);\n    }\n\n    const oldLeafKey = await oldLeaf.getKey();\n    const newLeafKey = await newLeaf.getKey();\n\n    if (pathNewLeaf[lvl]) {\n      newNodeMiddle = new NodeMiddle(oldLeafKey, newLeafKey);\n    } else {\n      newNodeMiddle = new NodeMiddle(newLeafKey, oldLeafKey);\n    }\n\n    await this.addNode(newLeaf);\n    return await this.addNode(newNodeMiddle);\n  }\n\n  async addLeaf(newLeaf: NodeLeaf, key: Hash, lvl: number, path: Array<boolean>): Promise<Hash> {\n    if (lvl > this._maxLevel - 1) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        return this.addNode(newLeaf);\n      case NODE_TYPE_LEAF: {\n        const nKey = (n as NodeLeaf).entry[0];\n        const newLeafKey = newLeaf.entry[0];\n\n        if (bytesEqual(nKey.value, newLeafKey.value)) {\n          throw ErrEntryIndexAlreadyExists;\n        }\n\n        const pathOldLeaf = getPath(this.maxLevels, nKey.value);\n        return this.pushLeaf(newLeaf, n, lvl, path, pathOldLeaf);\n      }\n      case NODE_TYPE_MIDDLE: {\n        n as NodeMiddle;\n        let newNodeMiddle: NodeMiddle;\n\n        if (path[lvl]) {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childR, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle((n as NodeMiddle).childL, nextKey);\n        } else {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childL, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle(nextKey, (n as NodeMiddle).childR);\n        }\n\n        return this.addNode(newNodeMiddle);\n      }\n      default: {\n        throw ErrInvalidNodeFound;\n      }\n    }\n  }\n\n  async get(k: bigint): Promise<{ key: bigint; value: bigint; siblings: Siblings }> {\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i++) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrKeyNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            key: BigInt('0'),\n            value: BigInt('0'),\n            siblings\n          };\n        case NODE_TYPE_LEAF:\n          // if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n          //   return {\n          //     key: (n as NodeLeaf).entry[0].BigInt(),\n          //     value: (n as NodeLeaf).entry[1].BigInt(),\n          //     siblings,\n          //   };\n          // }\n          return {\n            key: (n as NodeLeaf).entry[0].bigInt(),\n            value: (n as NodeLeaf).entry[1].bigInt(),\n            siblings\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw new Error(ErrReachedMaxLevel);\n  }\n\n  async update(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkBigIntInField(k)) {\n      throw 'key not inside the finite field';\n    }\n    if (!checkBigIntInField(v)) {\n      throw 'key not inside the finite field';\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const cp = new CircomProcessorProof();\n\n    cp.fnc = 1;\n    cp.oldRoot = await this.root();\n    cp.oldKey = kHash;\n    cp.newKey = kHash;\n    cp.newValue = vHash;\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            cp.oldValue = (n as NodeLeaf).entry[1];\n            cp.siblings = circomSiblingsFromSiblings([...siblings], this.maxLevels);\n            const newNodeLeaf = new NodeLeaf(kHash, vHash);\n            await this.updateNode(newNodeLeaf);\n\n            const newRootKey = await this.recalculatePathUntilRoot(path, newNodeLeaf, siblings);\n\n            this._root = newRootKey;\n            await this._db.setRoot(newRootKey);\n            cp.newRoot = newRootKey;\n            return cp;\n          }\n          break;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async getNode(k: Hash): Promise<Node | undefined> {\n    if (bytesEqual(k.value, ZERO_HASH.value)) {\n      return new NodeEmpty();\n    }\n    return await this._db.get(k.value);\n  }\n\n  async recalculatePathUntilRoot(\n    path: Array<boolean>,\n    node: Node,\n    siblings: Siblings\n  ): Promise<Hash> {\n    for (let i = siblings.length - 1; i >= 0; i -= 1) {\n      const nodeKey = await node.getKey();\n      if (path[i]) {\n        node = new NodeMiddle(siblings[i], nodeKey);\n      } else {\n        node = new NodeMiddle(nodeKey, siblings[i]);\n      }\n      await this.addNode(node);\n    }\n\n    const nodeKey = await node.getKey();\n    return nodeKey;\n  }\n\n  // Delete removes the specified Key from the MerkleTree and updates the path\n  // from the deleted key to the Root with the new values.  This method removes\n  // the key from the MerkleTree, but does not remove the old nodes from the\n  // key-value database; this means that if the tree is accessed by an old Root\n  // where the key was not deleted yet, the key will still exist. If is desired\n  // to remove the key-values from the database that are not under the current\n  // Root, an option could be to dump all the leaves (using mt.DumpLeafs) and\n  // import them in a new MerkleTree in a new database (using\n  // mt.ImportDumpedLeafs), but this will loose all the Root history of the\n  // MerkleTree\n  async delete(k: bigint): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = this._root;\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this._maxLevel; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.bytes, (n as NodeLeaf).entry[0].value)) {\n            await this.rmAndUpload(path, kHash, siblings);\n            return;\n          }\n          throw ErrKeyNotFound;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async rmAndUpload(path: Array<boolean>, kHash: Hash, siblings: Siblings): Promise<void> {\n    if (siblings.length === 0) {\n      this._root = ZERO_HASH;\n      await this._db.setRoot(this._root);\n      return;\n    }\n\n    const toUpload = siblings[siblings.length - 1];\n    if (siblings.length < 2) {\n      this._root = siblings[0];\n      await this._db.setRoot(this._root);\n    }\n\n    const nearestSibling = await this._db.get(toUpload.bytes);\n    if (nearestSibling?.type === NODE_TYPE_MIDDLE) {\n      let newNode: Node;\n      if (path[siblings.length - 1]) {\n        newNode = new NodeMiddle(toUpload, ZERO_HASH);\n      } else {\n        newNode = new NodeMiddle(ZERO_HASH, toUpload);\n      }\n      await this.addNode(newNode);\n      const newRootKey = await this.recalculatePathUntilRoot(\n        path,\n        newNode,\n        siblings.slice(0, siblings.length - 1)\n      );\n      this._root = newRootKey;\n      await this._db.setRoot(this._root);\n      return;\n    }\n\n    for (let i = siblings.length - 2; i >= 0; i -= 1) {\n      if (!bytesEqual(siblings[i].value, ZERO_HASH.value)) {\n        let newNode: Node;\n        if (path[i]) {\n          newNode = new NodeMiddle(siblings[i], toUpload);\n        } else {\n          newNode = new NodeMiddle(toUpload, siblings[i]);\n        }\n        await this.addNode(newNode);\n\n        const newRootKey = await this.recalculatePathUntilRoot(path, newNode, siblings.slice(0, i));\n\n        this._root = newRootKey;\n        await this._db.setRoot(this._root);\n        break;\n      }\n\n      if (i === 0) {\n        this._root = toUpload;\n        await this._db.setRoot(this._root);\n        break;\n      }\n    }\n  }\n\n  async recWalk(key: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        await f(n);\n        break;\n      case NODE_TYPE_LEAF:\n        await f(n);\n        break;\n      case NODE_TYPE_MIDDLE:\n        await f(n);\n        await this.recWalk((n as NodeMiddle).childL, f);\n        await this.recWalk((n as NodeMiddle).childR, f);\n        break;\n      default:\n        throw ErrInvalidNodeFound;\n    }\n  }\n\n  async walk(rootKey: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    await this.recWalk(rootKey, f);\n  }\n\n  async generateCircomVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    const cp = await this.generateSCVerifierProof(k, rootKey);\n    cp.siblings = circomSiblingsFromSiblings(cp.siblings, this.maxLevels);\n    return cp;\n  }\n\n  async generateSCVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n\n    const { proof, value } = await this.generateProof(k, rootKey);\n    const cp = new CircomVerifierProof();\n    cp.root = rootKey;\n    cp.siblings = proof.allSiblings();\n    if (typeof proof.nodeAux !== 'undefined') {\n      cp.oldKey = proof.nodeAux.key;\n      cp.oldValue = proof.nodeAux.value;\n    } else {\n      cp.oldKey = ZERO_HASH;\n      cp.oldValue = ZERO_HASH;\n    }\n    cp.key = Hash.fromBigInt(k);\n    cp.value = Hash.fromBigInt(value);\n\n    if (proof.existence) {\n      cp.fnc = 0;\n    } else {\n      cp.fnc = 1;\n    }\n\n    return cp;\n  }\n\n  async generateProof(k: bigint, rootKey?: Hash): Promise<{ proof: Proof; value: bigint }> {\n    let siblingKey: Hash;\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n    if (!rootKey) {\n      rootKey = await this.root();\n    }\n    let nextKey = rootKey;\n\n    let depth = 0;\n    let existence = false;\n    const siblings: Siblings = [];\n    let nodeAux: NodeAux | undefined;\n\n    for (depth = 0; depth < this.maxLevels; depth += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: BigInt('0')\n          };\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            existence = true;\n\n            return {\n              proof: new Proof({\n                existence,\n                nodeAux,\n                siblings\n              }),\n              value: (n as NodeLeaf).entry[1].bigInt()\n            };\n          }\n          nodeAux = {\n            key: (n as NodeLeaf).entry[0],\n            value: (n as NodeLeaf).entry[1]\n          };\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: (n as NodeLeaf).entry[1].bigInt()\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[depth]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblingKey = (n as NodeMiddle).childL;\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblingKey = (n as NodeMiddle).childR;\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n      siblings.push(siblingKey);\n    }\n    throw ErrKeyNotFound;\n  }\n\n  async addAndGetCircomProof(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    const cp = new CircomProcessorProof();\n    cp.fnc = 2;\n    cp.oldRoot = await this.root();\n    let key = BigInt('0');\n    let value = BigInt('0');\n    let siblings: Siblings = [];\n    try {\n      const res = await this.get(k);\n      key = res.key;\n      value = res.value;\n      siblings = res.siblings;\n    } catch (err) {\n      if (err !== ErrKeyNotFound) {\n        throw err;\n      }\n    }\n\n    if (typeof key === 'undefined' || typeof value === 'undefined') {\n      throw 'key/value undefined';\n    }\n\n    cp.oldKey = Hash.fromBigInt(key);\n    cp.oldValue = Hash.fromBigInt(value);\n\n    if (bytesEqual(cp.oldKey.value, ZERO_HASH.value)) {\n      cp.isOld0 = true;\n    }\n\n    cp.siblings = circomSiblingsFromSiblings(siblings, this.maxLevels);\n    await this.add(k, v);\n\n    cp.newKey = Hash.fromBigInt(k);\n    cp.newValue = Hash.fromBigInt(v);\n    cp.newRoot = await this.root();\n\n    return cp;\n  }\n\n  // NOTE: for now it only prints to console, will be updated in future\n  async graphViz(rootKey: Hash): Promise<void> {\n    let cnt = 0;\n\n    await this.walk(rootKey, async (n: Node) => {\n      const k = await n.getKey();\n      let lr: [string, string];\n      let emptyNodes: string;\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          break;\n        case NODE_TYPE_LEAF:\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" [style=filled]`);\n          break;\n        case NODE_TYPE_MIDDLE:\n          lr = [(n as NodeMiddle).childL.string(), (n as NodeMiddle).childR.string()];\n          emptyNodes = '';\n\n          lr.forEach((s, i) => {\n            if (s === '0') {\n              lr[i] = `empty${cnt}`;\n              emptyNodes += `\"${lr[i]}\" [style=dashed,label=0];\\n`;\n              cnt += 1;\n            }\n          });\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" -> {\"${lr[1]}\"}`);\n          // eslint-disable-next-line no-console\n          console.log(emptyNodes);\n          break;\n        default:\n          break;\n      }\n    });\n\n    // eslint-disable-next-line no-console\n    console.log(`}\\n`);\n  }\n\n  async printGraphViz(rootKey: Hash): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    // eslint-disable-next-line no-console\n    console.log(\n      `--------\\nGraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n`\n    );\n    await this.graphViz(ZERO_HASH);\n    // eslint-disable-next-line no-console\n    console.log(\n      `End of GraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n--------\\n`\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["k", "k", "nodeKey"]
}
