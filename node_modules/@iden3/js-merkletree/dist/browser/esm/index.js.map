{"version":3,"file":"index.js","sources":["../../../src/constants/hash.ts","../../../src/constants/node.ts","../../../src/constants/data.ts","../../../src/constants/proof.ts","../../../src/constants/field.ts","../../../src/lib/utils/crypto.ts","../../../src/lib/utils/bytes.ts","../../../src/lib/utils/merkletree.ts","../../../src/lib/utils/bigint.ts","../../../src/lib/hash/hash.ts","../../../src/lib/db/inMemory.ts","../../../src/lib/utils/node.ts","../../../src/lib/node/node.ts","../../../src/lib/db/localStorage.ts","../../../node_modules/idb-keyval/dist/index.js","../../../src/lib/db/indexedDB.ts","../../../src/lib/entry/elemBytes.ts","../../../src/lib/entry/data.ts","../../../src/lib/entry/entry.ts","../../../src/lib/errors/merkletree.ts","../../../src/lib/errors/db.ts","../../../src/lib/merkletree/circom.ts","../../../src/lib/errors/proof.ts","../../../src/lib/merkletree/proof.ts","../../../src/lib/merkletree/merkletree.ts"],"sourcesContent":["export const HASH_BYTES_LENGTH = 32;\n","// middle node.ts with children\nimport { NodeType } from '../types';\n\nexport const NODE_TYPE_MIDDLE: NodeType = 0;\n// Leaf node.ts with a key and a value\nexport const NODE_TYPE_LEAF: NodeType = 1;\n// empty node.ts\nexport const NODE_TYPE_EMPTY: NodeType = 2;\n\nexport const NODE_VALUE_BYTE_ARR_LENGTH = 65;\n\nexport const EMPTY_NODE_VALUE = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n\nexport const EMPTY_NODE_STRING = 'empty';\n","export const ELEM_BYTES_LEN = 32;\nexport const DATA_LEN = 8;\nexport const DATA_LEN_BYTES = DATA_LEN * ELEM_BYTES_LEN;\n","import { ELEM_BYTES_LEN } from './data';\nexport const PROOF_FLAG_LEN = 2;\nexport const NOT_EMPTIES_LEN = ELEM_BYTES_LEN - PROOF_FLAG_LEN;\n","const qString = '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport const FIELD_SIZE = BigInt(qString);\nexport const MAX_NUM_IN_FIELD = FIELD_SIZE - BigInt('1');\n","import { FIELD_SIZE } from '../../constants/field';\n\nexport const checkBigIntInField = (bigNum: bigint): boolean => {\n  return bigNum < FIELD_SIZE;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types/bytes';\nimport { checkBigIntInField } from './crypto';\n\nexport const bytesEqual: (b1: Bytes, b2: Bytes) => boolean = (b1, b2) => {\n  return b1.every((ele, idx) => ele === b2[idx]);\n};\n\n// TODO: might be make this generic over typed arrays?\nexport const swapEndianness = (bytes: Bytes): Bytes => {\n  return bytes.slice().reverse();\n};\n\nexport const bytes2BinaryString = (bytes: Bytes): string => {\n  return '0b' + bytes.reduce((acc, i) => acc + i.toString(2).padStart(8, '0'), '');\n};\n\nexport const testBit = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[parseInt((n / 8).toString())] & (1 << n % 8)) !== 0;\n};\n\nexport const testBitBigEndian = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] & (1 << n % 8)) !== 0;\n};\n\n// SetBitBigEndian sets the bit n in the bitmap to 1, in Big Endian.\nexport const setBitBigEndian = (bitMap: Bytes, n: number): void => {\n  bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] |= 1 << n % 8;\n};\n\nconst hexTable = '0123456789abcdef';\nexport const bytes2Hex = (u: Bytes): string => {\n  const arr = new Array(u.length * 2);\n  let j = 0;\n  u.forEach((v) => {\n    arr[j] = hexTable[parseInt((v >> 4).toString(10))];\n    arr[j + 1] = hexTable[parseInt((v & 15).toString(10))];\n    j += 2;\n  });\n\n  return arr.join('');\n};\n\n// NOTE: `bytes` should be big endian\n// bytes received from Hash.value getter are safe to use since their endianness is swapped, for the same reason the private Hash.bytes { stored in little endian } should never be used\nexport const newBigIntFromBytes = (bytes: Bytes): bigint => {\n  if (bytes.length !== HASH_BYTES_LENGTH) {\n    throw `Expected 32 bytes, found ${bytes.length} bytes`;\n  }\n\n  const bigNum = BigInt(bytes2BinaryString(bytes));\n  if (!checkBigIntInField(bigNum)) {\n    throw 'NewBigIntFromHashBytes: Value not inside the Finite Field';\n  }\n\n  return bigNum;\n};\n\nexport const str2Bytes = (str: string): Bytes =>\n  new Uint8Array(str.length * 2).map((_, i) => str.charCodeAt(i));\n","// const siblingBytes = bs.slice(this.notEmpties.length + PROOF_FLAG_LEN);\nimport { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\nimport { Path, Siblings } from '../../types/merkletree';\nimport { testBit } from './bytes';\n\nexport const getPath = (numLevels: number, k: Bytes): Path => {\n  const path = new Array<boolean>(numLevels);\n\n  for (let idx = 0; idx < numLevels; idx += 1) {\n    path[idx] = testBit(k, idx);\n  }\n  return path;\n};\n\nexport const siblings2Bytes = (siblings: Siblings): Bytes => {\n  const siblingBytesBuff = new ArrayBuffer(HASH_BYTES_LENGTH * siblings.length);\n  const siblingBytes = new Uint8Array(siblingBytesBuff);\n  siblings.forEach((v, i) => {\n    siblingBytes.set(v.value, i * HASH_BYTES_LENGTH);\n  });\n\n  return siblingBytes;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\n\nexport const bigint2Array = (bigNum: bigint, radix?: number): Array<number> => {\n  return bigNum\n    .toString(radix ? radix : 10)\n    .split('')\n    .map((n) => {\n      return parseInt(n);\n    });\n};\n\nexport const bigIntToUINT8Array = (bigNum: bigint): Bytes => {\n  const n256 = BigInt(256);\n  const bytes = new Uint8Array(HASH_BYTES_LENGTH);\n  let i = 0;\n  while (bigNum > BigInt(0)) {\n    bytes[HASH_BYTES_LENGTH - 1 - i] = Number(bigNum % n256);\n    bigNum = bigNum / n256;\n    i += 1;\n  }\n  return bytes;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport {\n  bytesEqual,\n  swapEndianness,\n  bytes2Hex,\n  bytes2BinaryString,\n  checkBigIntInField,\n  bigIntToUINT8Array\n} from '../utils';\nimport { Bytes, IHash, Siblings } from '../../types';\nimport { Hex, poseidon } from '@iden3/js-crypto';\n\nexport class Hash implements IHash {\n  // little endian\n  bytes: Bytes;\n\n  constructor(_bytes?: Bytes) {\n    if (_bytes?.length) {\n      if (_bytes.length !== HASH_BYTES_LENGTH) {\n        throw new Error(`Expected ${HASH_BYTES_LENGTH} bytes, found ${_bytes.length} bytes`);\n      }\n      this.bytes = _bytes;\n    } else {\n      this.bytes = new Uint8Array(HASH_BYTES_LENGTH);\n    }\n  }\n\n  // returns a new copy, in little endian\n  get value(): Bytes {\n    return this.bytes;\n  }\n\n  // bytes should be in big-endian\n  set value(bytes: Bytes) {\n    if (bytes.length !== HASH_BYTES_LENGTH) {\n      throw `Expected 32 bytes, found ${bytes.length} bytes`;\n    }\n    this.bytes = swapEndianness(bytes);\n  }\n\n  string(): string {\n    return this.bigInt().toString(10);\n  }\n\n  hex(): string {\n    return bytes2Hex(this.bytes);\n  }\n\n  equals(hash: Hash): boolean {\n    return bytesEqual(this.value, hash.value);\n  }\n\n  bigInt(): bigint {\n    const bytes = swapEndianness(this.value);\n    return BigInt(bytes2BinaryString(bytes));\n  }\n\n  static fromString(s: string): Hash {\n    try {\n      return Hash.fromBigInt(BigInt(s));\n    } catch (e) {\n      const deserializedHash = JSON.parse(s);\n      const bytes = Uint8Array.from(Object.values(deserializedHash.bytes));\n      return new Hash(bytes);\n    }\n  }\n  static fromBigInt(i: bigint): Hash {\n    if (!checkBigIntInField(i)) {\n      throw new Error('NewBigIntFromHashBytes: Value not inside the Finite Field');\n    }\n\n    const bytes = bigIntToUINT8Array(i);\n\n    return new Hash(swapEndianness(bytes));\n  }\n\n  static fromHex(h: string | undefined): Hash {\n    if (!h) {\n      return ZERO_HASH;\n    }\n    return new Hash(Hex.decodeString(h));\n  }\n\n  toJSON() {\n    return this.string();\n  }\n}\n\nexport const ZERO_HASH = new Hash();\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromBigInt = (bigNum: bigint): Hash => {\n  return Hash.fromBigInt(bigNum);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromHex = (h: string): Hash => {\n  return Hash.fromHex(h);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigString instead\n */\nexport const newHashFromString = (decimalString: string): Hash => {\n  return Hash.fromString(decimalString);\n};\n\nexport const hashElems = (e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash(e);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const hashElemsKey = (k: bigint, e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash([...e, k]);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const circomSiblingsFromSiblings = (siblings: Siblings, levels: number): Siblings => {\n  for (let i = siblings.length; i < levels; i += 1) {\n    siblings.push(ZERO_HASH);\n  }\n  return siblings;\n};\n","// in Memory Database implementation\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class InMemoryDB implements ITreeStorage {\n  prefix: Bytes;\n  private _kvMap: {\n    [k in string]: Node;\n  };\n  private _currentRoot: Hash;\n\n  constructor(_prefix: Bytes) {\n    this.prefix = _prefix;\n    this._kvMap = {};\n    this._currentRoot = ZERO_HASH;\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    const val = this._kvMap[kBytes.toString()] ? this._kvMap[kBytes.toString()] : undefined;\n    return val;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    this._kvMap[kBytes.toString()] = n;\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this._currentRoot = r;\n  }\n}\n","// LeafKey computes the key of a leaf node given the hIndex and hValue of the\n// entry of the leaf.\nimport { Hash, hashElemsKey } from '../hash/hash';\n\nimport { NODE_VALUE_BYTE_ARR_LENGTH } from '../../constants';\nimport { bigIntToUINT8Array } from './bigint';\nimport { Bytes, NodeType } from '../../types';\n\nexport const leafKey = async (k: Hash, v: Hash): Promise<Hash> => {\n  return hashElemsKey(BigInt(1), [k.bigInt(), v.bigInt()]);\n};\n\nexport const nodeValue = (type: NodeType, a: Hash, b: Hash): Bytes => {\n  const bytes = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n  const kBytes = bigIntToUINT8Array(a.bigInt());\n  const vBytes = bigIntToUINT8Array(b.bigInt());\n  bytes[0] = type;\n\n  for (let idx = 1; idx < 33; idx += 1) {\n    bytes[idx] = kBytes[idx - 1];\n  }\n\n  for (let idx = 33; idx <= NODE_VALUE_BYTE_ARR_LENGTH; idx += 1) {\n    bytes[idx] = vBytes[idx - 33];\n  }\n\n  return bytes;\n};\n","import { Bytes, Node, NodeType } from '../../types';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\n\nimport {\n  EMPTY_NODE_STRING,\n  EMPTY_NODE_VALUE,\n  NODE_TYPE_EMPTY,\n  NODE_TYPE_LEAF,\n  NODE_TYPE_MIDDLE\n} from '../../constants';\nimport { leafKey, nodeValue } from '../utils/node';\n\nexport class NodeLeaf implements Node {\n  type: NodeType;\n  entry: [Hash, Hash];\n  // cache used to avoid recalculating key\n  private _key: Hash;\n\n  constructor(k: Hash, v: Hash) {\n    this.type = NODE_TYPE_LEAF;\n    this.entry = [k, v];\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this._key === ZERO_HASH) {\n      return await leafKey(this.entry[0], this.entry[1]);\n    }\n    return this._key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.entry[0], this.entry[1]);\n  }\n\n  get string(): string {\n    return `Leaf I:${this.entry[0]} D:${this.entry[1]}`;\n  }\n}\n\nexport class NodeMiddle implements Node {\n  type: NodeType;\n  childL: Hash;\n  childR: Hash;\n  private _key: Hash;\n\n  constructor(cL: Hash, cR: Hash) {\n    this.type = NODE_TYPE_MIDDLE;\n    this.childL = cL;\n    this.childR = cR;\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this._key === ZERO_HASH) {\n      return hashElems([this.childL.bigInt(), this.childR.bigInt()]);\n    }\n    return this._key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.childL, this.childR);\n  }\n\n  get string(): string {\n    return `Middle L:${this.childL} R:${this.childR}`;\n  }\n}\n\nexport class NodeEmpty implements Node {\n  type: NodeType;\n  private _key: Hash;\n\n  constructor() {\n    this.type = NODE_TYPE_EMPTY;\n    this._key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    return ZERO_HASH;\n  }\n\n  get value(): Bytes {\n    return EMPTY_NODE_VALUE;\n  }\n\n  get string(): string {\n    return EMPTY_NODE_STRING;\n  }\n}\n","/* eslint-disable no-case-declarations */\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytes2Hex } from '../utils';\n\nexport class LocalStorageDB implements ITreeStorage {\n  private _currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes) {\n    const rootStr = localStorage.getItem(bytes2Hex(_prefix));\n    if (rootStr) {\n      const bytes: number[] = JSON.parse(rootStr);\n\n      this._currentRoot = new Hash(Uint8Array.from(bytes));\n    } else {\n      this._currentRoot = ZERO_HASH;\n    }\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const val = localStorage.getItem(key);\n\n    if (val === null) {\n      return undefined;\n    }\n\n    const obj = JSON.parse(val);\n    switch (obj.type) {\n      case NODE_TYPE_EMPTY:\n        return new NodeEmpty();\n      case NODE_TYPE_MIDDLE:\n        const cL = new Hash(Uint8Array.from(obj.childL));\n        const cR = new Hash(Uint8Array.from(obj.childR));\n\n        return new NodeMiddle(cL, cR);\n      case NODE_TYPE_LEAF:\n        const k = new Hash(Uint8Array.from(obj.entry[0]));\n        const v = new Hash(Uint8Array.from(obj.entry[1]));\n\n        return new NodeLeaf(k, v);\n    }\n\n    throw `error: value found for key ${bytes2Hex(kBytes)} is not of type Node`;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const toSerialize: Record<string, unknown> = {\n      type: n.type\n    };\n    if (n instanceof NodeMiddle) {\n      toSerialize.childL = Array.from(n.childL.bytes);\n      toSerialize.childR = Array.from(n.childR.bytes);\n    } else if (n instanceof NodeLeaf) {\n      toSerialize.entry = [Array.from(n.entry[0].bytes), Array.from(n.entry[1].bytes)];\n    }\n    const val = JSON.stringify(toSerialize);\n    localStorage.setItem(key, val);\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this._currentRoot = r;\n    localStorage.setItem(bytes2Hex(this._prefix), JSON.stringify(Array.from(r.bytes)));\n  }\n}\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    let dbp;\n    const getDB = () => {\n        if (dbp)\n            return dbp;\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        dbp = promisifyRequest(request);\n        dbp.then((db) => {\n            // It seems like Safari sometimes likes to just close the connection.\n            // It's supposed to fire this event when that happens. Let's hope it does!\n            db.onclose = () => (dbp = undefined);\n        }, () => { });\n        return dbp;\n    };\n    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","import { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { bytes2Hex } from '../utils';\nimport { get, set, UseStore, createStore } from 'idb-keyval';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\n\nexport class IndexedDBStorage implements ITreeStorage {\n  public static readonly storageName = 'merkle-tree';\n\n  private readonly _prefixHash: string;\n  private readonly _store: UseStore;\n\n  private _currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes, databaseName?: string) {\n    this._currentRoot = ZERO_HASH;\n    this._prefixHash = bytes2Hex(_prefix);\n    this._store = createStore(\n      `${databaseName ?? IndexedDBStorage.storageName}-db`,\n      IndexedDBStorage.storageName\n    );\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const obj = await get(key, this._store);\n    if (obj === null || obj === undefined) {\n      return undefined;\n    }\n    if (obj.type === NODE_TYPE_EMPTY) {\n      return new NodeEmpty();\n    }\n    if (obj.type === NODE_TYPE_MIDDLE) {\n      const cL = new Hash(Uint8Array.from(obj.childL.bytes));\n      const cR = new Hash(Uint8Array.from(obj.childR.bytes));\n      return new NodeMiddle(cL, cR);\n    }\n    if (obj.type === NODE_TYPE_LEAF) {\n      const k = new Hash(Uint8Array.from(obj.entry[0].bytes));\n      const v = new Hash(Uint8Array.from(obj.entry[1].bytes));\n\n      return new NodeLeaf(k, v);\n    }\n    throw new Error(`error: value found for key ${key} is not of type Node`);\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    await set(key, n, this._store);\n  }\n\n  async getRoot(): Promise<Hash> {\n    if (!this._currentRoot.equals(ZERO_HASH)) {\n      return this._currentRoot;\n    }\n    const root = await get(this._prefixHash, this._store);\n\n    if (!root) {\n      this._currentRoot = ZERO_HASH;\n    } else {\n      this._currentRoot = new Hash(root.bytes);\n    }\n    return this._currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    await set(this._prefixHash, r, this._store);\n    this._currentRoot = r;\n  }\n}\n","import { ELEM_BYTES_LEN } from '../../constants';\nimport { Bytes } from '../../types';\nimport { bytes2Hex, newBigIntFromBytes, swapEndianness } from '../utils';\n\nexport class ElemBytes {\n  // Little Endian\n  private _bytes: Bytes;\n\n  constructor() {\n    this._bytes = new Uint8Array(ELEM_BYTES_LEN);\n  }\n\n  get value(): Bytes {\n    return this._bytes;\n  }\n\n  set value(b: Bytes) {\n    this._bytes = b;\n  }\n\n  bigInt(): bigint {\n    return newBigIntFromBytes(swapEndianness(this._bytes));\n  }\n\n  string(): string {\n    const hexStr = bytes2Hex(this._bytes.slice(0, 4));\n    return `${hexStr}...`;\n  }\n}\n","import { ElemBytes } from './elemBytes';\nimport { DATA_LEN, DATA_LEN_BYTES, ELEM_BYTES_LEN } from '../../constants';\nimport { bytesEqual } from '../utils';\nimport { Bytes } from '../../types';\n\nexport class Data {\n  private _value: Array<ElemBytes>;\n\n  constructor() {\n    this._value = new Array<ElemBytes>(DATA_LEN);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this._value;\n  }\n\n  set value(_v: ElemBytes[]) {\n    if (_v.length !== DATA_LEN) {\n      throw `expected bytes length to be ${DATA_LEN}, got ${_v.length}`;\n    }\n    this._value = _v;\n  }\n\n  bytes(): Bytes {\n    const b = new Uint8Array(DATA_LEN * ELEM_BYTES_LEN);\n\n    for (let idx = 0; idx < DATA_LEN; idx += 1) {\n      this._value[idx].value.forEach((v, _idx) => {\n        b[idx * ELEM_BYTES_LEN + _idx] = v;\n      });\n    }\n    return b;\n  }\n\n  equal(d2: Data): boolean {\n    return (\n      bytesEqual(this._value[0].value, d2.value[0].value) &&\n      bytesEqual(this._value[1].value, d2.value[1].value) &&\n      bytesEqual(this._value[2].value, d2.value[2].value) &&\n      bytesEqual(this._value[3].value, d2.value[3].value)\n    );\n  }\n}\n\nexport const newDataFromBytes = (bytes: Bytes): Data => {\n  if (bytes.length !== DATA_LEN_BYTES) {\n    throw `expected bytes length to be ${DATA_LEN_BYTES}, got ${bytes.length}`;\n  }\n  const d = new Data();\n  const arr = new Array<ElemBytes>(DATA_LEN_BYTES);\n\n  for (let i = 0; i < DATA_LEN; i += 1) {\n    const tmp = new ElemBytes();\n    tmp.value = bytes.slice(i * ELEM_BYTES_LEN, (i + 1) * DATA_LEN_BYTES);\n    arr[i] = tmp;\n  }\n\n  d.value = arr;\n  return d;\n};\n","import { Data } from '../entry/data';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\nimport { checkBigIntInField } from '../utils';\n\nimport { ElemBytes } from './elemBytes';\n\nexport class Entry {\n  private _data: Data;\n  private _hIndex: Hash;\n  private _hValue: Hash;\n\n  constructor(_data?: Data) {\n    this._data = _data ? _data : new Data();\n    this._hIndex = ZERO_HASH;\n    this._hValue = ZERO_HASH;\n  }\n\n  get data(): Data {\n    return this._data;\n  }\n\n  get index(): Array<ElemBytes> {\n    return this._data.value.slice(0, 4);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this._data.value.slice(4, 8);\n  }\n\n  async hIndex(): Promise<Hash> {\n    if (this._hIndex === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.index));\n    }\n    return this._hIndex;\n  }\n\n  async hValue(): Promise<Hash> {\n    if (this._hValue === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.value));\n    }\n    return this._hValue;\n  }\n\n  hiHv(): Promise<{ hi: Hash; hv: Hash }> {\n    return (async () => {\n      const hi = await this.hIndex();\n      const hv = await this.hValue();\n      return { hi, hv };\n    })();\n  }\n\n  bytes(): Array<ElemBytes> {\n    return this._data.value;\n  }\n\n  equal(e2: Entry): boolean {\n    return this._data.equal(e2.data);\n  }\n\n  clone(): Entry {\n    return new Entry(this._data);\n  }\n}\n\nexport const elemBytesToBigInts = (es: Array<ElemBytes>): Array<bigint> => {\n  const bigInts = es.map((e) => {\n    return e.bigInt();\n  });\n\n  return bigInts;\n};\n\nexport const checkEntryInField = (e: Entry): boolean => {\n  const bigInts = elemBytesToBigInts(e.data.value);\n  let flag = true;\n\n  bigInts.forEach((b) => {\n    if (!checkBigIntInField(b)) {\n      flag = false;\n    }\n  });\n\n  return flag;\n};\n","export const ErrNodeKeyAlreadyExists = 'key already exists';\n// ErrKeyNotFound is used when a key is not found in the MerkleTree.\nexport const ErrKeyNotFound = 'Key not found in the MerkleTree';\n// ErrNodeBytesBadSize is used when the data of a node has an incorrect\n// size and can't be parsed.\nexport const ErrNodeBytesBadSize = 'node data has incorrect size in the DB';\n// ErrReachedMaxLevel is used when a traversal of the MT reaches the\n// maximum level.\nexport const ErrReachedMaxLevel = 'reached maximum level of the merkle tree';\n// ErrInvalidNodeFound is used when an invalid node is found and can't\n// be parsed.\nexport const ErrInvalidNodeFound = 'found an invalid node in the DB';\n// ErrInvalidProofBytes is used when a serialized proof is invalid.\nexport const ErrInvalidProofBytes = 'the serialized proof is invalid';\n// ErrInvalidDBValue is used when a value in the key value DB is\n// invalid (for example, it doesn't contain a byte header and a []byte\n// body of at least len=1.\nexport const ErrInvalidDBValue = 'the value in the DB is invalid';\n// ErrEntryIndexAlreadyExists is used when the entry index already\n// exists in the tree.\nexport const ErrEntryIndexAlreadyExists = 'the entry index already exists in the tree';\n// ErrNotWritable is used when the MerkleTree is not writable and a\n// write function is called\nexport const ErrNotWritable = 'Merkle Tree not writable';\n","export const ErrNotFound = 'key not found';\n","import { ICircomProcessorProof, ICircomVerifierProof, Siblings } from '../../types/merkletree';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class CircomVerifierProof implements ICircomVerifierProof {\n  root: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  isOld0: boolean;\n  key: Hash;\n  value: Hash;\n  // 0: inclusion, 1: non inclusion\n  fnc: number;\n\n  constructor(\n    _root: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _key: Hash = ZERO_HASH,\n    _value: Hash = ZERO_HASH,\n    _fnc = 0\n  ) {\n    this.root = _root;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.isOld0 = _isOld0;\n    this.key = _key;\n    this.value = _value;\n    this.fnc = _fnc;\n  }\n}\n\nexport class CircomProcessorProof implements ICircomProcessorProof {\n  oldRoot: Hash;\n  newRoot: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  newKey: Hash;\n  newValue: Hash;\n  isOld0: boolean;\n  // 0: NOP, 1: Update, 2: Insert, 3: Delete\n  fnc: number;\n\n  constructor(\n    _oldRoot: Hash = ZERO_HASH,\n    _newRoot: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _newKey: Hash = ZERO_HASH,\n    _newValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _fnc = 0\n  ) {\n    this.oldRoot = _oldRoot;\n    this.newRoot = _newRoot;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.newKey = _newKey;\n    this.newValue = _newValue;\n    this.isOld0 = _isOld0;\n    this.fnc = _fnc;\n  }\n}\n","export const ErrNodeAuxNonExistAgainstHIndex =\n  'non-existence proof being checked against hIndex equal to nodeAux';\n","import { NodeAux, Siblings } from '../../types/merkletree';\nimport { ELEM_BYTES_LEN, NOT_EMPTIES_LEN, PROOF_FLAG_LEN } from '../../constants';\nimport { bytesEqual, getPath, setBitBigEndian, siblings2Bytes, testBitBigEndian } from '../utils';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NodeMiddle } from '../node/node';\nimport { leafKey } from '../utils/node';\nimport { ErrNodeAuxNonExistAgainstHIndex } from '../errors/proof';\nimport { Bytes } from '../../types';\n\nexport interface ProofJSON {\n  existence: boolean;\n  siblings: string[];\n  node_aux?: NodeAuxJSON; // this is a right representation of auxiliary node field according to the specification, nodeAux will be deprecated.\n  /**\n   * @deprecated old version is deprecated, do not use it.\n   */\n  nodeAux?: NodeAuxJSON; // old version of representation of auxiliary node.\n}\n\nexport interface NodeAuxJSON {\n  key: string;\n  value: string;\n}\n\nexport class Proof {\n  existence: boolean;\n  private depth: number;\n  // notEmpties is a bitmap of non-empty siblings found in siblings\n  private notEmpties: Bytes;\n  private siblings: Siblings;\n  nodeAux: NodeAux | undefined;\n\n  constructor(obj?: { siblings: Siblings; nodeAux: NodeAux | undefined; existence: boolean }) {\n    this.existence = obj?.existence ?? false;\n    this.depth = 0;\n    this.nodeAux = obj?.nodeAux;\n\n    const { siblings, notEmpties } = this.reduceSiblings(obj?.siblings);\n    this.siblings = siblings;\n    this.notEmpties = notEmpties;\n  }\n\n  bytes(): Bytes {\n    let bsLen = PROOF_FLAG_LEN + this.notEmpties.length + ELEM_BYTES_LEN * this.siblings.length;\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bsLen += 2 * ELEM_BYTES_LEN;\n    }\n\n    const arrBuff = new ArrayBuffer(bsLen);\n    const bs = new Uint8Array(arrBuff);\n\n    if (!this.existence) {\n      bs[0] |= 1;\n    }\n    bs[1] = this.depth;\n    bs.set(this.notEmpties, PROOF_FLAG_LEN);\n    const siblingBytes = siblings2Bytes(this.siblings);\n    bs.set(siblingBytes, this.notEmpties.length + PROOF_FLAG_LEN);\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bs[0] |= 2;\n      bs.set(this.nodeAux.key.value, bs.length - 2 * ELEM_BYTES_LEN);\n      bs.set(this.nodeAux.value.value, bs.length - 1 * ELEM_BYTES_LEN);\n    }\n    return bs;\n  }\n\n  toJSON() {\n    return {\n      existence: this.existence,\n      siblings: this.allSiblings().map((s) => s.toJSON()),\n      node_aux: this.nodeAux\n        ? {\n            key: this.nodeAux.key.toJSON(),\n            value: this.nodeAux.value.toJSON()\n          }\n        : undefined\n    };\n  }\n\n  private reduceSiblings(siblings?: Siblings): { notEmpties: Uint8Array; siblings: Siblings } {\n    const reducedSiblings: Siblings = [];\n    const notEmpties = new Uint8Array(NOT_EMPTIES_LEN);\n\n    if (!siblings) {\n      return { siblings: reducedSiblings, notEmpties };\n    }\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if (JSON.stringify(siblings[i]) !== JSON.stringify(ZERO_HASH)) {\n        setBitBigEndian(notEmpties, i);\n        reducedSiblings.push(sibling);\n        this.depth = i + 1;\n      }\n    }\n    return { notEmpties, siblings: reducedSiblings };\n  }\n\n  public static fromJSON(obj: ProofJSON): Proof {\n    let nodeAux: NodeAux | undefined = undefined;\n    const nodeAuxJson: NodeAuxJSON | undefined = obj.node_aux ?? obj.nodeAux; // we keep backward compatibility and support both representations\n    if (nodeAuxJson) {\n      nodeAux = {\n        key: Hash.fromString(nodeAuxJson.key),\n        value: Hash.fromString(nodeAuxJson.value)\n      };\n    }\n    const existence = obj.existence ?? false;\n\n    const siblings: Siblings = obj.siblings.map((s) => Hash.fromString(s));\n\n    return new Proof({ existence, nodeAux, siblings });\n  }\n\n  allSiblings(): Siblings {\n    return Proof.buildAllSiblings(this.depth, this.notEmpties, this.siblings);\n  }\n\n  public static buildAllSiblings(\n    depth: number,\n    notEmpties: Uint8Array,\n    siblings: Hash[]\n  ): Siblings {\n    let sibIdx = 0;\n    const allSiblings: Siblings = [];\n\n    for (let i = 0; i < depth; i += 1) {\n      if (testBitBigEndian(notEmpties, i)) {\n        allSiblings.push(siblings[sibIdx]);\n        sibIdx += 1;\n      } else {\n        allSiblings.push(ZERO_HASH);\n      }\n    }\n    return allSiblings;\n  }\n}\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use proof.allSiblings instead\n */\n// eslint-disable-next-line @cspell/spellchecker\nexport const siblignsFroomProof = (proof: Proof): Siblings => {\n  return proof.allSiblings();\n};\n\nexport const verifyProof = async (\n  rootKey: Hash,\n  proof: Proof,\n  k: bigint,\n  v: bigint\n): Promise<boolean> => {\n  try {\n    const rFromProof = await rootFromProof(proof, k, v);\n    return bytesEqual(rootKey.value, rFromProof.value);\n  } catch (err) {\n    if (err === ErrNodeAuxNonExistAgainstHIndex) {\n      return false;\n    }\n    throw err;\n  }\n};\n\nexport const rootFromProof = async (proof: Proof, k: bigint, v: bigint): Promise<Hash> => {\n  const kHash = Hash.fromBigInt(k);\n  const vHash = Hash.fromBigInt(v);\n  let midKey: Hash;\n\n  if (proof.existence) {\n    midKey = await leafKey(kHash, vHash);\n  } else {\n    if (typeof proof.nodeAux === 'undefined') {\n      midKey = ZERO_HASH;\n    } else {\n      const nodeAux = proof.nodeAux as unknown as NodeAux;\n      if (bytesEqual(kHash.value, nodeAux.key.value)) {\n        throw ErrNodeAuxNonExistAgainstHIndex;\n      }\n      midKey = await leafKey(nodeAux.key, nodeAux.value);\n    }\n  }\n\n  const siblings = proof.allSiblings();\n\n  const path = getPath(siblings.length, kHash.value);\n\n  for (let i = siblings.length - 1; i >= 0; i -= 1) {\n    if (path[i]) {\n      midKey = await new NodeMiddle(siblings[i], midKey).getKey();\n    } else {\n      midKey = await new NodeMiddle(midKey, siblings[i]).getKey();\n    }\n  }\n\n  return midKey;\n};\n","import { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH, circomSiblingsFromSiblings } from '../hash/hash';\n\nimport { Node } from '../../types';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytesEqual, getPath } from '../utils';\nimport { NodeAux, Siblings } from '../../types/merkletree';\nimport { checkBigIntInField } from '../utils/crypto';\nimport { CircomProcessorProof, CircomVerifierProof } from './circom';\nimport {\n  ErrEntryIndexAlreadyExists,\n  ErrInvalidNodeFound,\n  ErrKeyNotFound,\n  ErrNotFound,\n  ErrNotWritable,\n  ErrReachedMaxLevel\n} from '../errors';\nimport { Proof } from './proof';\nimport { Entry, checkEntryInField } from '../entry';\n\nexport class Merkletree {\n  private _db: ITreeStorage;\n  private _root!: Hash;\n  private _writable: boolean;\n  private _maxLevel: number;\n\n  constructor(_db: ITreeStorage, _writable: boolean, _maxLevels: number) {\n    this._db = _db;\n    this._writable = _writable;\n    this._maxLevel = _maxLevels;\n  }\n\n  async root(): Promise<Hash> {\n    if (!this._root) {\n      this._root = await this._db.getRoot();\n    }\n    return this._root;\n  }\n\n  get maxLevels(): number {\n    return this._maxLevel;\n  }\n\n  async add(k: bigint, v: bigint): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    this._root = await this.root();\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const newNodeLeaf = new NodeLeaf(kHash, vHash);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this._root, 0, path);\n    this._root = newRootKey;\n    await this._db.setRoot(this._root);\n  }\n\n  async updateNode(n: Node): Promise<Hash> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n\n    await this._db.put(k.value, n);\n    return k;\n  }\n\n  async addNode(n: Node): Promise<Hash> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n    // if (typeof this.#db.get(k.value) !== 'undefined') {\n    //   throw ErrNodeKeyAlreadyExists;\n    // }\n\n    await this._db.put(k.value, n);\n    return k;\n  }\n\n  async addEntry(e: Entry): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkEntryInField(e)) {\n      throw 'elements not inside the finite field over r';\n    }\n    this._root = await this._db.getRoot();\n    const hIndex = await e.hIndex();\n    const hValue = await e.hValue();\n\n    const newNodeLeaf = new NodeLeaf(hIndex, hValue);\n    const path = getPath(this.maxLevels, hIndex.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this._root, 0, path);\n    this._root = newRootKey;\n    await this._db.setRoot(this._root);\n  }\n\n  async pushLeaf(\n    newLeaf: Node,\n    oldLeaf: Node,\n    lvl: number,\n    pathNewLeaf: Array<boolean>,\n    pathOldLeaf: Array<boolean>\n  ): Promise<Hash> {\n    if (lvl > this._maxLevel - 2) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    let newNodeMiddle: NodeMiddle;\n\n    if (pathNewLeaf[lvl] === pathOldLeaf[lvl]) {\n      const nextKey = await this.pushLeaf(newLeaf, oldLeaf, lvl + 1, pathNewLeaf, pathOldLeaf);\n      if (pathNewLeaf[lvl]) {\n        newNodeMiddle = new NodeMiddle(new Hash(), nextKey);\n      } else {\n        newNodeMiddle = new NodeMiddle(nextKey, new Hash());\n      }\n\n      return await this.addNode(newNodeMiddle);\n    }\n\n    const oldLeafKey = await oldLeaf.getKey();\n    const newLeafKey = await newLeaf.getKey();\n\n    if (pathNewLeaf[lvl]) {\n      newNodeMiddle = new NodeMiddle(oldLeafKey, newLeafKey);\n    } else {\n      newNodeMiddle = new NodeMiddle(newLeafKey, oldLeafKey);\n    }\n\n    await this.addNode(newLeaf);\n    return await this.addNode(newNodeMiddle);\n  }\n\n  async addLeaf(newLeaf: NodeLeaf, key: Hash, lvl: number, path: Array<boolean>): Promise<Hash> {\n    if (lvl > this._maxLevel - 1) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        return this.addNode(newLeaf);\n      case NODE_TYPE_LEAF: {\n        const nKey = (n as NodeLeaf).entry[0];\n        const newLeafKey = newLeaf.entry[0];\n\n        if (bytesEqual(nKey.value, newLeafKey.value)) {\n          throw ErrEntryIndexAlreadyExists;\n        }\n\n        const pathOldLeaf = getPath(this.maxLevels, nKey.value);\n        return this.pushLeaf(newLeaf, n, lvl, path, pathOldLeaf);\n      }\n      case NODE_TYPE_MIDDLE: {\n        n as NodeMiddle;\n        let newNodeMiddle: NodeMiddle;\n\n        if (path[lvl]) {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childR, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle((n as NodeMiddle).childL, nextKey);\n        } else {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childL, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle(nextKey, (n as NodeMiddle).childR);\n        }\n\n        return this.addNode(newNodeMiddle);\n      }\n      default: {\n        throw ErrInvalidNodeFound;\n      }\n    }\n  }\n\n  async get(k: bigint): Promise<{ key: bigint; value: bigint; siblings: Siblings }> {\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i++) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrKeyNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            key: BigInt('0'),\n            value: BigInt('0'),\n            siblings\n          };\n        case NODE_TYPE_LEAF:\n          // if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n          //   return {\n          //     key: (n as NodeLeaf).entry[0].BigInt(),\n          //     value: (n as NodeLeaf).entry[1].BigInt(),\n          //     siblings,\n          //   };\n          // }\n          return {\n            key: (n as NodeLeaf).entry[0].bigInt(),\n            value: (n as NodeLeaf).entry[1].bigInt(),\n            siblings\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw new Error(ErrReachedMaxLevel);\n  }\n\n  async update(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkBigIntInField(k)) {\n      throw 'key not inside the finite field';\n    }\n    if (!checkBigIntInField(v)) {\n      throw 'key not inside the finite field';\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const cp = new CircomProcessorProof();\n\n    cp.fnc = 1;\n    cp.oldRoot = await this.root();\n    cp.oldKey = kHash;\n    cp.newKey = kHash;\n    cp.newValue = vHash;\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            cp.oldValue = (n as NodeLeaf).entry[1];\n            cp.siblings = circomSiblingsFromSiblings([...siblings], this.maxLevels);\n            const newNodeLeaf = new NodeLeaf(kHash, vHash);\n            await this.updateNode(newNodeLeaf);\n\n            const newRootKey = await this.recalculatePathUntilRoot(path, newNodeLeaf, siblings);\n\n            this._root = newRootKey;\n            await this._db.setRoot(newRootKey);\n            cp.newRoot = newRootKey;\n            return cp;\n          }\n          break;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async getNode(k: Hash): Promise<Node | undefined> {\n    if (bytesEqual(k.value, ZERO_HASH.value)) {\n      return new NodeEmpty();\n    }\n    return await this._db.get(k.value);\n  }\n\n  async recalculatePathUntilRoot(\n    path: Array<boolean>,\n    node: Node,\n    siblings: Siblings\n  ): Promise<Hash> {\n    for (let i = siblings.length - 1; i >= 0; i -= 1) {\n      const nodeKey = await node.getKey();\n      if (path[i]) {\n        node = new NodeMiddle(siblings[i], nodeKey);\n      } else {\n        node = new NodeMiddle(nodeKey, siblings[i]);\n      }\n      await this.addNode(node);\n    }\n\n    const nodeKey = await node.getKey();\n    return nodeKey;\n  }\n\n  // Delete removes the specified Key from the MerkleTree and updates the path\n  // from the deleted key to the Root with the new values.  This method removes\n  // the key from the MerkleTree, but does not remove the old nodes from the\n  // key-value database; this means that if the tree is accessed by an old Root\n  // where the key was not deleted yet, the key will still exist. If is desired\n  // to remove the key-values from the database that are not under the current\n  // Root, an option could be to dump all the leaves (using mt.DumpLeafs) and\n  // import them in a new MerkleTree in a new database (using\n  // mt.ImportDumpedLeafs), but this will loose all the Root history of the\n  // MerkleTree\n  async delete(k: bigint): Promise<void> {\n    if (!this._writable) {\n      throw ErrNotWritable;\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = this._root;\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this._maxLevel; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.bytes, (n as NodeLeaf).entry[0].value)) {\n            await this.rmAndUpload(path, kHash, siblings);\n            return;\n          }\n          throw ErrKeyNotFound;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async rmAndUpload(path: Array<boolean>, kHash: Hash, siblings: Siblings): Promise<void> {\n    if (siblings.length === 0) {\n      this._root = ZERO_HASH;\n      await this._db.setRoot(this._root);\n      return;\n    }\n\n    const toUpload = siblings[siblings.length - 1];\n    if (siblings.length < 2) {\n      this._root = siblings[0];\n      await this._db.setRoot(this._root);\n    }\n\n    const nearestSibling = await this._db.get(toUpload.bytes);\n    if (nearestSibling?.type === NODE_TYPE_MIDDLE) {\n      let newNode: Node;\n      if (path[siblings.length - 1]) {\n        newNode = new NodeMiddle(toUpload, ZERO_HASH);\n      } else {\n        newNode = new NodeMiddle(ZERO_HASH, toUpload);\n      }\n      await this.addNode(newNode);\n      const newRootKey = await this.recalculatePathUntilRoot(\n        path,\n        newNode,\n        siblings.slice(0, siblings.length - 1)\n      );\n      this._root = newRootKey;\n      await this._db.setRoot(this._root);\n      return;\n    }\n\n    for (let i = siblings.length - 2; i >= 0; i -= 1) {\n      if (!bytesEqual(siblings[i].value, ZERO_HASH.value)) {\n        let newNode: Node;\n        if (path[i]) {\n          newNode = new NodeMiddle(siblings[i], toUpload);\n        } else {\n          newNode = new NodeMiddle(toUpload, siblings[i]);\n        }\n        await this.addNode(newNode);\n\n        const newRootKey = await this.recalculatePathUntilRoot(path, newNode, siblings.slice(0, i));\n\n        this._root = newRootKey;\n        await this._db.setRoot(this._root);\n        break;\n      }\n\n      if (i === 0) {\n        this._root = toUpload;\n        await this._db.setRoot(this._root);\n        break;\n      }\n    }\n  }\n\n  async recWalk(key: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        await f(n);\n        break;\n      case NODE_TYPE_LEAF:\n        await f(n);\n        break;\n      case NODE_TYPE_MIDDLE:\n        await f(n);\n        await this.recWalk((n as NodeMiddle).childL, f);\n        await this.recWalk((n as NodeMiddle).childR, f);\n        break;\n      default:\n        throw ErrInvalidNodeFound;\n    }\n  }\n\n  async walk(rootKey: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    await this.recWalk(rootKey, f);\n  }\n\n  async generateCircomVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    const cp = await this.generateSCVerifierProof(k, rootKey);\n    cp.siblings = circomSiblingsFromSiblings(cp.siblings, this.maxLevels);\n    return cp;\n  }\n\n  async generateSCVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n\n    const { proof, value } = await this.generateProof(k, rootKey);\n    const cp = new CircomVerifierProof();\n    cp.root = rootKey;\n    cp.siblings = proof.allSiblings();\n    if (typeof proof.nodeAux !== 'undefined') {\n      cp.oldKey = proof.nodeAux.key;\n      cp.oldValue = proof.nodeAux.value;\n    } else {\n      cp.oldKey = ZERO_HASH;\n      cp.oldValue = ZERO_HASH;\n    }\n    cp.key = Hash.fromBigInt(k);\n    cp.value = Hash.fromBigInt(value);\n\n    if (proof.existence) {\n      cp.fnc = 0;\n    } else {\n      cp.fnc = 1;\n    }\n\n    return cp;\n  }\n\n  async generateProof(k: bigint, rootKey?: Hash): Promise<{ proof: Proof; value: bigint }> {\n    let siblingKey: Hash;\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n    if (!rootKey) {\n      rootKey = await this.root();\n    }\n    let nextKey = rootKey;\n\n    let depth = 0;\n    let existence = false;\n    const siblings: Siblings = [];\n    let nodeAux: NodeAux | undefined;\n\n    for (depth = 0; depth < this.maxLevels; depth += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: BigInt('0')\n          };\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            existence = true;\n\n            return {\n              proof: new Proof({\n                existence,\n                nodeAux,\n                siblings\n              }),\n              value: (n as NodeLeaf).entry[1].bigInt()\n            };\n          }\n          nodeAux = {\n            key: (n as NodeLeaf).entry[0],\n            value: (n as NodeLeaf).entry[1]\n          };\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: (n as NodeLeaf).entry[1].bigInt()\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[depth]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblingKey = (n as NodeMiddle).childL;\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblingKey = (n as NodeMiddle).childR;\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n      siblings.push(siblingKey);\n    }\n    throw ErrKeyNotFound;\n  }\n\n  async addAndGetCircomProof(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    const cp = new CircomProcessorProof();\n    cp.fnc = 2;\n    cp.oldRoot = await this.root();\n    let key = BigInt('0');\n    let value = BigInt('0');\n    let siblings: Siblings = [];\n    try {\n      const res = await this.get(k);\n      key = res.key;\n      value = res.value;\n      siblings = res.siblings;\n    } catch (err) {\n      if (err !== ErrKeyNotFound) {\n        throw err;\n      }\n    }\n\n    if (typeof key === 'undefined' || typeof value === 'undefined') {\n      throw 'key/value undefined';\n    }\n\n    cp.oldKey = Hash.fromBigInt(key);\n    cp.oldValue = Hash.fromBigInt(value);\n\n    if (bytesEqual(cp.oldKey.value, ZERO_HASH.value)) {\n      cp.isOld0 = true;\n    }\n\n    cp.siblings = circomSiblingsFromSiblings(siblings, this.maxLevels);\n    await this.add(k, v);\n\n    cp.newKey = Hash.fromBigInt(k);\n    cp.newValue = Hash.fromBigInt(v);\n    cp.newRoot = await this.root();\n\n    return cp;\n  }\n\n  // NOTE: for now it only prints to console, will be updated in future\n  async graphViz(rootKey: Hash): Promise<void> {\n    let cnt = 0;\n\n    await this.walk(rootKey, async (n: Node) => {\n      const k = await n.getKey();\n      let lr: [string, string];\n      let emptyNodes: string;\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          break;\n        case NODE_TYPE_LEAF:\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" [style=filled]`);\n          break;\n        case NODE_TYPE_MIDDLE:\n          lr = [(n as NodeMiddle).childL.string(), (n as NodeMiddle).childR.string()];\n          emptyNodes = '';\n\n          lr.forEach((s, i) => {\n            if (s === '0') {\n              lr[i] = `empty${cnt}`;\n              emptyNodes += `\"${lr[i]}\" [style=dashed,label=0];\\n`;\n              cnt += 1;\n            }\n          });\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" -> {\"${lr[1]}\"}`);\n          // eslint-disable-next-line no-console\n          console.log(emptyNodes);\n          break;\n        default:\n          break;\n      }\n    });\n\n    // eslint-disable-next-line no-console\n    console.log(`}\\n`);\n  }\n\n  async printGraphViz(rootKey: Hash): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    // eslint-disable-next-line no-console\n    console.log(\n      `--------\\nGraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n`\n    );\n    await this.graphViz(ZERO_HASH);\n    // eslint-disable-next-line no-console\n    console.log(\n      `End of GraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n--------\\n`\n    );\n  }\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[14]}