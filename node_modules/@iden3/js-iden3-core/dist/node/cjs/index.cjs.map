{
  "version": 3,
  "sources": ["../../../src/index.ts", "../../../src/schemaHash.ts", "../../../src/constants.ts", "../../../src/utils.ts", "../../../src/elemBytes.ts", "../../../src/id.ts", "../../../src/claim.ts", "../../../src/did/did-helper.ts", "../../../src/did/types.ts", "../../../src/did/did-parser.ts", "../../../src/did/did.ts", "../../../src/registration.ts"],
  "sourcesContent": ["export * from './claim';\nexport * from './constants';\nexport * from './did';\nexport * from './elemBytes';\nexport * from './id';\nexport * from './schemaHash';\nexport * from './utils';\nexport * from './registration';\n", "import { Hex } from '@iden3/js-crypto';\nimport { Constants } from './constants';\nimport { BytesHelper } from './elemBytes';\n\nexport class SchemaHash {\n  // authSchemaHash predefined value of auth schema, used for auth claim during identity creation.\n  // This schema is hardcoded in the identity circuits and used to verify user's auth claim.\n  // Keccak256(https://schema.iden3.io/core/jsonld/auth.jsonld#AuthBJJCredential) last 16 bytes\n  // Hex: cca3371a6cb1b715004407e325bd993c\n  // BigInt: 80551937543569765027552589160822318028\n  static readonly authSchemaHash = new SchemaHash(\n    Uint8Array.from([204, 163, 55, 26, 108, 177, 183, 21, 0, 68, 7, 227, 37, 189, 153, 60])\n  );\n\n  private _bytes: Uint8Array = new Uint8Array(Constants.SCHEMA.HASH_LENGTH);\n  /**\n   * Constructor\n   * @param bytes\n   */\n  constructor(bytes?: Uint8Array) {\n    if (bytes) {\n      this._bytes = bytes;\n    }\n    if (this.bytes.length !== Constants.SCHEMA.HASH_LENGTH) {\n      throw new Error(`Schema hash must be ${Constants.SCHEMA.HASH_LENGTH} bytes long`);\n    }\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  /**\n   * MarshalText returns HEX representation of SchemaHash.\n   * @returns {Uint8Array} 32 bytes//\n   */\n  marshalTextBytes(): Uint8Array {\n    return Hex.encode(this.bytes);\n  }\n\n  marshalText(): string {\n    return Hex.encodeString(this.bytes);\n  }\n\n  /**\n   * NewSchemaHashFromHex creates new SchemaHash from hex string\n   * @param s\n   * @returns {SchemaHash}\n   */\n  static newSchemaHashFromHex(s: string): SchemaHash {\n    const schemaEncodedBytes = Hex.decodeString(s);\n\n    if (schemaEncodedBytes.length !== Constants.SCHEMA.HASH_LENGTH) {\n      throw new Error(`invalid schema hash length: ${schemaEncodedBytes.length}`);\n    }\n\n    return new SchemaHash(schemaEncodedBytes);\n  }\n\n  /**\n   * NewSchemaHashFromInt creates new SchemaHash from big.Int\n   * @param i\n   * @returns\n   */\n  static newSchemaHashFromInt(i: bigint): SchemaHash {\n    const bytes = BytesHelper.intToNBytes(i, Constants.SCHEMA.HASH_LENGTH);\n    const start = Constants.SCHEMA.HASH_LENGTH - bytes.length;\n    return new SchemaHash(BytesHelper.intToBytes(i).slice(start, Constants.SCHEMA.HASH_LENGTH));\n  }\n\n  /**\n   * Convert SchemaHash to big.Int\n   * @returns {bigint}\n   */\n  bigInt(): bigint {\n    return BytesHelper.bytesToInt(this.bytes);\n  }\n}\n", "export const Constants = Object.freeze({\n  ERRORS: {\n    // ErrDataOverflow means that given *big.Int value does not fit in Field Q\n    // e.g. greater than Q constant:\n    // Q constant: 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    DATA_OVERFLOW: new Error('data does not fits SNARK size'),\n    // ErrIncorrectIDPosition means that passed position is not one of predefined:\n    // IDPositionIndex or IDPositionValue\n    INCORRECT_ID_POSITION: new Error('incorrect ID position'),\n    // throws when ID not found in the Claim.\n    NO_ID: new Error('ID is not set'),\n    // throws when subject position flags sets in invalid value.\n    INVALID_SUBJECT_POSITION: new Error('invalid subject position'),\n    // ErrIncorrectMerklizePosition means that passed position is not one of predefined:\n    // MerklizePositionIndex or MerklizePositionValue\n    INCORRECT_MERKLIZED_POSITION: new Error('incorrect Merklize position'),\n    // ErrNoMerklizedRoot returns when Merklized Root is not found in the Claim.\n    NO_MERKLIZED_ROOT: new Error('Merklized root is not set'),\n    NETWORK_NOT_SUPPORTED_FOR_DID: new Error('network in not supported for did'),\n    UNSUPPORTED_BLOCKCHAIN_FOR_DID: new Error('not supported blockchain for did'),\n    UNSUPPORTED_DID_METHOD: new Error('not supported DID method'),\n    UNKNOWN_DID_METHOD: new Error('unknown DID method'),\n    INCORRECT_DID: new Error('incorrect DID'),\n    UNSUPPORTED_ID: new Error('unsupported Id')\n  },\n  SCHEMA: {\n    HASH_LENGTH: 16\n  },\n  ETH_ADDRESS_LENGTH: 20,\n  BYTES_LENGTH: 32,\n  ELEM_BYTES_LENGTH: 4,\n  NONCE_BYTES_LENGTH: 8,\n  Q: BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617'),\n  ID: {\n    TYPE_DEFAULT: Uint8Array.from([0x00, 0x00]),\n    TYPE_READONLY: Uint8Array.from([0b00000000, 0b00000001]),\n    ID_LENGTH: 31\n  },\n  DID: {\n    DID_SCHEMA: 'did'\n  },\n  GENESIS_LENGTH: 27\n});\n\nexport const Blockchain: { [k: string]: string } = {\n  Ethereum: 'eth',\n  Polygon: 'polygon',\n  Privado: 'privado',\n  Billions: 'billions',\n  Linea: 'linea',\n  Unknown: 'unknown',\n  NoChain: '',\n  ReadOnly: 'readonly'\n};\n\nexport const NetworkId: { [k: string]: string } = {\n  Main: 'main',\n  Mumbai: 'mumbai',\n  Amoy: 'amoy',\n  Goerli: 'goerli',\n  Sepolia: 'sepolia',\n  Zkevm: 'zkevm',\n  Cardona: 'cardona',\n  Test: 'test',\n  Unknown: 'unknown',\n  NoNetwork: ''\n};\n\nexport const DidMethod: { [k: string]: string } = {\n  Iden3: 'iden3',\n  PolygonId: 'polygonid',\n  Other: ''\n};\n\n/**\n * Object containing chain IDs for various blockchains and networks.\n * @type { [key: string]: number }\n */\nexport const ChainIds: { [key: string]: number } = {\n  [`${Blockchain.Ethereum}:${NetworkId.Main}`]: 1,\n  [`${Blockchain.Ethereum}:${NetworkId.Goerli}`]: 5,\n  [`${Blockchain.Ethereum}:${NetworkId.Sepolia}`]: 11155111,\n  [`${Blockchain.Polygon}:${NetworkId.Main}`]: 137,\n  [`${Blockchain.Polygon}:${NetworkId.Mumbai}`]: 80001,\n  [`${Blockchain.Polygon}:${NetworkId.Amoy}`]: 80002,\n  [`${Blockchain.Polygon}:${NetworkId.Zkevm}`]: 1101,\n  [`${Blockchain.Polygon}:${NetworkId.Cardona}`]: 2442,\n  [`${Blockchain.Privado}:${NetworkId.Main}`]: 21000,\n  [`${Blockchain.Privado}:${NetworkId.Test}`]: 21001,\n  [`${Blockchain.Linea}:${NetworkId.Main}`]: 59144,\n  [`${Blockchain.Linea}:${NetworkId.Sepolia}`]: 59141,\n  [`${Blockchain.Billions}:${NetworkId.Main}`]: 45056,\n  [`${Blockchain.Billions}:${NetworkId.Test}`]: 6913\n};\n\nexport const DidMethodByte: { [key: string]: number } = {\n  [DidMethod.Iden3]: 0b00000001,\n  [DidMethod.PolygonId]: 0b00000010,\n  [DidMethod.Other]: 0b11111111\n};\n\nconst blockchainNetworkMap = {\n  [`${Blockchain.ReadOnly}:${NetworkId.NoNetwork}`]: 0b00000000,\n  [`${Blockchain.Polygon}:${NetworkId.Main}`]: 0b0001_0000 | 0b0000_0001,\n  [`${Blockchain.Polygon}:${NetworkId.Mumbai}`]: 0b0001_0000 | 0b0000_0010,\n  [`${Blockchain.Polygon}:${NetworkId.Amoy}`]: 0b0001_0000 | 0b0000_0011,\n  [`${Blockchain.Polygon}:${NetworkId.Zkevm}`]: 0b0001_0000 | 0b0000_0100,\n  [`${Blockchain.Polygon}:${NetworkId.Cardona}`]: 0b0001_0000 | 0b0000_0101,\n  [`${Blockchain.Ethereum}:${NetworkId.Main}`]: 0b0010_0000 | 0b0000_0001,\n  [`${Blockchain.Ethereum}:${NetworkId.Goerli}`]: 0b0010_0000 | 0b0000_0010,\n  [`${Blockchain.Ethereum}:${NetworkId.Sepolia}`]: 0b0010_0000 | 0b0000_0011,\n  [`${Blockchain.Privado}:${NetworkId.Main}`]: 0b1010_0000 | 0b0000_0001,\n  [`${Blockchain.Privado}:${NetworkId.Test}`]: 0b1010_0000 | 0b0000_0010,\n  [`${Blockchain.Linea}:${NetworkId.Main}`]: 0b0100_0000 | 0b0000_1001,\n  [`${Blockchain.Linea}:${NetworkId.Sepolia}`]: 0b0100_0000 | 0b0000_1000,\n  [`${Blockchain.Billions}:${NetworkId.Main}`]: 0b1011_0000 | 0b0000_0001,\n  [`${Blockchain.Billions}:${NetworkId.Test}`]: 0b1011_0000 | 0b0000_0010\n};\n\n// DIDMethodNetwork is map for did methods and their blockchain networks\nexport const DidMethodNetwork: {\n  [k: string]: { [k: string]: number };\n} = {\n  [DidMethod.Iden3]: {\n    ...blockchainNetworkMap\n  },\n  [DidMethod.PolygonId]: {\n    ...blockchainNetworkMap\n  },\n  [DidMethod.Other]: {\n    [`${Blockchain.Unknown}:${NetworkId.Unknown}`]: 0b1111_1111\n  }\n};\n", "import { poseidon } from '@iden3/js-crypto';\nimport { Constants } from './constants';\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nexport const encoder = new TextEncoder();\n\nexport function fromLittleEndian(bytes: Uint8Array): bigint {\n  const n256 = BigInt(256);\n  let result = BigInt(0);\n  let base = BigInt(1);\n  bytes.forEach((byte) => {\n    result += base * BigInt(byte);\n    base = base * n256;\n  });\n  return result;\n}\n\nexport function fromBigEndian(bytes: Uint8Array): bigint {\n  return fromLittleEndian(bytes.reverse());\n}\n\nexport function toLittleEndian(bigNumber: bigint, len = 31): Uint8Array {\n  const n256 = BigInt(256);\n  const result = new Uint8Array(len);\n  let i = 0;\n  while (bigNumber > BigInt(0)) {\n    result[i] = Number(bigNumber % n256);\n    bigNumber = bigNumber / n256;\n    i += 1;\n  }\n  return result;\n}\n\nexport function toBigEndian(bigNumber: bigint, len = 31): Uint8Array {\n  return toLittleEndian(bigNumber, len).reverse();\n}\n\nexport function putUint32(n: number): Uint8Array {\n  const buf = new ArrayBuffer(4);\n  const view = new DataView(buf);\n  view.setUint32(0, n, true);\n  return new Uint8Array(buf);\n}\n\nexport function getUint32(arr: Uint8Array): number {\n  const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  return new DataView(buf).getUint32(0, true);\n}\n\nexport function putUint64(n: bigint): Uint8Array {\n  const buf = new ArrayBuffer(8);\n  const view = new DataView(buf);\n  view.setBigUint64(0, n, true);\n  return new Uint8Array(buf);\n}\n\nexport function getUint64(arr: Uint8Array): bigint {\n  const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  return new DataView(buf).getBigUint64(0, true);\n}\n\nexport function getUnixTimestamp(d: Date): number {\n  return Math.floor(d.getTime() / 1000);\n}\nexport function getDateFromUnixTimestamp(n: number): Date {\n  return new Date(n * 1000);\n}\n\n// checkBigIntInField checks if given *big.Int fits in a Field Q element\nexport function checkBigIntInField(a: bigint): boolean {\n  return a < Constants.Q;\n}\n\nexport function checkBigIntArrayInField(arr: bigint[]): boolean {\n  return arr.every((n) => checkBigIntInField(n));\n}\n\n// IdenState calculates the Identity State from the Claims Tree Root,\n// Revocation Tree Root and Roots Tree Root.\nexport function idenState(clr: bigint, rer: bigint, ror: bigint): bigint {\n  return poseidon.hash([clr, rer, ror]);\n}\n\nexport class StringUtils {\n  static isNotValidIDChar(char: string): boolean {\n    return (\n      StringUtils.isNotAlpha(char) && StringUtils.isNotDigit(char) && char !== '.' && char !== '-'\n    );\n  }\n\n  static isNotValidParamChar(char: string): boolean {\n    return (\n      StringUtils.isNotAlpha(char) &&\n      StringUtils.isNotDigit(char) &&\n      char !== '.' &&\n      char !== '-' &&\n      char !== '_' &&\n      char !== ':'\n    );\n  }\n\n  static isNotValidQueryOrFragmentChar(char: string): boolean {\n    return StringUtils.isNotValidPathChar(char) && char !== '/' && char !== '?';\n  }\n\n  static isNotValidPathChar(char: string): boolean {\n    return StringUtils.isNotUnreservedOrSubdelim(char) && char !== ':' && char !== '@';\n  }\n\n  static isNotUnreservedOrSubdelim(char: string): boolean {\n    switch (char) {\n      case '-':\n      case '.':\n      case '_':\n      case '~':\n      case '!':\n      case '$':\n      case '&':\n      case \"'\":\n      case '(':\n      case ')':\n      case '*':\n      case '+':\n      case ',':\n      case ';':\n      case '=':\n        return false;\n      default:\n        if (StringUtils.isNotAlpha(char) && StringUtils.isNotDigit(char)) {\n          return true;\n        }\n        return false;\n    }\n  }\n\n  static isNotHexDigit(char: string): boolean {\n    return (\n      StringUtils.isNotDigit(char) &&\n      (char < '\\x41' || char > '\\x46') &&\n      (char < '\\x61' || char > '\\x66')\n    );\n  }\n\n  static isNotDigit(char: string): boolean {\n    // '\\x30' is digit 0, '\\x39' is digit 9\n    return char < '\\x30' || char > '\\x39';\n  }\n\n  // StringUtils.isNotAlpha returns true if a byte is not a big letter between A-Z or small letter between a-z\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotAlpha(char: string): boolean {\n    return StringUtils.isNotSmallLetter(char) && StringUtils.isNotBigLetter(char);\n  }\n\n  // isNotBigLetter returns true if a byte is not a big letter between A-Z\n  // in US-ASCII http://www.columbia.edu/kermit/ascii.html\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotBigLetter(char: string): boolean {\n    // '\\x41' is big letter A, '\\x5A' small letter Z\n    return char < '\\x41' || char > '\\x5A';\n  }\n\n  // isNotSmallLetter returns true if a byte is not a small letter between a-z\n  // in US-ASCII http://www.columbia.edu/kermit/ascii.html\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotSmallLetter(char: string): boolean {\n    // '\\x61' is small letter a, '\\x7A' small letter z\n    return char < '\\x61' || char > '\\x7A';\n  }\n}\n\nexport const genesisFromEthAddress = (addr: Uint8Array) => {\n  return Uint8Array.from([...new Uint8Array(7), ...addr]);\n};\n", "import { Constants } from './constants';\nimport { checkBigIntInField, fromLittleEndian, toLittleEndian, encoder } from './utils';\nimport { Hex, sha256 } from '@iden3/js-crypto';\nexport class BytesHelper {\n  static intToBytes(int: bigint): Uint8Array {\n    return BytesHelper.intToNBytes(int, Constants.BYTES_LENGTH);\n  }\n\n  static intToNBytes(int: bigint, n: number): Uint8Array {\n    return Uint8Array.from(toLittleEndian(int, n));\n  }\n\n  static checkChecksum(bytes: Uint8Array): boolean {\n    const { typ, genesis, checksum } = BytesHelper.decomposeBytes(bytes);\n    if (!checksum.length || JSON.stringify(Uint8Array.from([0, 0])) === JSON.stringify(checksum)) {\n      return false;\n    }\n\n    const c = BytesHelper.calculateChecksum(typ, genesis);\n    return JSON.stringify(c) === JSON.stringify(checksum);\n  }\n\n  static decomposeBytes(b: Uint8Array): {\n    typ: Uint8Array;\n    genesis: Uint8Array;\n    checksum: Uint8Array;\n  } {\n    const offset = 2;\n    const len = b.length - offset;\n    return {\n      typ: b.slice(0, offset),\n      genesis: b.slice(offset, len),\n      checksum: b.slice(-offset)\n    };\n  }\n\n  static calculateChecksum(typ: Uint8Array, genesis: Uint8Array): Uint8Array {\n    const toChecksum = [...typ, ...genesis];\n    const s: number = toChecksum.reduce((acc, cur) => acc + cur, 0);\n    const checksum = [s >> 8, s & 0xff];\n    return Uint8Array.from(checksum.reverse());\n  }\n\n  static hashBytes(str: string): Uint8Array {\n    const hash = sha256(encoder.encode(str));\n    return new Uint8Array(hash);\n  }\n\n  static hexToBytes(str: string): Uint8Array {\n    return Hex.decodeString(str);\n  }\n\n  static bytesToHex(bytes: Uint8Array) {\n    const hex: string[] = [];\n    for (let i = 0; i < bytes.length; i++) {\n      const current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];\n      hex.push((current >>> 4).toString(16));\n      hex.push((current & 0xf).toString(16));\n    }\n    return hex.join('');\n  }\n\n  static bytesToInt(bytes: Uint8Array): bigint {\n    return fromLittleEndian(bytes);\n  }\n}\n\nexport class ElemBytes {\n  private _bytes = new Uint8Array(Constants.BYTES_LENGTH);\n\n  constructor(bytes?: Uint8Array | null) {\n    if (bytes) {\n      this._bytes = bytes;\n    }\n    if (this._bytes.length !== Constants.BYTES_LENGTH) {\n      throw new Error('Invalid bytes length');\n    }\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  set bytes(value: Uint8Array) {\n    this._bytes = value;\n  }\n\n  toBigInt(): bigint {\n    return BytesHelper.bytesToInt(this._bytes);\n  }\n\n  setBigInt(n: bigint): ElemBytes {\n    if (!checkBigIntInField(n)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._bytes = BytesHelper.intToBytes(n);\n    return this;\n  }\n\n  slotFromHex(hex: string): ElemBytes {\n    const bytes = Hex.decodeString(hex);\n    if (bytes.length !== Constants.BYTES_LENGTH) {\n      throw new Error('Invalid bytes length');\n    }\n    this._bytes.set(bytes, 0);\n    return this;\n  }\n\n  hex(): string {\n    return Hex.encodeString(this._bytes);\n  }\n\n  // ElemBytesToInts converts slice of ElemBytes to slice of *big.Int\n  static elemBytesToInts(elements: ElemBytes[]): bigint[] {\n    const result: bigint[] = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      result.push(element.toBigInt());\n    }\n\n    return result;\n  }\n\n  static fromInt(i: bigint): ElemBytes {\n    if (!checkBigIntInField(i)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    const bytes = BytesHelper.intToBytes(i);\n    return new ElemBytes(bytes);\n  }\n}\n", "import { Constants } from './constants';\nimport { fromLittleEndian } from './utils';\nimport { BytesHelper, ElemBytes } from './elemBytes';\nimport { poseidon, base58ToBytes, base58FromBytes } from '@iden3/js-crypto';\n\n// ID is a byte array with\n// [  type  | root_genesis | checksum ]\n// [2 bytes |   27 bytes   | 2 bytes  ]\n// where the root_genesis are the first 28 bytes from the hash root_genesis\n\nexport class Id {\n  private _bytes: Uint8Array;\n  private readonly _checksum: Uint8Array;\n\n  constructor(typ: Uint8Array, genesis: Uint8Array) {\n    this._checksum = BytesHelper.calculateChecksum(typ, genesis);\n    this._bytes = Uint8Array.from([...typ, ...genesis, ...this._checksum]);\n  }\n\n  private static getFromBytes(bytes: Uint8Array): Id {\n    const { typ, genesis }: { typ: Uint8Array; genesis: Uint8Array } =\n      BytesHelper.decomposeBytes(bytes);\n    return new Id(typ, genesis);\n  }\n\n  checksum(): Uint8Array {\n    return this._checksum;\n  }\n\n  string(): string {\n    return base58FromBytes(this._bytes);\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  set bytes(b: Uint8Array) {\n    this._bytes = b;\n  }\n\n  type(): Uint8Array {\n    return this._bytes.slice(0, 2);\n  }\n\n  bigInt(): bigint {\n    return fromLittleEndian(this._bytes);\n  }\n\n  equal(id: Id): boolean {\n    return JSON.stringify(this._bytes) === JSON.stringify(id.bytes);\n  }\n\n  marshal(): Uint8Array {\n    return new TextEncoder().encode(this.string());\n  }\n\n  static unMarshal(b: Uint8Array): Id {\n    return Id.fromString(new TextDecoder().decode(b));\n  }\n\n  static fromBytes(b: Uint8Array): Id {\n    const bytes = b ?? Uint8Array.from([]);\n    if (bytes.length !== Constants.ID.ID_LENGTH) {\n      throw new Error('fromBytes error: byte array incorrect length');\n    }\n\n    if (bytes.every((i: number) => i === 0)) {\n      throw new Error('fromBytes error: byte array empty');\n    }\n\n    const id = Id.getFromBytes(bytes);\n\n    if (!BytesHelper.checkChecksum(bytes)) {\n      throw new Error('fromBytes error: checksum error');\n    }\n\n    return id;\n  }\n\n  static fromString(s: string): Id {\n    const bytes = base58ToBytes(s);\n    return Id.fromBytes(bytes);\n  }\n\n  static fromBigInt(bigInt: bigint): Id {\n    const b = BytesHelper.intToNBytes(bigInt, Constants.ID.ID_LENGTH);\n    return Id.fromBytes(b);\n  }\n\n  static profileId(id: Id, nonce: bigint): Id {\n    const bigIntHash = poseidon.hash([id.bigInt(), nonce]);\n    const { typ } = BytesHelper.decomposeBytes(id.bytes);\n    const genesis = BytesHelper.intToNBytes(bigIntHash, 27);\n    return new Id(typ, genesis);\n  }\n\n  // IdGenesisFromIdenState calculates the genesis ID from an Identity State.\n  static idGenesisFromIdenState(\n    typ: Uint8Array, //nolint:revive\n    state: bigint\n  ): Id {\n    const idenStateData = ElemBytes.fromInt(state);\n\n    // we take last 27 bytes, because of swapped endianness\n    const idGenesisBytes = idenStateData.bytes.slice(idenStateData.bytes.length - 27);\n    return new Id(typ, idGenesisBytes);\n  }\n\n  static ethAddressFromId(id: Id): Uint8Array {\n    const isZeros = id.bytes.slice(2, 2 + 7).every((i: number) => i === 0);\n    if (!isZeros) {\n      throw new Error(\"can't get Ethereum address: high bytes of genesis are not zero\");\n    }\n    return id.bytes.slice(2 + 7).slice(0, Constants.ETH_ADDRESS_LENGTH);\n  }\n}\n", "import { SchemaHash } from './schemaHash';\nimport { ElemBytes } from './elemBytes';\nimport { Constants } from './constants';\nimport { Id } from './id';\nimport {\n  checkBigIntArrayInField,\n  checkBigIntInField,\n  getDateFromUnixTimestamp,\n  getUint32,\n  getUint64,\n  getUnixTimestamp,\n  putUint32,\n  putUint64 as getBytesFromUint64\n} from './utils';\nimport { Hex, poseidon } from '@iden3/js-crypto';\n\n/*\nClaim structure\n\nIndex:\n i_0: [ 128  bits ] claim schema\n      [ 32 bits ] option flags\n          [3] Subject:\n            000: A.1 Self\n            001: invalid\n            010: A.2.i OtherIden Index\n            011: A.2.v OtherIden Value\n            100: B.i Object Index\n            101: B.v Object Value\n          [1] Expiration: bool\n          [1] Updatable: bool\n          [3] Merklized: data is merklized root is stored in the:\n            000: none\n            001: C.i Root Index (root located in i_2)\n            010: C.v Root Value (root located in v_2)\n          [24] 0\n      [ 32 bits ] version (optional?)\n      [ 61 bits ] 0 - reserved for future use\n i_1: [ 248 bits] identity (case b) (optional)\n      [  5 bits ] 0\n i_2: [ 253 bits] 0\n i_3: [ 253 bits] 0\nValue:\n v_0: [ 64 bits ]  revocation nonce\n      [ 64 bits ]  expiration date (optional)\n      [ 125 bits] 0 - reserved\n v_1: [ 248 bits] identity (case c) (optional)\n      [  5 bits ] 0\n v_2: [ 253 bits] 0\n v_3: [ 253 bits] 0\n*/\n\nexport enum SlotName {\n  IndexA = 'IndexA',\n  IndexB = 'IndexB',\n  ValueA = 'ValueA',\n  ValueB = 'ValueB'\n}\n\n// ErrSlotOverflow means some ElemBytes overflows Q Field. And wraps the name\n// of overflowed slot.\nexport class ErrSlotOverflow extends Error {\n  constructor(msg: string) {\n    super(`Slot ${msg} not in field (too large)`);\n    Object.setPrototypeOf(this, ErrSlotOverflow.prototype);\n  }\n}\n\n// subjectFlag for the time being describes the location of Id (in index or value\n// slots or nowhere at all).\n//\n// Values subjectFlagInvalid presents for backward compatibility and for now means nothing.\n\nexport enum SubjectFlag {\n  Self = 0b0,\n  Invalid = 0b1,\n  OtherIdenIndex = 0b10,\n  OtherIdenValue = 0b11\n}\n\nexport enum IdPosition {\n  None = 0,\n  Index = 1,\n  Value = 2\n}\n\n// merklizedFlag for the time being describes the location of root (in index or value\n// slots or nowhere at all).\n//\n// Values merklizedFlagIndex indicates that root is located in index[2] slots.\n// Values merklizedFlagValue indicates that root is located in value[2] slots.\nexport enum MerklizedFlag {\n  None = 0b00000000,\n  Index = 0b00100000,\n  Value = 0b01000000,\n  Invalid = 0b10000000\n}\n\nexport enum MerklizedRootPosition {\n  None = 0,\n  Index = 1,\n  Value = 2\n}\n\nexport enum Flags {\n  ByteIdx = 16,\n  ExpirationBitIdx = 3,\n  UpdatableBitIdx = 4\n}\n\nexport class Claim {\n  private _index: ElemBytes[] = [];\n  private _value: ElemBytes[] = [];\n\n  constructor() {\n    for (let i = 0; i < Constants.ELEM_BYTES_LENGTH; i++) {\n      this._index[i] = new ElemBytes();\n      this._value[i] = new ElemBytes();\n    }\n  }\n\n  // NewClaim creates new Claim with specified SchemaHash and any number of\n  // options. Using options you can specify any field in claim.\n  static newClaim(sh: SchemaHash, ...args: ClaimOption[]): Claim {\n    const c = new Claim();\n    c.setSchemaHash(sh);\n    for (let i = 0; i < args.length; i++) {\n      const fn = args[i];\n      fn(c);\n    }\n    return c;\n  }\n\n  // GetSchemaHash return copy of claim's schema hash.\n  getSchemaHash(): SchemaHash {\n    return new SchemaHash(this._index[0].bytes.slice(0, Constants.SCHEMA.HASH_LENGTH));\n  }\n\n  get value(): ElemBytes[] {\n    return this._value;\n  }\n\n  set value(value: ElemBytes[]) {\n    this._value = value;\n  }\n\n  get index(): ElemBytes[] {\n    return this._index;\n  }\n\n  set index(value: ElemBytes[]) {\n    this._index = value;\n  }\n\n  // SetSchemaHash updates claim's schema hash.\n  setSchemaHash(sh: SchemaHash) {\n    this._index[0] = new ElemBytes(\n      Uint8Array.from([...sh.bytes, ...new Array(Constants.SCHEMA.HASH_LENGTH).fill(0)])\n    );\n  }\n\n  setSubject(s: SubjectFlag) {\n    // clean first 3 bits\n    this._index[0].bytes[Flags.ByteIdx] &= 0b11111000;\n    this._index[0].bytes[Flags.ByteIdx] |= s;\n  }\n\n  private getSubject(): SubjectFlag {\n    let sbj = this._index[0].bytes[Flags.ByteIdx];\n    // clean all except first 3 bits\n    sbj &= 0b00000111;\n    return sbj as SubjectFlag;\n  }\n\n  private setFlagExpiration(val: boolean) {\n    if (val) {\n      this._index[0].bytes[Flags.ByteIdx] |= 0b1 << Flags.ExpirationBitIdx;\n    } else {\n      this._index[0].bytes[Flags.ByteIdx] &= ~(0b1 << Flags.ExpirationBitIdx);\n    }\n  }\n\n  private getFlagExpiration(): boolean {\n    const mask = 0b1 << Flags.ExpirationBitIdx;\n    return (this._index[0].bytes[Flags.ByteIdx] & mask) > 0;\n  }\n\n  // GetIDPosition returns the position at which the Id is stored.\n  getIdPosition(): IdPosition {\n    switch (this.getSubject()) {\n      case SubjectFlag.Self:\n        return IdPosition.None;\n      case SubjectFlag.OtherIdenIndex:\n        return IdPosition.Index;\n      case SubjectFlag.OtherIdenValue:\n        return IdPosition.Value;\n      default:\n        throw Constants.ERRORS.INVALID_SUBJECT_POSITION;\n    }\n  }\n\n  // SetValueDataInts sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueDataInts(slotA: bigint | null, slotB: bigint | null): void {\n    this._value[2] = this.setSlotInt(slotA, SlotName.ValueA);\n    this._value[3] = this.setSlotInt(slotB, SlotName.ValueB);\n  }\n  // SetValueDataBytes sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueDataBytes(slotA: Uint8Array, slotB: Uint8Array): void {\n    this._value[2] = this.setSlotBytes(slotA, SlotName.ValueA);\n    this._value[3] = this.setSlotBytes(slotB, SlotName.ValueB);\n  }\n  // SetValueData sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueData(slotA: ElemBytes, slotB: ElemBytes): void {\n    const slotsAsInts: bigint[] = [slotA.toBigInt(), slotB.toBigInt()];\n    if (!checkBigIntArrayInField(slotsAsInts)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._value[2] = slotA;\n    this._value[3] = slotB;\n  }\n  // SetIndexDataInts sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexDataInts(slotA: bigint | null, slotB: bigint | null): void {\n    this._index[2] = this.setSlotInt(slotA, SlotName.IndexA);\n    this._index[3] = this.setSlotInt(slotB, SlotName.IndexB);\n  }\n  // SetIndexDataBytes sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexDataBytes(slotA: Uint8Array | null, slotB: Uint8Array | null): void {\n    this._index[2] = this.setSlotBytes(slotA, SlotName.IndexA);\n    this._index[3] = this.setSlotBytes(slotB, SlotName.IndexB);\n  }\n\n  private setSlotBytes(value: Uint8Array | null, slotName: SlotName): ElemBytes {\n    const slot = new ElemBytes(value);\n    if (!checkBigIntInField(slot.toBigInt())) {\n      throw new ErrSlotOverflow(slotName);\n    }\n    return slot;\n  }\n\n  setFlagMerklized(s: MerklizedRootPosition): void {\n    let f: number;\n    switch (s) {\n      case MerklizedRootPosition.Index:\n        f = MerklizedFlag.Index;\n        break;\n      case MerklizedRootPosition.Value:\n        f = MerklizedFlag.Value;\n        break;\n      default:\n        f = MerklizedFlag.None;\n    }\n    // clean last 3 bits\n    this.index[0].bytes[Flags.ByteIdx] &= 0b00011111;\n    this.index[0].bytes[Flags.ByteIdx] |= f;\n  }\n\n  private getMerklized(): MerklizedFlag {\n    let mt = this.index[0].bytes[Flags.ByteIdx];\n    // clean all except last 3 bits\n    mt &= 0b11100000;\n    return mt as MerklizedFlag;\n  }\n\n  // GetMerklizedPosition returns the position at which the Merklized flag is stored.\n  getMerklizedPosition(): MerklizedRootPosition {\n    switch (this.getMerklized()) {\n      case MerklizedFlag.None:\n        return MerklizedRootPosition.None;\n      case MerklizedFlag.Index:\n        return MerklizedRootPosition.Index;\n      case MerklizedFlag.Value:\n        return MerklizedRootPosition.Value;\n      default:\n        throw Constants.ERRORS.INCORRECT_MERKLIZED_POSITION;\n    }\n  }\n\n  public setSlotInt(value: bigint | null, slotName: SlotName): ElemBytes {\n    if (!value) {\n      value = BigInt(0);\n    }\n    if (!checkBigIntInField(value)) {\n      throw new ErrSlotOverflow(slotName);\n    }\n    return new ElemBytes().setBigInt(value);\n  }\n  // SetIndexData sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexData(slotA: ElemBytes, slotB: ElemBytes) {\n    const slotsAsInts: bigint[] = [slotA.toBigInt(), slotB.toBigInt()];\n    if (!checkBigIntArrayInField(slotsAsInts)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._index[2] = slotA;\n    this._index[3] = slotB;\n  }\n\n  resetExpirationDate(): void {\n    this.setFlagExpiration(false);\n    const bytes = Array.from({ length: Constants.NONCE_BYTES_LENGTH }, () => 0);\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(Constants.NONCE_BYTES_LENGTH, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  // GetExpirationDate returns expiration date and flag. Flag is true if\n  // expiration date is present, false if null.\n  getExpirationDate(): Date | null {\n    if (this.getFlagExpiration()) {\n      const unixTimestamp = getUint64(this._value[0].bytes.slice(8, 16));\n      return getDateFromUnixTimestamp(Number(unixTimestamp));\n    }\n    return null;\n  }\n\n  // SetExpirationDate sets expiration date to dt\n  setExpirationDate(dt: Date) {\n    this.setFlagExpiration(true);\n    const bytes = getBytesFromUint64(BigInt(getUnixTimestamp(dt)));\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(Constants.NONCE_BYTES_LENGTH, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  // GetRevocationNonce returns revocation nonce\n  getRevocationNonce(): bigint {\n    return getUint64(this._value[0].bytes.slice(0, 8));\n  }\n  // SetRevocationNonce sets claim's revocation nonce\n  setRevocationNonce(nonce: bigint): void {\n    const bytes = getBytesFromUint64(nonce);\n    if (bytes.length > Constants.NONCE_BYTES_LENGTH) {\n      throw new Error('Nonce length is not valid');\n    }\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(0, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  getValueId(): Id {\n    return Id.fromBytes(this._value[1].bytes.slice(0, -1));\n  }\n\n  // SetValueId sets id to value. Removes id from index if any.\n  setValueId(id: Id): void {\n    this.resetIndexId();\n    this.setSubject(SubjectFlag.OtherIdenValue);\n    const arr = Array.from(this._index[1].bytes);\n    arr.splice(0, id.bytes.length, ...id.bytes);\n    this._value[1] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  private resetIndexId() {\n    this._index[1] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  private resetValueId(): void {\n    this._value[1] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  getIndexId(): Id {\n    return Id.fromBytes(this._index[1].bytes.slice(0, -1));\n  }\n\n  // SetIndexId sets id to index. Removes id from value if any.\n  setIndexId(id: Id): void {\n    this.resetValueId();\n    this.setSubject(SubjectFlag.OtherIdenIndex);\n    const arr = Array.from(this._index[1].bytes);\n    arr.splice(0, id.bytes.length, ...id.bytes);\n    this._index[1] = new ElemBytes(Uint8Array.from(arr));\n  }\n  // SetVersion sets claim's version\n  setVersion(ver: number) {\n    const bytes = putUint32(ver);\n    this._index[0].bytes[20] = bytes[0];\n    this._index[0].bytes[21] = bytes[1];\n    this._index[0].bytes[22] = bytes[2];\n    this._index[0].bytes[23] = bytes[3];\n  }\n  // GetVersion returns claim's version\n  getVersion(): number {\n    return getUint32(this._index[0].bytes.slice(20, 24));\n  }\n  // SetFlagUpdatable sets claim's flag `updatable`\n  setFlagUpdatable(val: boolean) {\n    if (val) {\n      this._index[0].bytes[Flags.ByteIdx] |= 0b1 << Flags.UpdatableBitIdx;\n    } else {\n      this._index[0].bytes[Flags.ByteIdx] &= ~(0b1 << Flags.UpdatableBitIdx);\n    }\n  }\n\n  // HIndex calculates the hash of the Index of the Claim\n  hIndex(): bigint {\n    return poseidon.hash(ElemBytes.elemBytesToInts(this._index));\n  }\n\n  // GetFlagUpdatable returns claim's flag `updatable`\n  getFlagUpdatable(): boolean {\n    const mask = 0b1 << Flags.UpdatableBitIdx;\n    return (this._index[0].bytes[Flags.ByteIdx] & mask) > 0;\n  }\n\n  // HValue calculates the hash of the Value of the Claim\n  hValue(): bigint {\n    return poseidon.hash(ElemBytes.elemBytesToInts(this._value));\n  }\n\n  // HiHv returns the HIndex and HValue of the Claim\n  hiHv(): { hi: bigint; hv: bigint } {\n    return { hi: this.hIndex(), hv: this.hValue() };\n  }\n\n  // SetIndexMerklizedRoot sets merklized root to index. Removes root from value[2] if any.\n  setIndexMerklizedRoot(r: bigint): void {\n    this.resetValueMerklizedRoot();\n    this.setFlagMerklized(MerklizedRootPosition.Index);\n    this.index[2] = this.setSlotInt(r, SlotName.IndexA);\n  }\n\n  resetIndexMerklizedRoot() {\n    this._index[2] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  // SetValueMerklizedRoot sets merklized root to value. Removes root from index[2] if any.\n  setValueMerklizedRoot(r: bigint): void {\n    this.resetIndexMerklizedRoot();\n    this.setFlagMerklized(MerklizedRootPosition.Value);\n    this.value[2] = this.setSlotInt(r, SlotName.ValueA);\n  }\n  resetValueMerklizedRoot() {\n    this._value[2] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  // GetMerklizedRoot returns merklized root from claim's index of value.\n  // Returns error ErrNoMerklizedRoot if MerklizedRoot is not set.\n  getMerklizedRoot(): bigint {\n    switch (this.getMerklized()) {\n      case MerklizedFlag.Index:\n        return this.index[2].toBigInt();\n      case MerklizedFlag.Value:\n        return this.value[2].toBigInt();\n      default:\n        throw Constants.ERRORS.NO_MERKLIZED_ROOT;\n    }\n  }\n\n  // resetId deletes Id from index and from value.\n  resetId(): void {\n    this.resetIndexId();\n    this.resetValueId();\n    this.setSubject(SubjectFlag.Self);\n  }\n  // GetId returns Id from claim's index of value.\n  // Returns error ErrNoId if Id is not set.\n  getId(): Id {\n    switch (this.getSubject()) {\n      case SubjectFlag.OtherIdenIndex:\n        return this.getIndexId();\n      case SubjectFlag.OtherIdenValue:\n        return this.getValueId();\n      default:\n        throw Constants.ERRORS.NO_ID;\n    }\n  }\n  // RawSlots returns raw bytes of claim's index and value\n  rawSlots(): { index: ElemBytes[]; value: ElemBytes[] } {\n    return {\n      index: this._index,\n      value: this._value\n    };\n  }\n  // RawSlotsAsInts returns slots as []bigint\n  rawSlotsAsInts(): bigint[] {\n    return [...ElemBytes.elemBytesToInts(this._index), ...ElemBytes.elemBytesToInts(this._value)];\n  }\n\n  clone(): Claim {\n    return JSON.parse(JSON.stringify(this));\n  }\n\n  marshalJson(): string[] {\n    return this.rawSlotsAsInts().map((b) => b.toString());\n  }\n\n  unMarshalJson(b: string): Claim {\n    const ints: bigint[] = JSON.parse(b).map((s: string) => BigInt(s));\n\n    if (ints.length !== this._index.length + this._value.length) {\n      throw new Error(\"invalid number of claim's slots\");\n    }\n    this._index = [];\n    this._value = [];\n    for (let i = 0, j = Constants.ELEM_BYTES_LENGTH; i < ints.length / 2; i++, j++) {\n      this._index[i] = new ElemBytes();\n      this._index[i].setBigInt(ints[i]);\n      this._value[i] = new ElemBytes();\n      this._value[i].setBigInt(ints[j]);\n    }\n    return this;\n  }\n\n  marshalBinary(): Uint8Array {\n    const getBytes = (src: ElemBytes[]) =>\n      src.reduce((acc: number[], cur: ElemBytes) => {\n        return [...acc, ...cur.bytes];\n      }, []);\n    return Uint8Array.from(getBytes(this._index).concat(getBytes(this._value)));\n  }\n\n  // Hex returns hex representation of binary claim\n  hex(): string {\n    const b = this.marshalBinary();\n    return Hex.encodeString(b);\n  }\n\n  fromHex(hex: string): Claim {\n    const b = Hex.decodeString(hex);\n    this.unMarshalBinary(b);\n    return this;\n  }\n\n  unMarshalBinary(data: Uint8Array): void {\n    const wantLen = 2 * Constants.ELEM_BYTES_LENGTH * Constants.BYTES_LENGTH;\n    if (data.length !== wantLen) {\n      throw new Error('unexpected length of input data');\n    }\n    this._index = [];\n    this._value = [];\n    for (let i = 0, j = Constants.ELEM_BYTES_LENGTH; i < Constants.ELEM_BYTES_LENGTH; i++, j++) {\n      this._index[i] = new ElemBytes(\n        data.slice(i * Constants.BYTES_LENGTH, (i + 1) * Constants.BYTES_LENGTH)\n      );\n      this._value[i] = new ElemBytes(\n        data.slice(j * Constants.BYTES_LENGTH, (j + 1) * Constants.BYTES_LENGTH)\n      );\n    }\n  }\n}\n\n// Option provides the ability to set different Claim's fields on construction\nexport type ClaimOption = (c: Claim) => void;\nexport class ClaimOptions {\n  // WithFlagUpdatable sets claim's flag `updatable`\n  static withFlagUpdatable(val: boolean): ClaimOption {\n    return (c: Claim) => c.setFlagUpdatable(val);\n  }\n\n  // WithVersion sets claim's version\n  static withVersion(ver: number): ClaimOption {\n    return (c: Claim) => c.setVersion(ver);\n  }\n\n  // WithIndexId sets Id to claim's index\n  static withIndexId(id: Id): ClaimOption {\n    return (c: Claim) => c.setIndexId(id);\n  }\n\n  // WithValueId sets Id to claim's value\n  static withValueId(id: Id): ClaimOption {\n    return (c: Claim) => c.setValueId(id);\n  }\n\n  // WithFlagMerklized sets claim's flag `merklized`\n  static withFlagMerklized(p: MerklizedRootPosition): ClaimOption {\n    return (c: Claim) => c.setFlagMerklized(p);\n  }\n\n  // WithId sets Id to claim's index or value depending on `pos`.\n  static withId(id: Id, pos: IdPosition): ClaimOption {\n    return (c: Claim) => {\n      switch (pos) {\n        case IdPosition.Index:\n          c.setIndexId(id);\n          break;\n        case IdPosition.Value:\n          c.setValueId(id);\n          break;\n        default:\n          throw Constants.ERRORS.INCORRECT_ID_POSITION;\n      }\n    };\n  }\n\n  // WithRevocationNonce sets claim's revocation nonce.\n  static withRevocationNonce(nonce: bigint): ClaimOption {\n    return (c: Claim) => c.setRevocationNonce(nonce);\n  }\n\n  // WithExpirationDate sets claim's expiration date to `dt`.\n  static withExpirationDate(dt: Date): ClaimOption {\n    return (c: Claim) => c.setExpirationDate(dt);\n  }\n\n  // WithIndexData sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexData(slotA: ElemBytes, slotB: ElemBytes): ClaimOption {\n    return (c: Claim) => c.setIndexData(slotA, slotB);\n  }\n\n  // WithIndexDataBytes sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexDataBytes(slotA: Uint8Array | null, slotB: Uint8Array | null): ClaimOption {\n    return (c: Claim) => c.setIndexDataBytes(slotA, slotB);\n  }\n\n  // WithIndexDataInts sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexDataInts(slotA: bigint | null, slotB: bigint | null): ClaimOption {\n    return (c: Claim) => c.setIndexDataInts(slotA, slotB);\n  }\n\n  // WithValueData sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueData(slotA: ElemBytes, slotB: ElemBytes): ClaimOption {\n    return (c: Claim) => c.setValueData(slotA, slotB);\n  }\n\n  // WithValueDataBytes sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueDataBytes(slotA: Uint8Array, slotB: Uint8Array): ClaimOption {\n    return (c: Claim) => c.setValueDataBytes(slotA, slotB);\n  }\n\n  // WithValueDataInts sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueDataInts(slotA: bigint | null, slotB: bigint | null): ClaimOption {\n    return (c: Claim) => c.setValueDataInts(slotA, slotB);\n  }\n\n  // WithIndexMerklizedRoot sets root to index i_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withIndexMerklizedRoot(r: bigint): ClaimOption {\n    return (c: Claim) => {\n      c.setFlagMerklized(MerklizedRootPosition.Index);\n      c.index[2] = c.setSlotInt(r, SlotName.IndexA);\n    };\n  }\n\n  // WithValueMerklizedRoot sets root to value v_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withValueMerklizedRoot(r: bigint): ClaimOption {\n    return (c: Claim) => {\n      c.setFlagMerklized(MerklizedRootPosition.Value);\n      c.value[2] = c.setSlotInt(r, SlotName.ValueA);\n    };\n  }\n\n  // WithMerklizedRoot sets root to value v_2 or index i_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withMerklizedRoot(r: bigint, pos: MerklizedRootPosition): ClaimOption {\n    return (c: Claim) => {\n      switch (pos) {\n        case MerklizedRootPosition.Index:\n          c.setFlagMerklized(MerklizedRootPosition.Index);\n          c.index[2] = c.setSlotInt(r, SlotName.IndexA);\n          break;\n        case MerklizedRootPosition.Value:\n          c.setFlagMerklized(MerklizedRootPosition.Value);\n          c.value[2] = c.setSlotInt(r, SlotName.ValueA);\n          break;\n        default:\n          throw Constants.ERRORS.INCORRECT_MERKLIZED_POSITION;\n      }\n    };\n  }\n}\n", "import { Constants, DidMethodByte, DidMethodNetwork } from '../constants';\n\n// DIDNetworkFlag is a structure to represent DID blockchain and network id\nexport class DIDNetworkFlag {\n  constructor(public readonly blockchain: string, public readonly networkId: string) {}\n\n  toString(): string {\n    return `${this.blockchain}:${this.networkId}`;\n  }\n\n  static fromString(s: string): DIDNetworkFlag {\n    const [blockchain, networkId] = s.split(':');\n    return new DIDNetworkFlag(blockchain.replace('_', ''), networkId.replace('_', ''));\n  }\n}\n\n// BuildDIDType builds bytes type from chain and network\nexport function buildDIDType(method: string, blockchain: string, network: string): Uint8Array {\n  const fb = DidMethodByte[method];\n  if (!fb) {\n    throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n  }\n  const methodFn = DidMethodNetwork[method];\n  if (!methodFn) {\n    throw Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;\n  }\n\n  const sb: number | undefined = methodFn[new DIDNetworkFlag(blockchain, network).toString()];\n\n  if (typeof sb !== 'number') {\n    throw new Error(\n      `blockchain ${blockchain.toString() ?? '-'} and network ${\n        network.toString() ?? '-'\n      } is not defined in core lib`\n    );\n  }\n\n  return Uint8Array.from([fb, sb]);\n}\n\n// FindNetworkIDForDIDMethodByValue finds network by byte value\nexport function findNetworkIDForDIDMethodByValue(method: string, byteNumber: number): string {\n  const methodMap = DidMethodNetwork[method];\n  if (!methodMap) {\n    throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n  }\n  for (const [key, value] of Object.entries(methodMap)) {\n    if (value === byteNumber) {\n      return DIDNetworkFlag.fromString(key).networkId;\n    }\n  }\n  throw Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;\n}\n\n// findBlockchainForDIDMethodByValue finds blockchain type by byte value\nexport function findBlockchainForDIDMethodByValue(method: string, byteNumber: number): string {\n  const methodMap = DidMethodNetwork[method];\n  if (!methodMap) {\n    throw new Error(\n      `${Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: did method ${method} is not defined in core lib`\n    );\n  }\n  for (const [key, value] of Object.entries(methodMap)) {\n    if (value === byteNumber) {\n      return DIDNetworkFlag.fromString(key).blockchain;\n    }\n  }\n  throw Constants.ERRORS.UNSUPPORTED_BLOCKCHAIN_FOR_DID;\n}\n\n// findDIDMethodByValue finds did method by its byte value\nexport function findDIDMethodByValue(byteNumber: number): string {\n  for (const [key, value] of Object.entries(DidMethodByte)) {\n    if (value === byteNumber) {\n      return key;\n    }\n  }\n  throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n}\n", "export class Param {\n  constructor(public name: string, public value: string) {}\n\n  toString(): string {\n    if (!this.name) {\n      return '';\n    }\n    if (!this.value) {\n      return this.name;\n    }\n    return `${this.name}=${this.value}`;\n  }\n}\n\nexport interface IDID {\n  method: string;\n  id: string;\n  idStrings: string[];\n  params: Param[];\n  path: string;\n  pathSegments: string[];\n  query: string;\n  fragment: string;\n}\n\nexport const initDIDParams: IDID = Object.freeze({\n  method: '',\n  id: '',\n  idStrings: [],\n  params: [],\n  path: '',\n  pathSegments: [],\n  query: '',\n  fragment: ''\n});\n", "import { IDID, Param, initDIDParams } from './types';\nimport { StringUtils } from '../utils';\n\n// a step in the parser state machine that returns the next step\ntype ParserStep = () => ParserStep | null;\n\nexport class Parser {\n  currentIndex = 0; // index in the input which the parser is currently processing:\n  out: IDID = { ...initDIDParams }; // the output DID that the parser will assemble as it steps through its state machine  // an error in the parser state machine\n\n  constructor(private readonly input: string) {}\n\n  checkLength(): ParserStep | null {\n    const inputLength = this.input.length;\n\n    if (inputLength < 7) {\n      throw new Error('input length is less than 7');\n    }\n\n    return this.parseScheme.bind(this);\n  }\n\n  // parseScheme is a parserStep that validates that the input begins with 'did:'\n  parseScheme(): ParserStep | null {\n    const currentIndex = 3; // 4 bytes in 'did:', i.e index 3\n    // the grammar requires `did:` prefix\n    if (this.input.slice(0, currentIndex + 1) !== 'did:') {\n      throw new Error(\"input does not begin with 'did:' prefix\");\n    }\n\n    this.currentIndex = currentIndex;\n    return this.parseMethod.bind(this);\n  }\n\n  parseMethod(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we got to the end of the input and didn't find a second ':'\n        throw new Error('input does not have a second `:` marking end of method name');\n      }\n\n      // read the input character at currentIndex\n      const char = input[currentIndex];\n\n      if (char === ':') {\n        // we've found the second : in the input that marks the end of the method\n        if (currentIndex === startIndex) {\n          // return error is method is empty, ex- did::1234\n          throw new Error(`method is empty, ${currentIndex}`);\n        }\n        break;\n      }\n\n      // as per the grammar method can only be made of digits 0-9 or small letters a-z\n      if (StringUtils.isNotDigit(char) && StringUtils.isNotSmallLetter(char)) {\n        throw new Error(`\"character is not a-z OR 0-9, ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + 1;\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n    this.out.method = input.slice(startIndex, currentIndex);\n\n    // method is followed by specific-idstring, parse that next\n    return this.parseId.bind(this);\n  }\n\n  parseId(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let next: ParserStep | null = null;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we've reached end of input, no next state\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === ':') {\n        // encountered : input may have another idstring, parse ID again\n        next = this.parseId;\n        break;\n      }\n\n      if (char === ';') {\n        // encountered ; input may have a parameter, parse that next\n        next = this.parseParamName;\n        break;\n      }\n\n      if (char === '/') {\n        // encountered / input may have a path following specific-idstring, parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following specific-idstring, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char === '#') {\n        // encountered # input may have a fragment following specific-idstring, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      // make sure current char is a valid idchar\n      // idchar = ALPHA / DIGIT / \".\" / \"-\"\n      if (StringUtils.isNotValidIDChar(char)) {\n        throw new Error(`byte is not ALPHA OR DIGIT OR '.' OR '-', ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + 1;\n    }\n\n    if (currentIndex === startIndex) {\n      // idstring length is zero\n      // from the grammar:\n      //   idstring = 1*idchar\n      // return error because idstring is empty, ex- did:a::123:456\n      throw new Error(`idstring must be at least one char long, ${currentIndex}`);\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n    this.out.idStrings = [...this.out.idStrings, input.slice(startIndex, currentIndex)];\n\n    // return the next parser step\n    return next ? next.bind(this) : null;\n  }\n\n  parseParamName(): ParserStep | null {\n    const input = this.input;\n    const startIndex = this.currentIndex + 1;\n    const next = this.paramTransition();\n    const currentIndex = this.currentIndex;\n\n    if (currentIndex === startIndex) {\n      throw new Error(`Param name must be at least one char long, ${currentIndex}`);\n    }\n\n    // Create a new param with the name\n    this.out.params = [...this.out.params, new Param(input.slice(startIndex, currentIndex), '')];\n\n    // return the next parser step\n    return next ? next.bind(this) : null;\n  }\n\n  parseParamValue(): ParserStep | null {\n    const input = this.input;\n    const startIndex = this.currentIndex + 1;\n    const next = this.paramTransition();\n    const currentIndex = this.currentIndex;\n    this.out.params[this.out.params.length - 1].value = input.slice(startIndex, currentIndex);\n    return next ? next.bind(this) : null;\n  }\n\n  paramTransition(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n\n    let indexIncrement: number;\n    let next: ParserStep | null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we've reached end of input, no next state\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === ';') {\n        // encountered : input may have another param, parse paramName again\n        next = this.parseParamName;\n        break;\n      }\n\n      // Separate steps for name and value?\n      if (char === '=') {\n        // parse param value\n        next = this.parseParamValue;\n        break;\n      }\n\n      if (char === '/') {\n        // encountered / input may have a path following current param, parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following current param, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char == '#') {\n        // encountered # input may have a fragment following current param, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      if (char == '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits', ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not percent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      // make sure current char is a valid param-char\n      // idchar = ALPHA / DIGIT / \".\" / \"-\"\n      if (!percentEncoded && StringUtils.isNotValidParamChar(char)) {\n        throw new Error(`character is not allowed in param - ${char}',  ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n\n    return next ? next.bind(this) : null;\n  }\n\n  parsePath(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let next: ParserStep | null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '/') {\n        // encountered / input may have another path segment, try to parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following path, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not percent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      // pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n      if (!percentEncoded && StringUtils.isNotValidPathChar(char)) {\n        throw new Error(`character is not allowed in path, ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    if (currentIndex == startIndex && this.out.pathSegments.length === 0) {\n      throw new Error(`first path segment must have at least one character, ${currentIndex}`);\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.pathSegments = [...this.out.pathSegments, input.slice(startIndex, currentIndex)];\n\n    return next ? next.bind(this) : null;\n  }\n\n  parseQuery(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let next: ParserStep | null = null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '#') {\n        // encountered # input may have a fragment following the query, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not percent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n      if (!percentEncoded && StringUtils.isNotValidQueryOrFragmentChar(char)) {\n        throw new Error(`character is not allowed in query - ${char}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.query = input.slice(startIndex, currentIndex);\n\n    return next ? next.bind(this) : null;\n  }\n\n  parseFragment(): ParserStep | null {\n    const input = this.input;\n    const inputLength = this.input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not percent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      if (!percentEncoded && StringUtils.isNotValidQueryOrFragmentChar(char)) {\n        throw new Error(`character is not allowed in fragment - ${char}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.fragment = input.slice(startIndex, currentIndex);\n\n    // no more parsing needed after a fragment,\n    // cause the state machine to exit by returning nil\n    return null;\n  }\n}\n", "import { Id } from '../id';\nimport {\n  Blockchain,\n  Constants,\n  DidMethodByte,\n  DidMethodNetwork,\n  DidMethod,\n  NetworkId\n} from '../constants';\nimport { BytesHelper } from '../elemBytes';\nimport {\n  DIDNetworkFlag,\n  findBlockchainForDIDMethodByValue,\n  findDIDMethodByValue,\n  findNetworkIDForDIDMethodByValue\n} from './did-helper';\nimport { Parser } from './did-parser';\nimport { IDID, Param } from './types';\nimport { sha256 } from '@iden3/js-crypto';\nimport { encoder } from '../utils';\n// DID Decentralized Identifiers (DIDs)\n// https://w3c.github.io/did-core/#did-syntax\n\nexport class DID {\n  method = '';\n  id = '';\n  idStrings: string[] = [];\n  params: Param[] = [];\n  path = '';\n  pathSegments: string[] = [];\n  query = '';\n  fragment = '';\n\n  constructor(d?: Partial<IDID>) {\n    if (d) {\n      Object.assign(this, d);\n    }\n  }\n\n  isUrl(): boolean {\n    return (\n      this.params.length > 0 ||\n      !!this.path ||\n      this.pathSegments.length > 0 ||\n      !!this.query ||\n      !!this.fragment\n    );\n  }\n\n  string(): string {\n    const buff = ['did:'];\n    if (this.method) {\n      buff.push(`${this.method}:`);\n    } else {\n      return '';\n    }\n\n    if (this.id) {\n      buff.push(this.id);\n    } else if (this.idStrings.length) {\n      buff.push(this.idStrings.join(':'));\n    } else {\n      return '';\n    }\n\n    if (this.params.length) {\n      for (const param of this.params) {\n        const p = param.toString();\n        if (p) {\n          buff.push(`;${p}`);\n        } else {\n          return '';\n        }\n      }\n    }\n\n    if (this.path) {\n      buff.push(`/${this.path}`);\n    } else if (this.pathSegments.length) {\n      buff.push(`/${this.pathSegments.join('/')}`);\n    }\n\n    if (this.query) {\n      buff.push(`?${this.query}`);\n    }\n\n    if (this.fragment) {\n      buff.push(`#${this.fragment}`);\n    }\n\n    return buff.join('');\n  }\n\n  toJSON() {\n    return this.string();\n  }\n\n  static parse(s: string): DID {\n    const parser = new Parser(s);\n\n    let parserState = parser.checkLength();\n\n    while (parserState) {\n      parserState = parserState();\n    }\n\n    parser.out.id = parser.out.idStrings.join(':');\n    parser.out.path = parser.out.pathSegments.join('/');\n\n    return new DID(parser.out);\n  }\n\n  static decodePartsFromId(id: Id): {\n    method: string;\n    blockchain: string;\n    networkId: string;\n  } {\n    const method = findDIDMethodByValue(id.bytes[0]);\n    const blockchain = findBlockchainForDIDMethodByValue(method, id.bytes[1]);\n\n    const networkId = findNetworkIDForDIDMethodByValue(method, id.bytes[1]);\n\n    return { method, blockchain, networkId };\n  }\n\n  static networkIdFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).networkId;\n  }\n\n  static methodFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).method;\n  }\n\n  static blockchainFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).blockchain;\n  }\n\n  private static throwIfDIDUnsupported(id: Id): {\n    method: string;\n    blockchain: string;\n    networkId: string;\n  } {\n    const { method, blockchain, networkId } = DID.decodePartsFromId(id);\n\n    if (DID.isUnsupported(method, blockchain, networkId)) {\n      throw new Error(`${Constants.ERRORS.UNKNOWN_DID_METHOD.message}: unsupported DID`);\n    }\n\n    return { method, blockchain, networkId };\n  }\n\n  // DIDGenesisFromIdenState calculates the genesis ID from an Identity State and returns it as DID\n  static newFromIdenState(typ: Uint8Array, state: bigint): DID {\n    const id = Id.idGenesisFromIdenState(typ, state);\n\n    return DID.parseFromId(id);\n  }\n\n  // NewDID creates a new *w3c.DID from the type and the genesis\n  static new(typ: Uint8Array, genesis: Uint8Array): DID {\n    return DID.parseFromId(new Id(typ, genesis));\n  }\n\n  // ParseDIDFromID returns DID from ID\n  static parseFromId(id: Id): DID {\n    if (!BytesHelper.checkChecksum(id.bytes)) {\n      throw new Error(`${Constants.ERRORS.UNSUPPORTED_ID.message}: invalid checksum`);\n    }\n    const { method, blockchain, networkId } = DID.throwIfDIDUnsupported(id);\n\n    const didParts = [Constants.DID.DID_SCHEMA, method.toString(), blockchain.toString()];\n    if (networkId) {\n      didParts.push(networkId.toString());\n    }\n    didParts.push(id.string());\n\n    const didString = didParts.join(':');\n\n    const did = DID.parse(didString);\n\n    return did;\n  }\n\n  static idFromDID(did: DID): Id {\n    let id: Id;\n    try {\n      id = DID.getIdFromDID(did);\n    } catch (error) {\n      if ((error as Error).message === Constants.ERRORS.UNKNOWN_DID_METHOD.message) {\n        return DID.idFromUnsupportedDID(did);\n      }\n      throw error;\n    }\n\n    return id;\n  }\n\n  static isUnsupported(method: string, blockchain: string, networkId: string): boolean {\n    return (\n      method == DidMethod.Other &&\n      blockchain == Blockchain.Unknown &&\n      networkId == NetworkId.Unknown\n    );\n  }\n\n  static idFromUnsupportedDID(did: DID): Id {\n    const hash = sha256(encoder.encode(did.string()));\n\n    const genesis = new Uint8Array(27);\n    const idSlice = hash.slice(hash.length - Constants.GENESIS_LENGTH);\n    for (let i = 0; i < genesis.length; i++) {\n      genesis[i] = idSlice[i] ?? 0;\n    }\n    const flg = new DIDNetworkFlag(Blockchain.Unknown, NetworkId.Unknown);\n    const tp = Uint8Array.from([\n      DidMethodByte[DidMethod.Other],\n      DidMethodNetwork[DidMethod.Other][flg.toString()]\n    ]);\n    return new Id(tp, genesis);\n  }\n\n  private static getIdFromDID(did: DID): Id {\n    const method = did.method;\n    const methodByte = DidMethodByte[method];\n    if (!methodByte || method === DidMethod.Other) {\n      throw Constants.ERRORS.UNKNOWN_DID_METHOD;\n    }\n\n    if (did.idStrings.length > 3 || did.idStrings.length < 2) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: unexpected number of ID strings`);\n    }\n\n    const id = Id.fromString(did.idStrings[did.idStrings.length - 1]);\n\n    if (!BytesHelper.checkChecksum(id.bytes)) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: incorrect ID checksum`);\n    }\n\n    const { method: method2, blockchain, networkId } = DID.decodePartsFromId(id);\n\n    if (method2.toString() !== method.toString()) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: methods in Id and DID are different`);\n    }\n\n    if (blockchain.toString() !== did.idStrings[0]) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: blockchains in ID and DID are different`);\n    }\n\n    if (did.idStrings.length > 2 && networkId.toString() != did.idStrings[1]) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: networkIDs in Id and DID are different`);\n    }\n\n    return id;\n  }\n}\n", "import {\n  Blockchain,\n  ChainIds,\n  DidMethod,\n  DidMethodByte,\n  DidMethodNetwork,\n  NetworkId\n} from './constants';\nimport { DID } from './did';\n\nexport const registerBlockchain = (blockchain: string): void => {\n  Blockchain[blockchain] = blockchain;\n};\n\nexport const registerNetwork = (network: string): void => {\n  NetworkId[network] = network;\n};\n\nexport const registerDidMethod = (method: string, byte: number): void => {\n  const max = DidMethodByte[DidMethod.Other];\n\n  if (byte >= max) {\n    throw new Error(\n      `Can't register DID method byte: current '${byte.toString(2)}', maximum byte allowed: '${(\n        max - 1\n      ).toString(2)}'`\n    );\n  }\n\n  if (typeof DidMethodByte[method] === 'number' && DidMethodByte[method] === byte) {\n    return;\n  }\n\n  if (Object.values(DidMethodByte).includes(byte)) {\n    throw new Error(\n      `can't register method '${method}' because DID method byte '${byte.toString(\n        2\n      )}' already registered for another method`\n    );\n  }\n\n  DidMethod[method] = method;\n  DidMethodByte[method] = byte;\n};\n\n/**\n * Register chain ID for a blockchain and network.\n *\n * @param {string} blockchain\n * @param {string} network\n * @param {number} [chainId]\n * @returns {void}\n */\nexport const registerChainId = (blockchain: string, network: string, chainId: number): void => {\n  const key = `${blockchain}:${network}`;\n\n  if (typeof ChainIds[key] === 'number' && ChainIds[key] === chainId) {\n    return;\n  }\n\n  if (Object.values(ChainIds).includes(chainId)) {\n    throw new Error(\n      `can't register chainId ${chainId} for '${blockchain}:${network}' because it's already registered for another chain id`\n    );\n  }\n\n  ChainIds[key] = chainId;\n};\n\n/**\n * Get chain ID by a blockchain and network.\n *\n * @param {string} blockchain\n * @param {string} [network]\n * @returns {number}\n */\nexport const getChainId = (blockchain: string, network?: string): number => {\n  if (network) {\n    blockchain += `:${network}`;\n  }\n  const chainId = ChainIds[blockchain];\n  if (!chainId) {\n    throw new Error(`chainId not found for ${blockchain}`);\n  }\n  return chainId;\n};\n\n/**\n * ChainIDfromDID returns chain name from w3c.DID\n *\n * @param {DID} did\n * @returns {number}\n */\nexport const chainIDfromDID = (did: DID): number => {\n  const id = DID.idFromDID(did);\n\n  const blockchain = DID.blockchainFromId(id);\n\n  const networkId = DID.networkIdFromId(id);\n\n  const chainId = ChainIds[`${blockchain}:${networkId}`];\n  if (typeof chainId !== 'number') {\n    throw new Error(`chainId not found for ${blockchain}:${networkId}`);\n  }\n\n  return chainId;\n};\n\n/**\n * Register a DID method with a byte value.\n * https://docs.iden3.io/getting-started/identity/identity-types/#regular-identity\n * @param {{\n *   method: DidMethodName;  DID method name\n *   methodByte?: number; put DID method byte value in case you want to register new DID method\n *   blockchain: BlockchainName;  blockchain name\n *   network: NetworkName;  network name\n *   networkFlag: number;  network flag\n *   chainId?: number;  put  chain ID in case you need to use it\n * }} {\n *   method,\n *   methodByte,\n *   blockchain,\n *   network,\n *   chainId,\n *   networkFlag\n * }\n */\nexport const registerDidMethodNetwork = ({\n  method,\n  methodByte,\n  blockchain,\n  network,\n  chainId,\n  networkFlag\n}: {\n  method: string;\n  methodByte?: number;\n  blockchain: string;\n  network: string;\n  networkFlag: number;\n  chainId?: number;\n}): void => {\n  registerBlockchain(blockchain);\n  registerNetwork(network);\n  if (typeof methodByte === 'number') {\n    registerDidMethod(method, methodByte);\n  }\n\n  if (!DidMethodNetwork[method]) {\n    DidMethodNetwork[method] = {};\n  }\n\n  if (typeof chainId === 'number') {\n    registerChainId(blockchain, network, chainId);\n  }\n\n  const key = `${blockchain}:${network}`;\n\n  const existedFlag = DidMethodNetwork[method][key];\n  if (typeof existedFlag === 'number' && existedFlag === networkFlag) {\n    return;\n  }\n\n  if (Object.values(DidMethodNetwork[method]).includes(networkFlag)) {\n    throw new Error(\n      `DID network flag ${networkFlag.toString(\n        2\n      )} is already registered for the another network id for '${method}' method`\n    );\n  }\n\n  DidMethodNetwork[method][key] = networkFlag;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAA,oBAAoB;;;ACAb,IAAM,YAAY,OAAO,OAAO;AAAA,EACrC,QAAQ;AAAA;AAAA;AAAA;AAAA,IAIN,eAAe,IAAI,MAAM,+BAA+B;AAAA;AAAA;AAAA,IAGxD,uBAAuB,IAAI,MAAM,uBAAuB;AAAA;AAAA,IAExD,OAAO,IAAI,MAAM,eAAe;AAAA;AAAA,IAEhC,0BAA0B,IAAI,MAAM,0BAA0B;AAAA;AAAA;AAAA,IAG9D,8BAA8B,IAAI,MAAM,6BAA6B;AAAA;AAAA,IAErE,mBAAmB,IAAI,MAAM,2BAA2B;AAAA,IACxD,+BAA+B,IAAI,MAAM,kCAAkC;AAAA,IAC3E,gCAAgC,IAAI,MAAM,kCAAkC;AAAA,IAC5E,wBAAwB,IAAI,MAAM,0BAA0B;AAAA,IAC5D,oBAAoB,IAAI,MAAM,oBAAoB;AAAA,IAClD,eAAe,IAAI,MAAM,eAAe;AAAA,IACxC,gBAAgB,IAAI,MAAM,gBAAgB;AAAA,EAC5C;AAAA,EACA,QAAQ;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA,oBAAoB;AAAA,EACpB,cAAc;AAAA,EACd,mBAAmB;AAAA,EACnB,oBAAoB;AAAA,EACpB,GAAG,OAAO,+EAA+E;AAAA,EACzF,IAAI;AAAA,IACF,cAAc,WAAW,KAAK,CAAC,GAAM,CAAI,CAAC;AAAA,IAC1C,eAAe,WAAW,KAAK,CAAC,GAAY,CAAU,CAAC;AAAA,IACvD,WAAW;AAAA,EACb;AAAA,EACA,KAAK;AAAA,IACH,YAAY;AAAA,EACd;AAAA,EACA,gBAAgB;AAClB,CAAC;AAEM,IAAM,aAAsC;AAAA,EACjD,UAAU;AAAA,EACV,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AACZ;AAEO,IAAM,YAAqC;AAAA,EAChD,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,SAAS;AAAA,EACT,WAAW;AACb;AAEO,IAAM,YAAqC;AAAA,EAChD,OAAO;AAAA,EACP,WAAW;AAAA,EACX,OAAO;AACT;AAMO,IAAM,WAAsC;AAAA,EACjD,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC9C,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,MAAM,EAAE,GAAG;AAAA,EAChD,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,OAAO,EAAE,GAAG;AAAA,EACjD,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC7C,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,MAAM,EAAE,GAAG;AAAA,EAC/C,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC7C,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,KAAK,EAAE,GAAG;AAAA,EAC9C,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,OAAO,EAAE,GAAG;AAAA,EAChD,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC7C,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC7C,CAAC,GAAG,WAAW,KAAK,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC3C,CAAC,GAAG,WAAW,KAAK,IAAI,UAAU,OAAO,EAAE,GAAG;AAAA,EAC9C,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG;AAAA,EAC9C,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG;AAChD;AAEO,IAAM,gBAA2C;AAAA,EACtD,CAAC,UAAU,KAAK,GAAG;AAAA,EACnB,CAAC,UAAU,SAAS,GAAG;AAAA,EACvB,CAAC,UAAU,KAAK,GAAG;AACrB;AAEA,IAAM,uBAAuB;AAAA,EAC3B,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,SAAS,EAAE,GAAG;AAAA,EACnD,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG,KAAc;AAAA,EAC3D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,MAAM,EAAE,GAAG,KAAc;AAAA,EAC7D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG,KAAc;AAAA,EAC3D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,KAAK,EAAE,GAAG,KAAc;AAAA,EAC5D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,OAAO,EAAE,GAAG,KAAc;AAAA,EAC9D,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG,KAAc;AAAA,EAC5D,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,MAAM,EAAE,GAAG,KAAc;AAAA,EAC9D,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,OAAO,EAAE,GAAG,KAAc;AAAA,EAC/D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG,MAAc;AAAA,EAC3D,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,IAAI,EAAE,GAAG,MAAc;AAAA,EAC3D,CAAC,GAAG,WAAW,KAAK,IAAI,UAAU,IAAI,EAAE,GAAG,KAAc;AAAA,EACzD,CAAC,GAAG,WAAW,KAAK,IAAI,UAAU,OAAO,EAAE,GAAG,KAAc;AAAA,EAC5D,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG,MAAc;AAAA,EAC5D,CAAC,GAAG,WAAW,QAAQ,IAAI,UAAU,IAAI,EAAE,GAAG,MAAc;AAC9D;AAGO,IAAM,mBAET;AAAA,EACF,CAAC,UAAU,KAAK,GAAG;AAAA,IACjB,GAAG;AAAA,EACL;AAAA,EACA,CAAC,UAAU,SAAS,GAAG;AAAA,IACrB,GAAG;AAAA,EACL;AAAA,EACA,CAAC,UAAU,KAAK,GAAG;AAAA,IACjB,CAAC,GAAG,WAAW,OAAO,IAAI,UAAU,OAAO,EAAE,GAAG;AAAA,EAClD;AACF;;;ACpIA,uBAAyB;AAGlB,IAAM,UAAU,IAAI,YAAY;AAEhC,SAAS,iBAAiB,OAA2B;AAC1D,QAAM,OAAO,OAAO,GAAG;AACvB,MAAI,SAAS,OAAO,CAAC;AACrB,MAAI,OAAO,OAAO,CAAC;AACnB,QAAM,QAAQ,CAAC,SAAS;AACtB,cAAU,OAAO,OAAO,IAAI;AAC5B,WAAO,OAAO;AAAA,EAChB,CAAC;AACD,SAAO;AACT;AAEO,SAAS,cAAc,OAA2B;AACvD,SAAO,iBAAiB,MAAM,QAAQ,CAAC;AACzC;AAEO,SAAS,eAAe,WAAmB,MAAM,IAAgB;AACtE,QAAM,OAAO,OAAO,GAAG;AACvB,QAAM,SAAS,IAAI,WAAW,GAAG;AACjC,MAAI,IAAI;AACR,SAAO,YAAY,OAAO,CAAC,GAAG;AAC5B,WAAO,CAAC,IAAI,OAAO,YAAY,IAAI;AACnC,gBAAY,YAAY;AACxB,SAAK;AAAA,EACP;AACA,SAAO;AACT;AAEO,SAAS,YAAY,WAAmB,MAAM,IAAgB;AACnE,SAAO,eAAe,WAAW,GAAG,EAAE,QAAQ;AAChD;AAEO,SAAS,UAAU,GAAuB;AAC/C,QAAM,MAAM,IAAI,YAAY,CAAC;AAC7B,QAAM,OAAO,IAAI,SAAS,GAAG;AAC7B,OAAK,UAAU,GAAG,GAAG,IAAI;AACzB,SAAO,IAAI,WAAW,GAAG;AAC3B;AAEO,SAAS,UAAU,KAAyB;AACjD,QAAM,MAAM,IAAI,OAAO,MAAM,IAAI,YAAY,IAAI,aAAa,IAAI,UAAU;AAC5E,SAAO,IAAI,SAAS,GAAG,EAAE,UAAU,GAAG,IAAI;AAC5C;AAEO,SAAS,UAAU,GAAuB;AAC/C,QAAM,MAAM,IAAI,YAAY,CAAC;AAC7B,QAAM,OAAO,IAAI,SAAS,GAAG;AAC7B,OAAK,aAAa,GAAG,GAAG,IAAI;AAC5B,SAAO,IAAI,WAAW,GAAG;AAC3B;AAEO,SAAS,UAAU,KAAyB;AACjD,QAAM,MAAM,IAAI,OAAO,MAAM,IAAI,YAAY,IAAI,aAAa,IAAI,UAAU;AAC5E,SAAO,IAAI,SAAS,GAAG,EAAE,aAAa,GAAG,IAAI;AAC/C;AAEO,SAAS,iBAAiB,GAAiB;AAChD,SAAO,KAAK,MAAM,EAAE,QAAQ,IAAI,GAAI;AACtC;AACO,SAAS,yBAAyB,GAAiB;AACxD,SAAO,IAAI,KAAK,IAAI,GAAI;AAC1B;AAGO,SAAS,mBAAmB,GAAoB;AACrD,SAAO,IAAI,UAAU;AACvB;AAEO,SAAS,wBAAwB,KAAwB;AAC9D,SAAO,IAAI,MAAM,CAAC,MAAM,mBAAmB,CAAC,CAAC;AAC/C;AAIO,SAAS,UAAU,KAAa,KAAa,KAAqB;AACvE,SAAO,0BAAS,KAAK,CAAC,KAAK,KAAK,GAAG,CAAC;AACtC;AAEO,IAAM,cAAN,MAAM,aAAY;AAAA,EACvB,OAAO,iBAAiB,MAAuB;AAC7C,WACE,aAAY,WAAW,IAAI,KAAK,aAAY,WAAW,IAAI,KAAK,SAAS,OAAO,SAAS;AAAA,EAE7F;AAAA,EAEA,OAAO,oBAAoB,MAAuB;AAChD,WACE,aAAY,WAAW,IAAI,KAC3B,aAAY,WAAW,IAAI,KAC3B,SAAS,OACT,SAAS,OACT,SAAS,OACT,SAAS;AAAA,EAEb;AAAA,EAEA,OAAO,8BAA8B,MAAuB;AAC1D,WAAO,aAAY,mBAAmB,IAAI,KAAK,SAAS,OAAO,SAAS;AAAA,EAC1E;AAAA,EAEA,OAAO,mBAAmB,MAAuB;AAC/C,WAAO,aAAY,0BAA0B,IAAI,KAAK,SAAS,OAAO,SAAS;AAAA,EACjF;AAAA,EAEA,OAAO,0BAA0B,MAAuB;AACtD,YAAQ,MAAM;AAAA,MACZ,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,eAAO;AAAA,MACT;AACE,YAAI,aAAY,WAAW,IAAI,KAAK,aAAY,WAAW,IAAI,GAAG;AAChE,iBAAO;AAAA,QACT;AACA,eAAO;AAAA,IACX;AAAA,EACF;AAAA,EAEA,OAAO,cAAc,MAAuB;AAC1C,WACE,aAAY,WAAW,IAAI,MAC1B,OAAO,OAAU,OAAO,SACxB,OAAO,OAAU,OAAO;AAAA,EAE7B;AAAA,EAEA,OAAO,WAAW,MAAuB;AAEvC,WAAO,OAAO,OAAU,OAAO;AAAA,EACjC;AAAA;AAAA;AAAA,EAIA,OAAO,WAAW,MAAuB;AACvC,WAAO,aAAY,iBAAiB,IAAI,KAAK,aAAY,eAAe,IAAI;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,eAAe,MAAuB;AAE3C,WAAO,OAAO,OAAU,OAAO;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,iBAAiB,MAAuB;AAE7C,WAAO,OAAO,OAAU,OAAO;AAAA,EACjC;AACF;AAEO,IAAM,wBAAwB,CAAC,SAAqB;AACzD,SAAO,WAAW,KAAK,CAAC,GAAG,IAAI,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC;AACxD;;;AC1KA,IAAAC,oBAA4B;AACrB,IAAM,cAAN,MAAM,aAAY;AAAA,EACvB,OAAO,WAAW,KAAyB;AACzC,WAAO,aAAY,YAAY,KAAK,UAAU,YAAY;AAAA,EAC5D;AAAA,EAEA,OAAO,YAAY,KAAa,GAAuB;AACrD,WAAO,WAAW,KAAK,eAAe,KAAK,CAAC,CAAC;AAAA,EAC/C;AAAA,EAEA,OAAO,cAAc,OAA4B;AAC/C,UAAM,EAAE,KAAK,SAAS,SAAS,IAAI,aAAY,eAAe,KAAK;AACnE,QAAI,CAAC,SAAS,UAAU,KAAK,UAAU,WAAW,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,KAAK,UAAU,QAAQ,GAAG;AAC5F,aAAO;AAAA,IACT;AAEA,UAAM,IAAI,aAAY,kBAAkB,KAAK,OAAO;AACpD,WAAO,KAAK,UAAU,CAAC,MAAM,KAAK,UAAU,QAAQ;AAAA,EACtD;AAAA,EAEA,OAAO,eAAe,GAIpB;AACA,UAAM,SAAS;AACf,UAAM,MAAM,EAAE,SAAS;AACvB,WAAO;AAAA,MACL,KAAK,EAAE,MAAM,GAAG,MAAM;AAAA,MACtB,SAAS,EAAE,MAAM,QAAQ,GAAG;AAAA,MAC5B,UAAU,EAAE,MAAM,CAAC,MAAM;AAAA,IAC3B;AAAA,EACF;AAAA,EAEA,OAAO,kBAAkB,KAAiB,SAAiC;AACzE,UAAM,aAAa,CAAC,GAAG,KAAK,GAAG,OAAO;AACtC,UAAM,IAAY,WAAW,OAAO,CAAC,KAAK,QAAQ,MAAM,KAAK,CAAC;AAC9D,UAAM,WAAW,CAAC,KAAK,GAAG,IAAI,GAAI;AAClC,WAAO,WAAW,KAAK,SAAS,QAAQ,CAAC;AAAA,EAC3C;AAAA,EAEA,OAAO,UAAU,KAAyB;AACxC,UAAM,WAAO,0BAAO,QAAQ,OAAO,GAAG,CAAC;AACvC,WAAO,IAAI,WAAW,IAAI;AAAA,EAC5B;AAAA,EAEA,OAAO,WAAW,KAAyB;AACzC,WAAO,sBAAI,aAAa,GAAG;AAAA,EAC7B;AAAA,EAEA,OAAO,WAAW,OAAmB;AACnC,UAAM,MAAgB,CAAC;AACvB,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAM,UAAU,MAAM,CAAC,IAAI,IAAI,MAAM,CAAC,IAAI,MAAM,MAAM,CAAC;AACvD,UAAI,MAAM,YAAY,GAAG,SAAS,EAAE,CAAC;AACrC,UAAI,MAAM,UAAU,IAAK,SAAS,EAAE,CAAC;AAAA,IACvC;AACA,WAAO,IAAI,KAAK,EAAE;AAAA,EACpB;AAAA,EAEA,OAAO,WAAW,OAA2B;AAC3C,WAAO,iBAAiB,KAAK;AAAA,EAC/B;AACF;AAEO,IAAM,YAAN,MAAM,WAAU;AAAA,EACb,SAAS,IAAI,WAAW,UAAU,YAAY;AAAA,EAEtD,YAAY,OAA2B;AACrC,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB;AACA,QAAI,KAAK,OAAO,WAAW,UAAU,cAAc;AACjD,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AAAA,EACF;AAAA,EAEA,IAAI,QAAoB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAmB;AAC3B,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,WAAmB;AACjB,WAAO,YAAY,WAAW,KAAK,MAAM;AAAA,EAC3C;AAAA,EAEA,UAAU,GAAsB;AAC9B,QAAI,CAAC,mBAAmB,CAAC,GAAG;AAC1B,YAAM,UAAU,OAAO;AAAA,IACzB;AACA,SAAK,SAAS,YAAY,WAAW,CAAC;AACtC,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,KAAwB;AAClC,UAAM,QAAQ,sBAAI,aAAa,GAAG;AAClC,QAAI,MAAM,WAAW,UAAU,cAAc;AAC3C,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AACA,SAAK,OAAO,IAAI,OAAO,CAAC;AACxB,WAAO;AAAA,EACT;AAAA,EAEA,MAAc;AACZ,WAAO,sBAAI,aAAa,KAAK,MAAM;AAAA,EACrC;AAAA;AAAA,EAGA,OAAO,gBAAgB,UAAiC;AACtD,UAAM,SAAmB,CAAC;AAE1B,aAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,YAAM,UAAU,SAAS,CAAC;AAC1B,aAAO,KAAK,QAAQ,SAAS,CAAC;AAAA,IAChC;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,QAAQ,GAAsB;AACnC,QAAI,CAAC,mBAAmB,CAAC,GAAG;AAC1B,YAAM,UAAU,OAAO;AAAA,IACzB;AACA,UAAM,QAAQ,YAAY,WAAW,CAAC;AACtC,WAAO,IAAI,WAAU,KAAK;AAAA,EAC5B;AACF;;;AH/HO,IAAM,aAAN,MAAM,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMtB,OAAgB,iBAAiB,IAAI;AAAA,IACnC,WAAW,KAAK,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,IAAI,GAAG,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,EAAE,CAAC;AAAA,EACxF;AAAA,EAEQ,SAAqB,IAAI,WAAW,UAAU,OAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKxE,YAAY,OAAoB;AAC9B,QAAI,OAAO;AACT,WAAK,SAAS;AAAA,IAChB;AACA,QAAI,KAAK,MAAM,WAAW,UAAU,OAAO,aAAa;AACtD,YAAM,IAAI,MAAM,uBAAuB,UAAU,OAAO,WAAW,aAAa;AAAA,IAClF;AAAA,EACF;AAAA,EAEA,IAAI,QAAoB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAA+B;AAC7B,WAAO,sBAAI,OAAO,KAAK,KAAK;AAAA,EAC9B;AAAA,EAEA,cAAsB;AACpB,WAAO,sBAAI,aAAa,KAAK,KAAK;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,qBAAqB,GAAuB;AACjD,UAAM,qBAAqB,sBAAI,aAAa,CAAC;AAE7C,QAAI,mBAAmB,WAAW,UAAU,OAAO,aAAa;AAC9D,YAAM,IAAI,MAAM,+BAA+B,mBAAmB,MAAM,EAAE;AAAA,IAC5E;AAEA,WAAO,IAAI,YAAW,kBAAkB;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,qBAAqB,GAAuB;AACjD,UAAM,QAAQ,YAAY,YAAY,GAAG,UAAU,OAAO,WAAW;AACrE,UAAM,QAAQ,UAAU,OAAO,cAAc,MAAM;AACnD,WAAO,IAAI,YAAW,YAAY,WAAW,CAAC,EAAE,MAAM,OAAO,UAAU,OAAO,WAAW,CAAC;AAAA,EAC5F;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAiB;AACf,WAAO,YAAY,WAAW,KAAK,KAAK;AAAA,EAC1C;AACF;;;AI1EA,IAAAC,oBAAyD;AAOlD,IAAM,KAAN,MAAM,IAAG;AAAA,EACN;AAAA,EACS;AAAA,EAEjB,YAAY,KAAiB,SAAqB;AAChD,SAAK,YAAY,YAAY,kBAAkB,KAAK,OAAO;AAC3D,SAAK,SAAS,WAAW,KAAK,CAAC,GAAG,KAAK,GAAG,SAAS,GAAG,KAAK,SAAS,CAAC;AAAA,EACvE;AAAA,EAEA,OAAe,aAAa,OAAuB;AACjD,UAAM,EAAE,KAAK,QAAQ,IACnB,YAAY,eAAe,KAAK;AAClC,WAAO,IAAI,IAAG,KAAK,OAAO;AAAA,EAC5B;AAAA,EAEA,WAAuB;AACrB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,SAAiB;AACf,eAAO,mCAAgB,KAAK,MAAM;AAAA,EACpC;AAAA,EAEA,IAAI,QAAoB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,GAAe;AACvB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,OAAmB;AACjB,WAAO,KAAK,OAAO,MAAM,GAAG,CAAC;AAAA,EAC/B;AAAA,EAEA,SAAiB;AACf,WAAO,iBAAiB,KAAK,MAAM;AAAA,EACrC;AAAA,EAEA,MAAM,IAAiB;AACrB,WAAO,KAAK,UAAU,KAAK,MAAM,MAAM,KAAK,UAAU,GAAG,KAAK;AAAA,EAChE;AAAA,EAEA,UAAsB;AACpB,WAAO,IAAI,YAAY,EAAE,OAAO,KAAK,OAAO,CAAC;AAAA,EAC/C;AAAA,EAEA,OAAO,UAAU,GAAmB;AAClC,WAAO,IAAG,WAAW,IAAI,YAAY,EAAE,OAAO,CAAC,CAAC;AAAA,EAClD;AAAA,EAEA,OAAO,UAAU,GAAmB;AAClC,UAAM,QAAQ,KAAK,WAAW,KAAK,CAAC,CAAC;AACrC,QAAI,MAAM,WAAW,UAAU,GAAG,WAAW;AAC3C,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AAEA,QAAI,MAAM,MAAM,CAAC,MAAc,MAAM,CAAC,GAAG;AACvC,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AAEA,UAAM,KAAK,IAAG,aAAa,KAAK;AAEhC,QAAI,CAAC,YAAY,cAAc,KAAK,GAAG;AACrC,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,WAAW,GAAe;AAC/B,UAAM,YAAQ,iCAAc,CAAC;AAC7B,WAAO,IAAG,UAAU,KAAK;AAAA,EAC3B;AAAA,EAEA,OAAO,WAAW,QAAoB;AACpC,UAAM,IAAI,YAAY,YAAY,QAAQ,UAAU,GAAG,SAAS;AAChE,WAAO,IAAG,UAAU,CAAC;AAAA,EACvB;AAAA,EAEA,OAAO,UAAU,IAAQ,OAAmB;AAC1C,UAAM,aAAa,2BAAS,KAAK,CAAC,GAAG,OAAO,GAAG,KAAK,CAAC;AACrD,UAAM,EAAE,IAAI,IAAI,YAAY,eAAe,GAAG,KAAK;AACnD,UAAM,UAAU,YAAY,YAAY,YAAY,EAAE;AACtD,WAAO,IAAI,IAAG,KAAK,OAAO;AAAA,EAC5B;AAAA;AAAA,EAGA,OAAO,uBACL,KACA,OACI;AACJ,UAAM,gBAAgB,UAAU,QAAQ,KAAK;AAG7C,UAAM,iBAAiB,cAAc,MAAM,MAAM,cAAc,MAAM,SAAS,EAAE;AAChF,WAAO,IAAI,IAAG,KAAK,cAAc;AAAA,EACnC;AAAA,EAEA,OAAO,iBAAiB,IAAoB;AAC1C,UAAM,UAAU,GAAG,MAAM,MAAM,GAAG,IAAI,CAAC,EAAE,MAAM,CAAC,MAAc,MAAM,CAAC;AACrE,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,gEAAgE;AAAA,IAClF;AACA,WAAO,GAAG,MAAM,MAAM,IAAI,CAAC,EAAE,MAAM,GAAG,UAAU,kBAAkB;AAAA,EACpE;AACF;;;ACtGA,IAAAC,oBAA8B;AAsCvB,IAAK,WAAL,kBAAKC,cAAL;AACL,EAAAA,UAAA,YAAS;AACT,EAAAA,UAAA,YAAS;AACT,EAAAA,UAAA,YAAS;AACT,EAAAA,UAAA,YAAS;AAJC,SAAAA;AAAA,GAAA;AASL,IAAM,kBAAN,MAAM,yBAAwB,MAAM;AAAA,EACzC,YAAY,KAAa;AACvB,UAAM,QAAQ,GAAG,2BAA2B;AAC5C,WAAO,eAAe,MAAM,iBAAgB,SAAS;AAAA,EACvD;AACF;AAOO,IAAK,cAAL,kBAAKC,iBAAL;AACL,EAAAA,0BAAA,UAAO,KAAP;AACA,EAAAA,0BAAA,aAAU,KAAV;AACA,EAAAA,0BAAA,oBAAiB,KAAjB;AACA,EAAAA,0BAAA,oBAAiB,KAAjB;AAJU,SAAAA;AAAA,GAAA;AAOL,IAAK,aAAL,kBAAKC,gBAAL;AACL,EAAAA,wBAAA,UAAO,KAAP;AACA,EAAAA,wBAAA,WAAQ,KAAR;AACA,EAAAA,wBAAA,WAAQ,KAAR;AAHU,SAAAA;AAAA,GAAA;AAWL,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,8BAAA,UAAO,KAAP;AACA,EAAAA,8BAAA,WAAQ,MAAR;AACA,EAAAA,8BAAA,WAAQ,MAAR;AACA,EAAAA,8BAAA,aAAU,OAAV;AAJU,SAAAA;AAAA,GAAA;AAOL,IAAK,wBAAL,kBAAKC,2BAAL;AACL,EAAAA,8CAAA,UAAO,KAAP;AACA,EAAAA,8CAAA,WAAQ,KAAR;AACA,EAAAA,8CAAA,WAAQ,KAAR;AAHU,SAAAA;AAAA,GAAA;AAML,IAAK,QAAL,kBAAKC,WAAL;AACL,EAAAA,cAAA,aAAU,MAAV;AACA,EAAAA,cAAA,sBAAmB,KAAnB;AACA,EAAAA,cAAA,qBAAkB,KAAlB;AAHU,SAAAA;AAAA,GAAA;AAML,IAAM,QAAN,MAAM,OAAM;AAAA,EACT,SAAsB,CAAC;AAAA,EACvB,SAAsB,CAAC;AAAA,EAE/B,cAAc;AACZ,aAAS,IAAI,GAAG,IAAI,UAAU,mBAAmB,KAAK;AACpD,WAAK,OAAO,CAAC,IAAI,IAAI,UAAU;AAC/B,WAAK,OAAO,CAAC,IAAI,IAAI,UAAU;AAAA,IACjC;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,OAAO,SAAS,OAAmB,MAA4B;AAC7D,UAAM,IAAI,IAAI,OAAM;AACpB,MAAE,cAAc,EAAE;AAClB,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAM,KAAK,KAAK,CAAC;AACjB,SAAG,CAAC;AAAA,IACN;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,gBAA4B;AAC1B,WAAO,IAAI,WAAW,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,GAAG,UAAU,OAAO,WAAW,CAAC;AAAA,EACnF;AAAA,EAEA,IAAI,QAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAoB;AAC5B,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,IAAI,QAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,MAAM,OAAoB;AAC5B,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA,EAGA,cAAc,IAAgB;AAC5B,SAAK,OAAO,CAAC,IAAI,IAAI;AAAA,MACnB,WAAW,KAAK,CAAC,GAAG,GAAG,OAAO,GAAG,IAAI,MAAM,UAAU,OAAO,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;AAAA,IACnF;AAAA,EACF;AAAA,EAEA,WAAW,GAAgB;AAEzB,SAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK;AACvC,SAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK;AAAA,EACzC;AAAA,EAEQ,aAA0B;AAChC,QAAI,MAAM,KAAK,OAAO,CAAC,EAAE,MAAM,gBAAa;AAE5C,WAAO;AACP,WAAO;AAAA,EACT;AAAA,EAEQ,kBAAkB,KAAc;AACtC,QAAI,KAAK;AACP,WAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK,KAAO;AAAA,IAChD,OAAO;AACL,WAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK,EAAE,KAAO;AAAA,IAClD;AAAA,EACF;AAAA,EAEQ,oBAA6B;AACnC,UAAM,OAAO,KAAO;AACpB,YAAQ,KAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,IAAI,QAAQ;AAAA,EACxD;AAAA;AAAA,EAGA,gBAA4B;AAC1B,YAAQ,KAAK,WAAW,GAAG;AAAA,MACzB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,cAAM,UAAU,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,iBAAiB,OAAsB,OAA4B;AACjE,SAAK,OAAO,CAAC,IAAI,KAAK,WAAW,OAAO,qBAAe;AACvD,SAAK,OAAO,CAAC,IAAI,KAAK,WAAW,OAAO,qBAAe;AAAA,EACzD;AAAA;AAAA;AAAA,EAGA,kBAAkB,OAAmB,OAAyB;AAC5D,SAAK,OAAO,CAAC,IAAI,KAAK,aAAa,OAAO,qBAAe;AACzD,SAAK,OAAO,CAAC,IAAI,KAAK,aAAa,OAAO,qBAAe;AAAA,EAC3D;AAAA;AAAA;AAAA,EAGA,aAAa,OAAkB,OAAwB;AACrD,UAAM,cAAwB,CAAC,MAAM,SAAS,GAAG,MAAM,SAAS,CAAC;AACjE,QAAI,CAAC,wBAAwB,WAAW,GAAG;AACzC,YAAM,UAAU,OAAO;AAAA,IACzB;AACA,SAAK,OAAO,CAAC,IAAI;AACjB,SAAK,OAAO,CAAC,IAAI;AAAA,EACnB;AAAA;AAAA;AAAA,EAGA,iBAAiB,OAAsB,OAA4B;AACjE,SAAK,OAAO,CAAC,IAAI,KAAK,WAAW,OAAO,qBAAe;AACvD,SAAK,OAAO,CAAC,IAAI,KAAK,WAAW,OAAO,qBAAe;AAAA,EACzD;AAAA;AAAA;AAAA,EAGA,kBAAkB,OAA0B,OAAgC;AAC1E,SAAK,OAAO,CAAC,IAAI,KAAK,aAAa,OAAO,qBAAe;AACzD,SAAK,OAAO,CAAC,IAAI,KAAK,aAAa,OAAO,qBAAe;AAAA,EAC3D;AAAA,EAEQ,aAAa,OAA0B,UAA+B;AAC5E,UAAM,OAAO,IAAI,UAAU,KAAK;AAChC,QAAI,CAAC,mBAAmB,KAAK,SAAS,CAAC,GAAG;AACxC,YAAM,IAAI,gBAAgB,QAAQ;AAAA,IACpC;AACA,WAAO;AAAA,EACT;AAAA,EAEA,iBAAiB,GAAgC;AAC/C,QAAI;AACJ,YAAQ,GAAG;AAAA,MACT,KAAK;AACH,YAAI;AACJ;AAAA,MACF,KAAK;AACH,YAAI;AACJ;AAAA,MACF;AACE,YAAI;AAAA,IACR;AAEA,SAAK,MAAM,CAAC,EAAE,MAAM,gBAAa,KAAK;AACtC,SAAK,MAAM,CAAC,EAAE,MAAM,gBAAa,KAAK;AAAA,EACxC;AAAA,EAEQ,eAA8B;AACpC,QAAI,KAAK,KAAK,MAAM,CAAC,EAAE,MAAM,gBAAa;AAE1C,UAAM;AACN,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,uBAA8C;AAC5C,YAAQ,KAAK,aAAa,GAAG;AAAA,MAC3B,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,cAAM,UAAU,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA,EAEO,WAAW,OAAsB,UAA+B;AACrE,QAAI,CAAC,OAAO;AACV,cAAQ,OAAO,CAAC;AAAA,IAClB;AACA,QAAI,CAAC,mBAAmB,KAAK,GAAG;AAC9B,YAAM,IAAI,gBAAgB,QAAQ;AAAA,IACpC;AACA,WAAO,IAAI,UAAU,EAAE,UAAU,KAAK;AAAA,EACxC;AAAA;AAAA;AAAA,EAGA,aAAa,OAAkB,OAAkB;AAC/C,UAAM,cAAwB,CAAC,MAAM,SAAS,GAAG,MAAM,SAAS,CAAC;AACjE,QAAI,CAAC,wBAAwB,WAAW,GAAG;AACzC,YAAM,UAAU,OAAO;AAAA,IACzB;AACA,SAAK,OAAO,CAAC,IAAI;AACjB,SAAK,OAAO,CAAC,IAAI;AAAA,EACnB;AAAA,EAEA,sBAA4B;AAC1B,SAAK,kBAAkB,KAAK;AAC5B,UAAM,QAAQ,MAAM,KAAK,EAAE,QAAQ,UAAU,mBAAmB,GAAG,MAAM,CAAC;AAC1E,UAAM,MAAM,MAAM,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK;AAC3C,QAAI,OAAO,UAAU,oBAAoB,UAAU,oBAAoB,GAAG,KAAK;AAC/E,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,WAAW,KAAK,GAAG,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA,EAIA,oBAAiC;AAC/B,QAAI,KAAK,kBAAkB,GAAG;AAC5B,YAAM,gBAAgB,UAAU,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,GAAG,EAAE,CAAC;AACjE,aAAO,yBAAyB,OAAO,aAAa,CAAC;AAAA,IACvD;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,kBAAkB,IAAU;AAC1B,SAAK,kBAAkB,IAAI;AAC3B,UAAM,QAAQ,UAAmB,OAAO,iBAAiB,EAAE,CAAC,CAAC;AAC7D,UAAM,MAAM,MAAM,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK;AAC3C,QAAI,OAAO,UAAU,oBAAoB,UAAU,oBAAoB,GAAG,KAAK;AAC/E,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,WAAW,KAAK,GAAG,CAAC;AAAA,EACrD;AAAA;AAAA,EAGA,qBAA6B;AAC3B,WAAO,UAAU,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,GAAG,CAAC,CAAC;AAAA,EACnD;AAAA;AAAA,EAEA,mBAAmB,OAAqB;AACtC,UAAM,QAAQ,UAAmB,KAAK;AACtC,QAAI,MAAM,SAAS,UAAU,oBAAoB;AAC/C,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AACA,UAAM,MAAM,MAAM,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK;AAC3C,QAAI,OAAO,GAAG,UAAU,oBAAoB,GAAG,KAAK;AACpD,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,WAAW,KAAK,GAAG,CAAC;AAAA,EACrD;AAAA,EAEA,aAAiB;AACf,WAAO,GAAG,UAAU,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,GAAG,EAAE,CAAC;AAAA,EACvD;AAAA;AAAA,EAGA,WAAW,IAAc;AACvB,SAAK,aAAa;AAClB,SAAK,WAAW,sBAA0B;AAC1C,UAAM,MAAM,MAAM,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK;AAC3C,QAAI,OAAO,GAAG,GAAG,MAAM,QAAQ,GAAG,GAAG,KAAK;AAC1C,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,WAAW,KAAK,GAAG,CAAC;AAAA,EACrD;AAAA,EAEQ,eAAe;AACrB,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,IAAI,WAAW,UAAU,YAAY,EAAE,KAAK,CAAC,CAAC;AAAA,EAC/E;AAAA,EAEQ,eAAqB;AAC3B,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,IAAI,WAAW,UAAU,YAAY,EAAE,KAAK,CAAC,CAAC;AAAA,EAC/E;AAAA,EAEA,aAAiB;AACf,WAAO,GAAG,UAAU,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,GAAG,EAAE,CAAC;AAAA,EACvD;AAAA;AAAA,EAGA,WAAW,IAAc;AACvB,SAAK,aAAa;AAClB,SAAK,WAAW,sBAA0B;AAC1C,UAAM,MAAM,MAAM,KAAK,KAAK,OAAO,CAAC,EAAE,KAAK;AAC3C,QAAI,OAAO,GAAG,GAAG,MAAM,QAAQ,GAAG,GAAG,KAAK;AAC1C,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,WAAW,KAAK,GAAG,CAAC;AAAA,EACrD;AAAA;AAAA,EAEA,WAAW,KAAa;AACtB,UAAM,QAAQ,UAAU,GAAG;AAC3B,SAAK,OAAO,CAAC,EAAE,MAAM,EAAE,IAAI,MAAM,CAAC;AAClC,SAAK,OAAO,CAAC,EAAE,MAAM,EAAE,IAAI,MAAM,CAAC;AAClC,SAAK,OAAO,CAAC,EAAE,MAAM,EAAE,IAAI,MAAM,CAAC;AAClC,SAAK,OAAO,CAAC,EAAE,MAAM,EAAE,IAAI,MAAM,CAAC;AAAA,EACpC;AAAA;AAAA,EAEA,aAAqB;AACnB,WAAO,UAAU,KAAK,OAAO,CAAC,EAAE,MAAM,MAAM,IAAI,EAAE,CAAC;AAAA,EACrD;AAAA;AAAA,EAEA,iBAAiB,KAAc;AAC7B,QAAI,KAAK;AACP,WAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK,KAAO;AAAA,IAChD,OAAO;AACL,WAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,KAAK,EAAE,KAAO;AAAA,IAClD;AAAA,EACF;AAAA;AAAA,EAGA,SAAiB;AACf,WAAO,2BAAS,KAAK,UAAU,gBAAgB,KAAK,MAAM,CAAC;AAAA,EAC7D;AAAA;AAAA,EAGA,mBAA4B;AAC1B,UAAM,OAAO,KAAO;AACpB,YAAQ,KAAK,OAAO,CAAC,EAAE,MAAM,gBAAa,IAAI,QAAQ;AAAA,EACxD;AAAA;AAAA,EAGA,SAAiB;AACf,WAAO,2BAAS,KAAK,UAAU,gBAAgB,KAAK,MAAM,CAAC;AAAA,EAC7D;AAAA;AAAA,EAGA,OAAmC;AACjC,WAAO,EAAE,IAAI,KAAK,OAAO,GAAG,IAAI,KAAK,OAAO,EAAE;AAAA,EAChD;AAAA;AAAA,EAGA,sBAAsB,GAAiB;AACrC,SAAK,wBAAwB;AAC7B,SAAK,iBAAiB,aAA2B;AACjD,SAAK,MAAM,CAAC,IAAI,KAAK,WAAW,GAAG,qBAAe;AAAA,EACpD;AAAA,EAEA,0BAA0B;AACxB,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,IAAI,WAAW,UAAU,YAAY,EAAE,KAAK,CAAC,CAAC;AAAA,EAC/E;AAAA;AAAA,EAGA,sBAAsB,GAAiB;AACrC,SAAK,wBAAwB;AAC7B,SAAK,iBAAiB,aAA2B;AACjD,SAAK,MAAM,CAAC,IAAI,KAAK,WAAW,GAAG,qBAAe;AAAA,EACpD;AAAA,EACA,0BAA0B;AACxB,SAAK,OAAO,CAAC,IAAI,IAAI,UAAU,IAAI,WAAW,UAAU,YAAY,EAAE,KAAK,CAAC,CAAC;AAAA,EAC/E;AAAA;AAAA;AAAA,EAIA,mBAA2B;AACzB,YAAQ,KAAK,aAAa,GAAG;AAAA,MAC3B,KAAK;AACH,eAAO,KAAK,MAAM,CAAC,EAAE,SAAS;AAAA,MAChC,KAAK;AACH,eAAO,KAAK,MAAM,CAAC,EAAE,SAAS;AAAA,MAChC;AACE,cAAM,UAAU,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA,EAGA,UAAgB;AACd,SAAK,aAAa;AAClB,SAAK,aAAa;AAClB,SAAK,WAAW,YAAgB;AAAA,EAClC;AAAA;AAAA;AAAA,EAGA,QAAY;AACV,YAAQ,KAAK,WAAW,GAAG;AAAA,MACzB,KAAK;AACH,eAAO,KAAK,WAAW;AAAA,MACzB,KAAK;AACH,eAAO,KAAK,WAAW;AAAA,MACzB;AACE,cAAM,UAAU,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA,EAEA,WAAuD;AACrD,WAAO;AAAA,MACL,OAAO,KAAK;AAAA,MACZ,OAAO,KAAK;AAAA,IACd;AAAA,EACF;AAAA;AAAA,EAEA,iBAA2B;AACzB,WAAO,CAAC,GAAG,UAAU,gBAAgB,KAAK,MAAM,GAAG,GAAG,UAAU,gBAAgB,KAAK,MAAM,CAAC;AAAA,EAC9F;AAAA,EAEA,QAAe;AACb,WAAO,KAAK,MAAM,KAAK,UAAU,IAAI,CAAC;AAAA,EACxC;AAAA,EAEA,cAAwB;AACtB,WAAO,KAAK,eAAe,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;AAAA,EACtD;AAAA,EAEA,cAAc,GAAkB;AAC9B,UAAM,OAAiB,KAAK,MAAM,CAAC,EAAE,IAAI,CAAC,MAAc,OAAO,CAAC,CAAC;AAEjE,QAAI,KAAK,WAAW,KAAK,OAAO,SAAS,KAAK,OAAO,QAAQ;AAC3D,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AACA,SAAK,SAAS,CAAC;AACf,SAAK,SAAS,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,UAAU,mBAAmB,IAAI,KAAK,SAAS,GAAG,KAAK,KAAK;AAC9E,WAAK,OAAO,CAAC,IAAI,IAAI,UAAU;AAC/B,WAAK,OAAO,CAAC,EAAE,UAAU,KAAK,CAAC,CAAC;AAChC,WAAK,OAAO,CAAC,IAAI,IAAI,UAAU;AAC/B,WAAK,OAAO,CAAC,EAAE,UAAU,KAAK,CAAC,CAAC;AAAA,IAClC;AACA,WAAO;AAAA,EACT;AAAA,EAEA,gBAA4B;AAC1B,UAAM,WAAW,CAAC,QAChB,IAAI,OAAO,CAAC,KAAe,QAAmB;AAC5C,aAAO,CAAC,GAAG,KAAK,GAAG,IAAI,KAAK;AAAA,IAC9B,GAAG,CAAC,CAAC;AACP,WAAO,WAAW,KAAK,SAAS,KAAK,MAAM,EAAE,OAAO,SAAS,KAAK,MAAM,CAAC,CAAC;AAAA,EAC5E;AAAA;AAAA,EAGA,MAAc;AACZ,UAAM,IAAI,KAAK,cAAc;AAC7B,WAAO,sBAAI,aAAa,CAAC;AAAA,EAC3B;AAAA,EAEA,QAAQ,KAAoB;AAC1B,UAAM,IAAI,sBAAI,aAAa,GAAG;AAC9B,SAAK,gBAAgB,CAAC;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,MAAwB;AACtC,UAAM,UAAU,IAAI,UAAU,oBAAoB,UAAU;AAC5D,QAAI,KAAK,WAAW,SAAS;AAC3B,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AACA,SAAK,SAAS,CAAC;AACf,SAAK,SAAS,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,UAAU,mBAAmB,IAAI,UAAU,mBAAmB,KAAK,KAAK;AAC1F,WAAK,OAAO,CAAC,IAAI,IAAI;AAAA,QACnB,KAAK,MAAM,IAAI,UAAU,eAAe,IAAI,KAAK,UAAU,YAAY;AAAA,MACzE;AACA,WAAK,OAAO,CAAC,IAAI,IAAI;AAAA,QACnB,KAAK,MAAM,IAAI,UAAU,eAAe,IAAI,KAAK,UAAU,YAAY;AAAA,MACzE;AAAA,IACF;AAAA,EACF;AACF;AAIO,IAAM,eAAN,MAAmB;AAAA;AAAA,EAExB,OAAO,kBAAkB,KAA2B;AAClD,WAAO,CAAC,MAAa,EAAE,iBAAiB,GAAG;AAAA,EAC7C;AAAA;AAAA,EAGA,OAAO,YAAY,KAA0B;AAC3C,WAAO,CAAC,MAAa,EAAE,WAAW,GAAG;AAAA,EACvC;AAAA;AAAA,EAGA,OAAO,YAAY,IAAqB;AACtC,WAAO,CAAC,MAAa,EAAE,WAAW,EAAE;AAAA,EACtC;AAAA;AAAA,EAGA,OAAO,YAAY,IAAqB;AACtC,WAAO,CAAC,MAAa,EAAE,WAAW,EAAE;AAAA,EACtC;AAAA;AAAA,EAGA,OAAO,kBAAkB,GAAuC;AAC9D,WAAO,CAAC,MAAa,EAAE,iBAAiB,CAAC;AAAA,EAC3C;AAAA;AAAA,EAGA,OAAO,OAAO,IAAQ,KAA8B;AAClD,WAAO,CAAC,MAAa;AACnB,cAAQ,KAAK;AAAA,QACX,KAAK;AACH,YAAE,WAAW,EAAE;AACf;AAAA,QACF,KAAK;AACH,YAAE,WAAW,EAAE;AACf;AAAA,QACF;AACE,gBAAM,UAAU,OAAO;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,oBAAoB,OAA4B;AACrD,WAAO,CAAC,MAAa,EAAE,mBAAmB,KAAK;AAAA,EACjD;AAAA;AAAA,EAGA,OAAO,mBAAmB,IAAuB;AAC/C,WAAO,CAAC,MAAa,EAAE,kBAAkB,EAAE;AAAA,EAC7C;AAAA;AAAA;AAAA,EAIA,OAAO,cAAc,OAAkB,OAA+B;AACpE,WAAO,CAAC,MAAa,EAAE,aAAa,OAAO,KAAK;AAAA,EAClD;AAAA;AAAA;AAAA,EAIA,OAAO,mBAAmB,OAA0B,OAAuC;AACzF,WAAO,CAAC,MAAa,EAAE,kBAAkB,OAAO,KAAK;AAAA,EACvD;AAAA;AAAA;AAAA,EAIA,OAAO,kBAAkB,OAAsB,OAAmC;AAChF,WAAO,CAAC,MAAa,EAAE,iBAAiB,OAAO,KAAK;AAAA,EACtD;AAAA;AAAA;AAAA,EAIA,OAAO,cAAc,OAAkB,OAA+B;AACpE,WAAO,CAAC,MAAa,EAAE,aAAa,OAAO,KAAK;AAAA,EAClD;AAAA;AAAA;AAAA,EAIA,OAAO,mBAAmB,OAAmB,OAAgC;AAC3E,WAAO,CAAC,MAAa,EAAE,kBAAkB,OAAO,KAAK;AAAA,EACvD;AAAA;AAAA;AAAA,EAIA,OAAO,kBAAkB,OAAsB,OAAmC;AAChF,WAAO,CAAC,MAAa,EAAE,iBAAiB,OAAO,KAAK;AAAA,EACtD;AAAA;AAAA;AAAA,EAIA,OAAO,uBAAuB,GAAwB;AACpD,WAAO,CAAC,MAAa;AACnB,QAAE,iBAAiB,aAA2B;AAC9C,QAAE,MAAM,CAAC,IAAI,EAAE,WAAW,GAAG,qBAAe;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,OAAO,uBAAuB,GAAwB;AACpD,WAAO,CAAC,MAAa;AACnB,QAAE,iBAAiB,aAA2B;AAC9C,QAAE,MAAM,CAAC,IAAI,EAAE,WAAW,GAAG,qBAAe;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,OAAO,kBAAkB,GAAW,KAAyC;AAC3E,WAAO,CAAC,MAAa;AACnB,cAAQ,KAAK;AAAA,QACX,KAAK;AACH,YAAE,iBAAiB,aAA2B;AAC9C,YAAE,MAAM,CAAC,IAAI,EAAE,WAAW,GAAG,qBAAe;AAC5C;AAAA,QACF,KAAK;AACH,YAAE,iBAAiB,aAA2B;AAC9C,YAAE,MAAM,CAAC,IAAI,EAAE,WAAW,GAAG,qBAAe;AAC5C;AAAA,QACF;AACE,gBAAM,UAAU,OAAO;AAAA,MAC3B;AAAA,IACF;AAAA,EACF;AACF;;;AC7pBO,IAAM,iBAAN,MAAM,gBAAe;AAAA,EAC1B,YAA4B,YAAoC,WAAmB;AAAvD;AAAoC;AAAA,EAAoB;AAAA,EAEpF,WAAmB;AACjB,WAAO,GAAG,KAAK,UAAU,IAAI,KAAK,SAAS;AAAA,EAC7C;AAAA,EAEA,OAAO,WAAW,GAA2B;AAC3C,UAAM,CAAC,YAAY,SAAS,IAAI,EAAE,MAAM,GAAG;AAC3C,WAAO,IAAI,gBAAe,WAAW,QAAQ,KAAK,EAAE,GAAG,UAAU,QAAQ,KAAK,EAAE,CAAC;AAAA,EACnF;AACF;AAGO,SAAS,aAAa,QAAgB,YAAoB,SAA6B;AAC5F,QAAM,KAAK,cAAc,MAAM;AAC/B,MAAI,CAAC,IAAI;AACP,UAAM,UAAU,OAAO;AAAA,EACzB;AACA,QAAM,WAAW,iBAAiB,MAAM;AACxC,MAAI,CAAC,UAAU;AACb,UAAM,UAAU,OAAO;AAAA,EACzB;AAEA,QAAM,KAAyB,SAAS,IAAI,eAAe,YAAY,OAAO,EAAE,SAAS,CAAC;AAE1F,MAAI,OAAO,OAAO,UAAU;AAC1B,UAAM,IAAI;AAAA,MACR,cAAc,WAAW,SAAS,KAAK,GAAG,gBACxC,QAAQ,SAAS,KAAK,GACxB;AAAA,IACF;AAAA,EACF;AAEA,SAAO,WAAW,KAAK,CAAC,IAAI,EAAE,CAAC;AACjC;AAGO,SAAS,iCAAiC,QAAgB,YAA4B;AAC3F,QAAM,YAAY,iBAAiB,MAAM;AACzC,MAAI,CAAC,WAAW;AACd,UAAM,UAAU,OAAO;AAAA,EACzB;AACA,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACpD,QAAI,UAAU,YAAY;AACxB,aAAO,eAAe,WAAW,GAAG,EAAE;AAAA,IACxC;AAAA,EACF;AACA,QAAM,UAAU,OAAO;AACzB;AAGO,SAAS,kCAAkC,QAAgB,YAA4B;AAC5F,QAAM,YAAY,iBAAiB,MAAM;AACzC,MAAI,CAAC,WAAW;AACd,UAAM,IAAI;AAAA,MACR,GAAG,UAAU,OAAO,6BAA6B,gBAAgB,MAAM;AAAA,IACzE;AAAA,EACF;AACA,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACpD,QAAI,UAAU,YAAY;AACxB,aAAO,eAAe,WAAW,GAAG,EAAE;AAAA,IACxC;AAAA,EACF;AACA,QAAM,UAAU,OAAO;AACzB;AAGO,SAAS,qBAAqB,YAA4B;AAC/D,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,aAAa,GAAG;AACxD,QAAI,UAAU,YAAY;AACxB,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,UAAU,OAAO;AACzB;;;AC9EO,IAAM,QAAN,MAAY;AAAA,EACjB,YAAmB,MAAqB,OAAe;AAApC;AAAqB;AAAA,EAAgB;AAAA,EAExD,WAAmB;AACjB,QAAI,CAAC,KAAK,MAAM;AACd,aAAO;AAAA,IACT;AACA,QAAI,CAAC,KAAK,OAAO;AACf,aAAO,KAAK;AAAA,IACd;AACA,WAAO,GAAG,KAAK,IAAI,IAAI,KAAK,KAAK;AAAA,EACnC;AACF;AAaO,IAAM,gBAAsB,OAAO,OAAO;AAAA,EAC/C,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,WAAW,CAAC;AAAA,EACZ,QAAQ,CAAC;AAAA,EACT,MAAM;AAAA,EACN,cAAc,CAAC;AAAA,EACf,OAAO;AAAA,EACP,UAAU;AACZ,CAAC;;;AC5BM,IAAM,SAAN,MAAa;AAAA;AAAA,EAIlB,YAA6B,OAAe;AAAf;AAAA,EAAgB;AAAA,EAH7C,eAAe;AAAA;AAAA,EACf,MAAY,EAAE,GAAG,cAAc;AAAA,EAI/B,cAAiC;AAC/B,UAAM,cAAc,KAAK,MAAM;AAE/B,QAAI,cAAc,GAAG;AACnB,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAEA,WAAO,KAAK,YAAY,KAAK,IAAI;AAAA,EACnC;AAAA;AAAA,EAGA,cAAiC;AAC/B,UAAM,eAAe;AAErB,QAAI,KAAK,MAAM,MAAM,GAAG,eAAe,CAAC,MAAM,QAAQ;AACpD,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC3D;AAEA,SAAK,eAAe;AACpB,WAAO,KAAK,YAAY,KAAK,IAAI;AAAA,EACnC;AAAA,EAEA,cAAiC;AAC/B,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,MAAM;AAC1B,QAAI,eAAe,KAAK,eAAe;AACvC,UAAM,aAAa;AAEnB,eAAS;AACP,UAAI,iBAAiB,aAAa;AAEhC,cAAM,IAAI,MAAM,6DAA6D;AAAA,MAC/E;AAGA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,YAAI,iBAAiB,YAAY;AAE/B,gBAAM,IAAI,MAAM,oBAAoB,YAAY,EAAE;AAAA,QACpD;AACA;AAAA,MACF;AAGA,UAAI,YAAY,WAAW,IAAI,KAAK,YAAY,iBAAiB,IAAI,GAAG;AACtE,cAAM,IAAI,MAAM,iCAAiC,YAAY,EAAE;AAAA,MACjE;AAGA,qBAAe,eAAe;AAAA,IAChC;AAGA,SAAK,eAAe;AACpB,SAAK,IAAI,SAAS,MAAM,MAAM,YAAY,YAAY;AAGtD,WAAO,KAAK,QAAQ,KAAK,IAAI;AAAA,EAC/B;AAAA,EAEA,UAA6B;AAC3B,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,MAAM;AAC1B,QAAI,eAAe,KAAK,eAAe;AACvC,UAAM,aAAa;AAEnB,QAAI,OAA0B;AAE9B,eAAS;AACP,UAAI,iBAAiB,aAAa;AAEhC,eAAO;AACP;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAIA,UAAI,YAAY,iBAAiB,IAAI,GAAG;AACtC,cAAM,IAAI,MAAM,6CAA6C,YAAY,EAAE;AAAA,MAC7E;AAGA,qBAAe,eAAe;AAAA,IAChC;AAEA,QAAI,iBAAiB,YAAY;AAK/B,YAAM,IAAI,MAAM,4CAA4C,YAAY,EAAE;AAAA,IAC5E;AAGA,SAAK,eAAe;AACpB,SAAK,IAAI,YAAY,CAAC,GAAG,KAAK,IAAI,WAAW,MAAM,MAAM,YAAY,YAAY,CAAC;AAGlF,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,iBAAoC;AAClC,UAAM,QAAQ,KAAK;AACnB,UAAM,aAAa,KAAK,eAAe;AACvC,UAAM,OAAO,KAAK,gBAAgB;AAClC,UAAM,eAAe,KAAK;AAE1B,QAAI,iBAAiB,YAAY;AAC/B,YAAM,IAAI,MAAM,8CAA8C,YAAY,EAAE;AAAA,IAC9E;AAGA,SAAK,IAAI,SAAS,CAAC,GAAG,KAAK,IAAI,QAAQ,IAAI,MAAM,MAAM,MAAM,YAAY,YAAY,GAAG,EAAE,CAAC;AAG3F,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,kBAAqC;AACnC,UAAM,QAAQ,KAAK;AACnB,UAAM,aAAa,KAAK,eAAe;AACvC,UAAM,OAAO,KAAK,gBAAgB;AAClC,UAAM,eAAe,KAAK;AAC1B,SAAK,IAAI,OAAO,KAAK,IAAI,OAAO,SAAS,CAAC,EAAE,QAAQ,MAAM,MAAM,YAAY,YAAY;AACxF,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,kBAAqC;AACnC,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,MAAM;AAC1B,QAAI,eAAe,KAAK,eAAe;AAEvC,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,eAAS;AACP,UAAI,iBAAiB,aAAa;AAEhC,eAAO;AACP;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAGA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,QAAQ,KAAK;AAEf,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,QAAQ,KAAK;AAEf,YACE,eAAe,KAAK,eACpB,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,KACjD,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,GACjD;AACA,gBAAM,IAAI,MAAM,uCAAuC,YAAY,EAAE;AAAA,QACvE;AAEA,yBAAiB;AACjB,yBAAiB;AAAA,MACnB,OAAO;AAEL,yBAAiB;AACjB,yBAAiB;AAAA,MACnB;AAIA,UAAI,CAAC,kBAAkB,YAAY,oBAAoB,IAAI,GAAG;AAC5D,cAAM,IAAI,MAAM,uCAAuC,IAAI,OAAO,YAAY,EAAE;AAAA,MAClF;AAGA,qBAAe,eAAe;AAAA,IAChC;AAGA,SAAK,eAAe;AAEpB,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,YAA+B;AAC7B,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,MAAM;AAC1B,QAAI,eAAe,KAAK,eAAe;AACvC,UAAM,aAAa;AAEnB,QAAI;AACJ,QAAI;AACJ,QAAI;AAEJ,eAAS;AACP,UAAI,iBAAiB,aAAa;AAChC,eAAO;AACP;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,YACE,eAAe,KAAK,eACpB,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,KACjD,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,GACjD;AACA,gBAAM,IAAI,MAAM,sCAAsC,YAAY,EAAE;AAAA,QACtE;AAEA,yBAAiB;AACjB,yBAAiB;AAAA,MACnB,OAAO;AAEL,yBAAiB;AACjB,yBAAiB;AAAA,MACnB;AAGA,UAAI,CAAC,kBAAkB,YAAY,mBAAmB,IAAI,GAAG;AAC3D,cAAM,IAAI,MAAM,qCAAqC,YAAY,EAAE;AAAA,MACrE;AAGA,qBAAe,eAAe;AAAA,IAChC;AAEA,QAAI,gBAAgB,cAAc,KAAK,IAAI,aAAa,WAAW,GAAG;AACpE,YAAM,IAAI,MAAM,wDAAwD,YAAY,EAAE;AAAA,IACxF;AAGA,SAAK,eAAe;AACpB,SAAK,IAAI,eAAe,CAAC,GAAG,KAAK,IAAI,cAAc,MAAM,MAAM,YAAY,YAAY,CAAC;AAExF,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,aAAgC;AAC9B,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,MAAM;AAC1B,QAAI,eAAe,KAAK,eAAe;AACvC,UAAM,aAAa;AAEnB,QAAI;AACJ,QAAI,OAA0B;AAC9B,QAAI;AAEJ,eAAS;AACP,UAAI,iBAAiB,aAAa;AAChC;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,eAAO,KAAK;AACZ;AAAA,MACF;AAEA,UAAI,SAAS,KAAK;AAEhB,YACE,eAAe,KAAK,eACpB,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,KACjD,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,GACjD;AACA,gBAAM,IAAI,MAAM,sCAAsC,YAAY,EAAE;AAAA,QACtE;AAEA,yBAAiB;AACjB,yBAAiB;AAAA,MACnB,OAAO;AAEL,yBAAiB;AACjB,yBAAiB;AAAA,MACnB;AACA,UAAI,CAAC,kBAAkB,YAAY,8BAA8B,IAAI,GAAG;AACtE,cAAM,IAAI,MAAM,uCAAuC,IAAI,EAAE;AAAA,MAC/D;AAGA,qBAAe,eAAe;AAAA,IAChC;AAGA,SAAK,eAAe;AACpB,SAAK,IAAI,QAAQ,MAAM,MAAM,YAAY,YAAY;AAErD,WAAO,OAAO,KAAK,KAAK,IAAI,IAAI;AAAA,EAClC;AAAA,EAEA,gBAAmC;AACjC,UAAM,QAAQ,KAAK;AACnB,UAAM,cAAc,KAAK,MAAM;AAC/B,QAAI,eAAe,KAAK,eAAe;AACvC,UAAM,aAAa;AAEnB,QAAI;AACJ,QAAI;AAEJ,eAAS;AACP,UAAI,iBAAiB,aAAa;AAChC;AAAA,MACF;AAEA,YAAM,OAAO,MAAM,YAAY;AAE/B,UAAI,SAAS,KAAK;AAEhB,YACE,eAAe,KAAK,eACpB,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,KACjD,YAAY,cAAc,MAAM,eAAe,CAAC,CAAC,GACjD;AACA,gBAAM,IAAI,MAAM,sCAAsC,YAAY,EAAE;AAAA,QACtE;AAEA,yBAAiB;AACjB,yBAAiB;AAAA,MACnB,OAAO;AAEL,yBAAiB;AACjB,yBAAiB;AAAA,MACnB;AAEA,UAAI,CAAC,kBAAkB,YAAY,8BAA8B,IAAI,GAAG;AACtE,cAAM,IAAI,MAAM,0CAA0C,IAAI,EAAE;AAAA,MAClE;AAGA,qBAAe,eAAe;AAAA,IAChC;AAGA,SAAK,eAAe;AACpB,SAAK,IAAI,WAAW,MAAM,MAAM,YAAY,YAAY;AAIxD,WAAO;AAAA,EACT;AACF;;;AC5ZA,IAAAC,oBAAuB;AAKhB,IAAM,MAAN,MAAM,KAAI;AAAA,EACf,SAAS;AAAA,EACT,KAAK;AAAA,EACL,YAAsB,CAAC;AAAA,EACvB,SAAkB,CAAC;AAAA,EACnB,OAAO;AAAA,EACP,eAAyB,CAAC;AAAA,EAC1B,QAAQ;AAAA,EACR,WAAW;AAAA,EAEX,YAAY,GAAmB;AAC7B,QAAI,GAAG;AACL,aAAO,OAAO,MAAM,CAAC;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,QAAiB;AACf,WACE,KAAK,OAAO,SAAS,KACrB,CAAC,CAAC,KAAK,QACP,KAAK,aAAa,SAAS,KAC3B,CAAC,CAAC,KAAK,SACP,CAAC,CAAC,KAAK;AAAA,EAEX;AAAA,EAEA,SAAiB;AACf,UAAM,OAAO,CAAC,MAAM;AACpB,QAAI,KAAK,QAAQ;AACf,WAAK,KAAK,GAAG,KAAK,MAAM,GAAG;AAAA,IAC7B,OAAO;AACL,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,IAAI;AACX,WAAK,KAAK,KAAK,EAAE;AAAA,IACnB,WAAW,KAAK,UAAU,QAAQ;AAChC,WAAK,KAAK,KAAK,UAAU,KAAK,GAAG,CAAC;AAAA,IACpC,OAAO;AACL,aAAO;AAAA,IACT;AAEA,QAAI,KAAK,OAAO,QAAQ;AACtB,iBAAW,SAAS,KAAK,QAAQ;AAC/B,cAAM,IAAI,MAAM,SAAS;AACzB,YAAI,GAAG;AACL,eAAK,KAAK,IAAI,CAAC,EAAE;AAAA,QACnB,OAAO;AACL,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,QAAI,KAAK,MAAM;AACb,WAAK,KAAK,IAAI,KAAK,IAAI,EAAE;AAAA,IAC3B,WAAW,KAAK,aAAa,QAAQ;AACnC,WAAK,KAAK,IAAI,KAAK,aAAa,KAAK,GAAG,CAAC,EAAE;AAAA,IAC7C;AAEA,QAAI,KAAK,OAAO;AACd,WAAK,KAAK,IAAI,KAAK,KAAK,EAAE;AAAA,IAC5B;AAEA,QAAI,KAAK,UAAU;AACjB,WAAK,KAAK,IAAI,KAAK,QAAQ,EAAE;AAAA,IAC/B;AAEA,WAAO,KAAK,KAAK,EAAE;AAAA,EACrB;AAAA,EAEA,SAAS;AACP,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,OAAO,MAAM,GAAgB;AAC3B,UAAM,SAAS,IAAI,OAAO,CAAC;AAE3B,QAAI,cAAc,OAAO,YAAY;AAErC,WAAO,aAAa;AAClB,oBAAc,YAAY;AAAA,IAC5B;AAEA,WAAO,IAAI,KAAK,OAAO,IAAI,UAAU,KAAK,GAAG;AAC7C,WAAO,IAAI,OAAO,OAAO,IAAI,aAAa,KAAK,GAAG;AAElD,WAAO,IAAI,KAAI,OAAO,GAAG;AAAA,EAC3B;AAAA,EAEA,OAAO,kBAAkB,IAIvB;AACA,UAAM,SAAS,qBAAqB,GAAG,MAAM,CAAC,CAAC;AAC/C,UAAM,aAAa,kCAAkC,QAAQ,GAAG,MAAM,CAAC,CAAC;AAExE,UAAM,YAAY,iCAAiC,QAAQ,GAAG,MAAM,CAAC,CAAC;AAEtE,WAAO,EAAE,QAAQ,YAAY,UAAU;AAAA,EACzC;AAAA,EAEA,OAAO,gBAAgB,IAAgB;AACrC,WAAO,KAAI,sBAAsB,EAAE,EAAE;AAAA,EACvC;AAAA,EAEA,OAAO,aAAa,IAAgB;AAClC,WAAO,KAAI,sBAAsB,EAAE,EAAE;AAAA,EACvC;AAAA,EAEA,OAAO,iBAAiB,IAAgB;AACtC,WAAO,KAAI,sBAAsB,EAAE,EAAE;AAAA,EACvC;AAAA,EAEA,OAAe,sBAAsB,IAInC;AACA,UAAM,EAAE,QAAQ,YAAY,UAAU,IAAI,KAAI,kBAAkB,EAAE;AAElE,QAAI,KAAI,cAAc,QAAQ,YAAY,SAAS,GAAG;AACpD,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,mBAAmB,OAAO,mBAAmB;AAAA,IACnF;AAEA,WAAO,EAAE,QAAQ,YAAY,UAAU;AAAA,EACzC;AAAA;AAAA,EAGA,OAAO,iBAAiB,KAAiB,OAAoB;AAC3D,UAAM,KAAK,GAAG,uBAAuB,KAAK,KAAK;AAE/C,WAAO,KAAI,YAAY,EAAE;AAAA,EAC3B;AAAA;AAAA,EAGA,OAAO,IAAI,KAAiB,SAA0B;AACpD,WAAO,KAAI,YAAY,IAAI,GAAG,KAAK,OAAO,CAAC;AAAA,EAC7C;AAAA;AAAA,EAGA,OAAO,YAAY,IAAa;AAC9B,QAAI,CAAC,YAAY,cAAc,GAAG,KAAK,GAAG;AACxC,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,eAAe,OAAO,oBAAoB;AAAA,IAChF;AACA,UAAM,EAAE,QAAQ,YAAY,UAAU,IAAI,KAAI,sBAAsB,EAAE;AAEtE,UAAM,WAAW,CAAC,UAAU,IAAI,YAAY,OAAO,SAAS,GAAG,WAAW,SAAS,CAAC;AACpF,QAAI,WAAW;AACb,eAAS,KAAK,UAAU,SAAS,CAAC;AAAA,IACpC;AACA,aAAS,KAAK,GAAG,OAAO,CAAC;AAEzB,UAAM,YAAY,SAAS,KAAK,GAAG;AAEnC,UAAM,MAAM,KAAI,MAAM,SAAS;AAE/B,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,UAAU,KAAc;AAC7B,QAAI;AACJ,QAAI;AACF,WAAK,KAAI,aAAa,GAAG;AAAA,IAC3B,SAAS,OAAO;AACd,UAAK,MAAgB,YAAY,UAAU,OAAO,mBAAmB,SAAS;AAC5E,eAAO,KAAI,qBAAqB,GAAG;AAAA,MACrC;AACA,YAAM;AAAA,IACR;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,cAAc,QAAgB,YAAoB,WAA4B;AACnF,WACE,UAAU,UAAU,SACpB,cAAc,WAAW,WACzB,aAAa,UAAU;AAAA,EAE3B;AAAA,EAEA,OAAO,qBAAqB,KAAc;AACxC,UAAM,WAAO,0BAAO,QAAQ,OAAO,IAAI,OAAO,CAAC,CAAC;AAEhD,UAAM,UAAU,IAAI,WAAW,EAAE;AACjC,UAAM,UAAU,KAAK,MAAM,KAAK,SAAS,UAAU,cAAc;AACjE,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,cAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK;AAAA,IAC7B;AACA,UAAM,MAAM,IAAI,eAAe,WAAW,SAAS,UAAU,OAAO;AACpE,UAAM,KAAK,WAAW,KAAK;AAAA,MACzB,cAAc,UAAU,KAAK;AAAA,MAC7B,iBAAiB,UAAU,KAAK,EAAE,IAAI,SAAS,CAAC;AAAA,IAClD,CAAC;AACD,WAAO,IAAI,GAAG,IAAI,OAAO;AAAA,EAC3B;AAAA,EAEA,OAAe,aAAa,KAAc;AACxC,UAAM,SAAS,IAAI;AACnB,UAAM,aAAa,cAAc,MAAM;AACvC,QAAI,CAAC,cAAc,WAAW,UAAU,OAAO;AAC7C,YAAM,UAAU,OAAO;AAAA,IACzB;AAEA,QAAI,IAAI,UAAU,SAAS,KAAK,IAAI,UAAU,SAAS,GAAG;AACxD,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,aAAa,mCAAmC;AAAA,IACtF;AAEA,UAAM,KAAK,GAAG,WAAW,IAAI,UAAU,IAAI,UAAU,SAAS,CAAC,CAAC;AAEhE,QAAI,CAAC,YAAY,cAAc,GAAG,KAAK,GAAG;AACxC,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,aAAa,yBAAyB;AAAA,IAC5E;AAEA,UAAM,EAAE,QAAQ,SAAS,YAAY,UAAU,IAAI,KAAI,kBAAkB,EAAE;AAE3E,QAAI,QAAQ,SAAS,MAAM,OAAO,SAAS,GAAG;AAC5C,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,aAAa,uCAAuC;AAAA,IAC1F;AAEA,QAAI,WAAW,SAAS,MAAM,IAAI,UAAU,CAAC,GAAG;AAC9C,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,aAAa,2CAA2C;AAAA,IAC9F;AAEA,QAAI,IAAI,UAAU,SAAS,KAAK,UAAU,SAAS,KAAK,IAAI,UAAU,CAAC,GAAG;AACxE,YAAM,IAAI,MAAM,GAAG,UAAU,OAAO,aAAa,0CAA0C;AAAA,IAC7F;AAEA,WAAO;AAAA,EACT;AACF;;;ACpPO,IAAM,qBAAqB,CAAC,eAA6B;AAC9D,aAAW,UAAU,IAAI;AAC3B;AAEO,IAAM,kBAAkB,CAAC,YAA0B;AACxD,YAAU,OAAO,IAAI;AACvB;AAEO,IAAM,oBAAoB,CAAC,QAAgB,SAAuB;AACvE,QAAM,MAAM,cAAc,UAAU,KAAK;AAEzC,MAAI,QAAQ,KAAK;AACf,UAAM,IAAI;AAAA,MACR,4CAA4C,KAAK,SAAS,CAAC,CAAC,8BAC1D,MAAM,GACN,SAAS,CAAC,CAAC;AAAA,IACf;AAAA,EACF;AAEA,MAAI,OAAO,cAAc,MAAM,MAAM,YAAY,cAAc,MAAM,MAAM,MAAM;AAC/E;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,aAAa,EAAE,SAAS,IAAI,GAAG;AAC/C,UAAM,IAAI;AAAA,MACR,0BAA0B,MAAM,8BAA8B,KAAK;AAAA,QACjE;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,YAAU,MAAM,IAAI;AACpB,gBAAc,MAAM,IAAI;AAC1B;AAUO,IAAM,kBAAkB,CAAC,YAAoB,SAAiB,YAA0B;AAC7F,QAAM,MAAM,GAAG,UAAU,IAAI,OAAO;AAEpC,MAAI,OAAO,SAAS,GAAG,MAAM,YAAY,SAAS,GAAG,MAAM,SAAS;AAClE;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,QAAQ,EAAE,SAAS,OAAO,GAAG;AAC7C,UAAM,IAAI;AAAA,MACR,0BAA0B,OAAO,SAAS,UAAU,IAAI,OAAO;AAAA,IACjE;AAAA,EACF;AAEA,WAAS,GAAG,IAAI;AAClB;AASO,IAAM,aAAa,CAAC,YAAoB,YAA6B;AAC1E,MAAI,SAAS;AACX,kBAAc,IAAI,OAAO;AAAA,EAC3B;AACA,QAAM,UAAU,SAAS,UAAU;AACnC,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,yBAAyB,UAAU,EAAE;AAAA,EACvD;AACA,SAAO;AACT;AAQO,IAAM,iBAAiB,CAAC,QAAqB;AAClD,QAAM,KAAK,IAAI,UAAU,GAAG;AAE5B,QAAM,aAAa,IAAI,iBAAiB,EAAE;AAE1C,QAAM,YAAY,IAAI,gBAAgB,EAAE;AAExC,QAAM,UAAU,SAAS,GAAG,UAAU,IAAI,SAAS,EAAE;AACrD,MAAI,OAAO,YAAY,UAAU;AAC/B,UAAM,IAAI,MAAM,yBAAyB,UAAU,IAAI,SAAS,EAAE;AAAA,EACpE;AAEA,SAAO;AACT;AAqBO,IAAM,2BAA2B,CAAC;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAOY;AACV,qBAAmB,UAAU;AAC7B,kBAAgB,OAAO;AACvB,MAAI,OAAO,eAAe,UAAU;AAClC,sBAAkB,QAAQ,UAAU;AAAA,EACtC;AAEA,MAAI,CAAC,iBAAiB,MAAM,GAAG;AAC7B,qBAAiB,MAAM,IAAI,CAAC;AAAA,EAC9B;AAEA,MAAI,OAAO,YAAY,UAAU;AAC/B,oBAAgB,YAAY,SAAS,OAAO;AAAA,EAC9C;AAEA,QAAM,MAAM,GAAG,UAAU,IAAI,OAAO;AAEpC,QAAM,cAAc,iBAAiB,MAAM,EAAE,GAAG;AAChD,MAAI,OAAO,gBAAgB,YAAY,gBAAgB,aAAa;AAClE;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,iBAAiB,MAAM,CAAC,EAAE,SAAS,WAAW,GAAG;AACjE,UAAM,IAAI;AAAA,MACR,oBAAoB,YAAY;AAAA,QAC9B;AAAA,MACF,CAAC,0DAA0D,MAAM;AAAA,IACnE;AAAA,EACF;AAEA,mBAAiB,MAAM,EAAE,GAAG,IAAI;AAClC;",
  "names": ["import_js_crypto", "import_js_crypto", "import_js_crypto", "import_js_crypto", "SlotName", "SubjectFlag", "IdPosition", "MerklizedFlag", "MerklizedRootPosition", "Flags", "import_js_crypto"]
}
