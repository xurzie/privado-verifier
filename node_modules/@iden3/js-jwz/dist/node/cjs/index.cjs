"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Header: () => Header,
  ProvingMethodAlg: () => ProvingMethodAlg,
  Token: () => Token,
  hash: () => hash,
  proving: () => proving,
  verifyGroth16Proof: () => verifyGroth16Proof,
  witnessBuilder: () => witnessBuilder
});
module.exports = __toCommonJS(index_exports);

// src/hash.ts
var import_js_iden3_core = require("@iden3/js-iden3-core");
var import_js_crypto = require("@iden3/js-crypto");
var qString = "21888242871839275222246405745257275088548364400416034343698204186575808495617";
function hash(message) {
  const hashBytes = (0, import_js_crypto.sha256)(message);
  const bi = (0, import_js_iden3_core.fromBigEndian)(hashBytes.reverse());
  let m = BigInt(0);
  if (checkBigIntInField(bi)) {
    m = bi;
  } else {
    m = bi % BigInt(qString);
  }
  return import_js_crypto.poseidon.hash([m]);
}
function checkBigIntInField(a) {
  return a < BigInt(qString);
}

// src/proving.ts
var ProvingMethodAlg = class {
  constructor(alg, circuitId) {
    this.alg = alg;
    this.circuitId = circuitId;
  }
  toString() {
    return `${this.alg}:${this.circuitId}`;
  }
};
var provingMethods = /* @__PURE__ */ new Map();
function registerProvingMethod(alg, f) {
  return new Promise((res) => {
    provingMethods.set(alg.toString(), f);
    res();
  });
}
function getProvingMethod(alg) {
  return new Promise((res, rej) => {
    const func = provingMethods.get(alg.toString());
    if (func) {
      const method = func();
      res(method);
    } else {
      rej("unknown alg");
    }
  });
}
function prepare(f, hash2, circuitId) {
  return f(hash2, circuitId);
}

// src/jwz.ts
var import_rfc4648 = require("rfc4648");
var import_js_iden3_core2 = require("@iden3/js-iden3-core");
var Header = /* @__PURE__ */ ((Header2) => {
  Header2["Type"] = "typ";
  Header2["Alg"] = "alg";
  Header2["CircuitId"] = "circuitId";
  Header2["Critical"] = "crit";
  return Header2;
})(Header || {});
var RawJSONWebZeroknowledge = class {
  constructor(payload, protectedHeaders, header, zkp) {
    this.payload = payload;
    this.protectedHeaders = protectedHeaders;
    this.header = header;
    this.zkp = zkp;
  }
  async sanitized() {
    if (!this.payload) {
      throw new Error("iden3/js-jwz: missing payload in JWZ message");
    }
    const headers = JSON.parse(
      new TextDecoder().decode(this.protectedHeaders)
    );
    const criticalHeaders = headers["crit" /* Critical */];
    criticalHeaders.forEach((key) => {
      if (!headers[key]) {
        throw new Error(`iden3/js-jwz: header is listed in critical ${key}, but not presented`);
      }
    });
    const alg = headers["alg" /* Alg */];
    const circuitId = headers["circuitId" /* CircuitId */];
    const method = await getProvingMethod(new ProvingMethodAlg(alg, circuitId));
    const zkp = JSON.parse(new TextDecoder().decode(this.zkp));
    const token = new Token(method, new TextDecoder().decode(this.payload));
    token.alg = alg;
    token.circuitId = circuitId;
    token.zkProof = zkp;
    for (const [key, value] of Object.entries(headers)) {
      token.setHeader(key, value);
    }
    return token;
  }
};
var Token = class _Token {
  constructor(method, payload, inputsPreparer) {
    this.method = method;
    this.inputsPreparer = inputsPreparer;
    this.alg = this.method.alg;
    this.circuitId = this.method.circuitId;
    this.raw = {};
    this.raw.header = this.getDefaultHeaders();
    this.raw.payload = new TextEncoder().encode(payload);
  }
  alg;
  circuitId;
  raw;
  zkProof = {};
  setHeader(key, value) {
    this.raw.header[key] = value;
  }
  getPayload() {
    return new TextDecoder().decode(this.raw.payload);
  }
  getDefaultHeaders() {
    return {
      ["alg" /* Alg */]: this.alg,
      ["crit" /* Critical */]: ["circuitId" /* CircuitId */],
      ["circuitId" /* CircuitId */]: this.circuitId,
      ["typ" /* Type */]: "JWZ"
    };
  }
  // Parse parses a jwz message in compact or full serialization format.
  static parse(tokenStr) {
    const token = tokenStr?.trim();
    return token.startsWith("{") ? _Token.parseFull(tokenStr) : _Token.parseCompact(tokenStr);
  }
  // parseCompact parses a message in compact format.
  static async parseCompact(tokenStr) {
    const parts = tokenStr.split(".");
    if (parts.length != 3) {
      throw new Error("iden3/js-jwz: compact JWZ format must have three segments");
    }
    const rawProtected = import_rfc4648.base64url.parse(parts[0], { loose: true });
    const rawPayload = import_rfc4648.base64url.parse(parts[1], { loose: true });
    const proof = import_rfc4648.base64url.parse(parts[2], { loose: true });
    const raw = new RawJSONWebZeroknowledge(
      rawPayload,
      rawProtected,
      {},
      proof
    );
    return await raw.sanitized();
  }
  // parseFull parses a message in full format.
  static async parseFull(tokenStr) {
    const raw = JSON.parse(tokenStr);
    return await raw.sanitized();
  }
  // Prove creates and returns a complete, proved JWZ.
  // The token is proven using the Proving Method specified in the token.
  async prove(provingKey, wasm) {
    const headers = this.serializeHeaders();
    this.raw.protectedHeaders = new TextEncoder().encode(headers);
    const msgHash = await this.getMessageHash();
    if (!this.inputsPreparer) {
      throw new Error("iden3/jwz: prepare func must be defined");
    }
    const inputs = await prepare(this.inputsPreparer, msgHash, this.circuitId);
    const proof = await this.method.prove(inputs, provingKey, wasm);
    const marshaledProof = JSON.stringify(proof);
    this.zkProof = proof;
    this.raw.zkp = new TextEncoder().encode(marshaledProof);
    return this.compactSerialize();
  }
  // CompactSerialize returns token serialized in three parts: base64 encoded headers, payload and proof.
  compactSerialize() {
    if (!this.raw.header || !this.raw.protectedHeaders || !this.zkProof) {
      throw new Error("iden3/jwz:can't serialize without one of components");
    }
    const serializedProtected = import_rfc4648.base64url.stringify(this.raw.protectedHeaders, {
      pad: false
    });
    const serializedProof = import_rfc4648.base64url.stringify(this.raw.zkp, { pad: false });
    const serializedPayload = import_rfc4648.base64url.stringify(this.raw.payload, {
      pad: false
    });
    return `${serializedProtected}.${serializedPayload}.${serializedProof}`;
  }
  // fullSerialize returns marshaled presentation of raw token as json string.
  fullSerialize() {
    return JSON.stringify(this.raw);
  }
  async getMessageHash() {
    const serializedHeadersJSON = this.serializeHeaders();
    const serializedHeaders = new TextEncoder().encode(serializedHeadersJSON);
    const protectedHeaders = import_rfc4648.base64url.stringify(serializedHeaders, {
      pad: false
    });
    const payload = import_rfc4648.base64url.stringify(this.raw.payload, { pad: false });
    const messageToProof = new TextEncoder().encode(`${protectedHeaders}.${payload}`);
    const hashInt = await hash(messageToProof);
    return (0, import_js_iden3_core2.toBigEndian)(hashInt, 32);
  }
  // Verify  perform zero knowledge verification.
  async verify(verificationKey) {
    const msgHash = await this.getMessageHash();
    return this.method.verify(msgHash, this.zkProof, verificationKey);
  }
  serializeHeaders() {
    return JSON.stringify(this.raw.header, Object.keys(this.raw.header).sort());
  }
};

// src/authGroth16.ts
var import_js_iden3_core4 = require("@iden3/js-iden3-core");

// src/witness_calculator.ts
async function witnessBuilder(code, options) {
  options = options || {};
  let wasmModule;
  try {
    wasmModule = await WebAssembly.compile(code);
  } catch (err) {
    throw new Error(err);
  }
  let errStr = "";
  let msgStr = "";
  const instance = await WebAssembly.instantiate(wasmModule, {
    runtime: {
      exceptionHandler: function(code2) {
        let err;
        if (code2 == 1) {
          err = "Signal not found.\n";
        } else if (code2 == 2) {
          err = "Too many signals set.\n";
        } else if (code2 == 3) {
          err = "Signal already set.\n";
        } else if (code2 == 4) {
          err = "Assert Failed.\n";
        } else if (code2 == 5) {
          err = "Not enough memory.\n";
        } else if (code2 == 6) {
          err = "Input signal array access exceeds the size.\n";
        } else {
          err = "Unknown error.\n";
        }
        throw new Error(err + errStr);
      },
      printErrorMessage: function() {
        errStr += getMessage() + "\n";
      },
      writeBufferMessage: function() {
        const msg = getMessage();
        if (msg === "\n") {
          msgStr = "";
        } else {
          if (msgStr !== "") {
            msgStr += " ";
          }
          msgStr += msg;
        }
      },
      showSharedRWMemory: function() {
        printSharedRWMemory();
      }
    }
  });
  const sanityCheck = options;
  const wc = new WitnessCalculator(instance, sanityCheck);
  return wc;
  function getMessage() {
    let message = "";
    let c = instance.exports.getMessageChar();
    while (c != 0) {
      message += String.fromCharCode(c);
      c = instance.exports.getMessageChar();
    }
    return message;
  }
  function printSharedRWMemory() {
    const shared_rw_memory_size = instance.exports.getFieldNumLen32();
    const arr = new Uint32Array(shared_rw_memory_size);
    for (let j = 0; j < shared_rw_memory_size; j++) {
      arr[shared_rw_memory_size - 1 - j] = instance.exports.readSharedRWMemory(j);
    }
    if (msgStr !== "") {
      msgStr += " ";
    }
    msgStr += fromArray32(arr).toString();
  }
}
var WitnessCalculator = class {
  constructor(instance, sanityCheck) {
    this.instance = instance;
    this.instance = instance;
    this.version = this.instance.exports.getVersion();
    this.n32 = this.instance.exports.getFieldNumLen32();
    this.instance.exports.getRawPrime();
    const arr = new Uint32Array(this.n32);
    for (let i = 0; i < this.n32; i++) {
      arr[this.n32 - 1 - i] = this.instance.exports.readSharedRWMemory(i);
    }
    this.prime = fromArray32(arr);
    this.witnessSize = this.instance.exports.getWitnessSize();
    this.sanityCheck = sanityCheck;
  }
  version;
  n32;
  prime;
  witnessSize;
  sanityCheck;
  circom_version() {
    return this.instance.exports.getVersion();
  }
  async _doCalculateWitness(input, sanityCheck) {
    this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
    const keys = Object.keys(input);
    let input_counter = 0;
    keys.forEach((k) => {
      const h = fnvHash(k);
      const hMSB = parseInt(h.slice(0, 8), 16);
      const hLSB = parseInt(h.slice(8, 16), 16);
      const fArr = flatArray(input[k]);
      const signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);
      if (signalSize < 0) {
        throw new Error(`Signal ${k} not found
`);
      }
      if (fArr.length < signalSize) {
        throw new Error(`Not enough values for input signal ${k}
`);
      }
      if (fArr.length > signalSize) {
        throw new Error(`Too many values for input signal ${k}
`);
      }
      for (let i = 0; i < fArr.length; i++) {
        const arrFr = toArray32(BigInt(fArr[i]) % this.prime, this.n32);
        for (let j = 0; j < this.n32; j++) {
          this.instance.exports.writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);
        }
        try {
          this.instance.exports.setInputSignal(hMSB, hLSB, i);
          input_counter++;
        } catch (err) {
          throw new Error(err);
        }
      }
    });
    if (input_counter < this.instance.exports.getInputSize()) {
      throw new Error(
        `Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`
      );
    }
  }
  async calculateWitness(input, sanityCheck) {
    const w = [];
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const arr = new Uint32Array(this.n32);
      for (let j = 0; j < this.n32; j++) {
        arr[this.n32 - 1 - j] = this.instance.exports.readSharedRWMemory(j);
      }
      w.push(fromArray32(arr));
    }
    return w;
  }
  async calculateBinWitness(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      const pos = i * this.n32;
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
    }
    return buff;
  }
  async calculateWTNSBin(input, sanityCheck) {
    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
    const buff = new Uint8Array(buff32.buffer);
    await this._doCalculateWitness(input, sanityCheck);
    buff[0] = "w".charCodeAt(0);
    buff[1] = "t".charCodeAt(0);
    buff[2] = "n".charCodeAt(0);
    buff[3] = "s".charCodeAt(0);
    buff32[1] = 2;
    buff32[2] = 2;
    buff32[3] = 1;
    const n8 = this.n32 * 4;
    const idSection1length = 8 + n8;
    const idSection1lengthHex = idSection1length.toString(16);
    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
    buff32[6] = n8;
    this.instance.exports.getRawPrime();
    let pos = 7;
    for (let j = 0; j < this.n32; j++) {
      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
    }
    pos += this.n32;
    buff32[pos] = this.witnessSize;
    pos++;
    buff32[pos] = 2;
    pos++;
    const idSection2length = n8 * this.witnessSize;
    const idSection2lengthHex = idSection2length.toString(16);
    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
    pos += 2;
    for (let i = 0; i < this.witnessSize; i++) {
      this.instance.exports.getWitness(i);
      for (let j = 0; j < this.n32; j++) {
        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);
      }
      pos += this.n32;
    }
    return buff;
  }
};
function toArray32(rem, size) {
  const res = [];
  const radix = BigInt(4294967296);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  if (size) {
    let i = size - res.length;
    while (i > 0) {
      res.unshift(0);
      i--;
    }
  }
  return res;
}
function fromArray32(arr) {
  let res = BigInt(0);
  const radix = BigInt(4294967296);
  for (let i = 0; i < arr.length; i++) {
    res = res * radix + BigInt(arr[i]);
  }
  return res;
}
function flatArray(a) {
  const res = [];
  fillArray(res, a);
  return res;
  function fillArray(res2, a2) {
    if (Array.isArray(a2)) {
      for (let i = 0; i < a2.length; i++) {
        fillArray(res2, a2[i]);
      }
    } else {
      res2.push(a2);
    }
  }
}
function fnvHash(str) {
  const uint64_max = BigInt(2) ** BigInt(64);
  let hash2 = BigInt("0xCBF29CE484222325");
  for (let i = 0; i < str.length; i++) {
    hash2 ^= BigInt(str[i].charCodeAt());
    hash2 *= BigInt(1099511628211);
    hash2 %= uint64_max;
  }
  let hashHex = hash2.toString(16);
  const n = 16 - hashHex.length;
  hashHex = "0".repeat(n).concat(hashHex);
  return hashHex;
}

// src/common.ts
var import_snarkjs = require("snarkjs");
var import_js_iden3_core3 = require("@iden3/js-iden3-core");
var import_bn254 = require("@noble/curves/bn254");
var Groth16 = "groth16";
var AuthCircuit = "auth";
var AuthV2Circuit = "authV2";
var textDecoder = new TextDecoder();
var ZERO_BIGINT = BigInt(0);
var Fp2 = import_bn254.bn254.fields.Fp2;
var Fp12 = import_bn254.bn254.fields.Fp12;
async function prove(inputs, provingKey, wasm) {
  const witnessCalculator = await witnessBuilder(wasm);
  const jsonString = new TextDecoder().decode(inputs);
  const parsedData = JSON.parse(jsonString);
  const wtnsBytes = await witnessCalculator.calculateWTNSBin(parsedData, 0);
  const { proof, publicSignals } = await import_snarkjs.groth16.prove(provingKey, wtnsBytes);
  return {
    proof,
    pub_signals: publicSignals
  };
}
var [G1PP, G2PP] = [import_bn254.bn254.G1.ProjectivePoint, import_bn254.bn254.G2.ProjectivePoint];
var toG1 = ([x, y]) => G1PP.fromAffine({ x: BigInt(x), y: BigInt(y) });
var toG2 = ([[x0, y0], [x1, y1]]) => {
  return G2PP.fromAffine({
    x: Fp2.fromBigTuple([BigInt(x0), BigInt(y0)]),
    y: Fp2.fromBigTuple([BigInt(x1), BigInt(y1)])
  });
};
async function verify(messageHash, proof, verificationKey, unmarshall) {
  const outputs = unmarshall(proof.pub_signals);
  if (outputs.challenge !== (0, import_js_iden3_core3.fromBigEndian)(messageHash)) {
    throw new Error("challenge is not equal to message hash");
  }
  const vk = JSON.parse(textDecoder.decode(verificationKey));
  return verifyGroth16Proof(proof, vk);
}
function verifyGroth16Proof(zkp, vk) {
  if (!vk.IC) {
    throw new Error(`verification file doesn't exist for circuit`);
  }
  const { proof, pub_signals } = zkp;
  if (pub_signals.length + 1 !== vk.IC.length) {
    throw new Error(
      `Invalid number of public signals, expected ${vk.IC.length - 1} but got ${pub_signals.length}`
    );
  }
  let cpub = G1PP.ZERO;
  for (let i = 0; i < pub_signals.length; i++) {
    if (BigInt(pub_signals[i]) < ZERO_BIGINT || BigInt(pub_signals[i]) >= import_bn254.bn254.G1.CURVE.n) {
      throw new Error(`Input value is not in the field ${import_bn254.bn254.G1.CURVE.n}`);
    }
    if (BigInt(pub_signals[i]) !== ZERO_BIGINT) {
      const [x, y] = vk.IC[i + 1].map(BigInt);
      cpub = cpub.add(G1PP.fromAffine({ x, y }).multiply(BigInt(pub_signals[i])));
    }
  }
  cpub = cpub.add(toG1(vk.IC[0]));
  const newRes = import_bn254.bn254.pairingBatch([
    { g1: toG1(proof.pi_a).negate(), g2: toG2(proof.pi_b) },
    { g1: cpub, g2: toG2(vk.vk_gamma_2) },
    { g1: toG1(proof.pi_c), g2: toG2(vk.vk_delta_2) },
    { g1: toG1(vk.vk_alpha_1), g2: toG2(vk.vk_beta_2) }
  ]);
  return Fp12.eql(newRes, Fp12.ONE);
}

// src/authGroth16.ts
var ProvingMethodGroth16Auth = class {
  constructor(methodAlg) {
    this.methodAlg = methodAlg;
  }
  get alg() {
    return this.methodAlg.alg;
  }
  get circuitId() {
    return this.methodAlg.circuitId;
  }
  unmarshall(pubsignals) {
    const outputs = {};
    if (pubsignals.length != 3) {
      throw new Error(`invalid number of Output values expected ${3} got ${pubsignals.length}`);
    }
    outputs.challenge = BigInt(pubsignals[0]);
    outputs.userState = BigInt(pubsignals[1]);
    outputs.userId = import_js_iden3_core4.Id.fromBigInt(BigInt(pubsignals[2]));
    return outputs;
  }
  async verify(messageHash, proof, verificationKey) {
    return verify(messageHash, proof, verificationKey, this.unmarshall);
  }
  prove(inputs, provingKey, wasm) {
    return prove(inputs, provingKey, wasm);
  }
};
var provingMethodGroth16AuthInstance = new ProvingMethodGroth16Auth(
  new ProvingMethodAlg(Groth16, AuthCircuit)
);

// src/authV2Groth16.ts
var import_js_iden3_core5 = require("@iden3/js-iden3-core");
var import_js_merkletree = require("@iden3/js-merkletree");
var import_ffjavascript = require("ffjavascript");
var AuthV2Groth16Alg = new ProvingMethodAlg(Groth16, AuthV2Circuit);
var ProvingMethodGroth16AuthV2 = class _ProvingMethodGroth16AuthV2 {
  constructor(methodAlg) {
    this.methodAlg = methodAlg;
  }
  static curveName = "bn128";
  get alg() {
    return this.methodAlg.alg;
  }
  get circuitId() {
    return this.methodAlg.circuitId;
  }
  async verify(messageHash, proof, verificationKey) {
    return verify(messageHash, proof, verificationKey, this.unmarshall);
  }
  async prove(inputs, provingKey, wasm) {
    const zkProof = await prove(inputs, provingKey, wasm);
    await this.terminateCurve();
    return zkProof;
  }
  async terminateCurve() {
    const curve = await (0, import_ffjavascript.getCurveFromName)(_ProvingMethodGroth16AuthV2.curveName);
    curve.terminate();
  }
  unmarshall(pubSignals) {
    const len = 3;
    if (pubSignals.length !== len) {
      throw new Error(`invalid number of Output values expected ${len} got ${pubSignals.length}`);
    }
    return {
      userID: import_js_iden3_core5.Id.fromBigInt(BigInt(pubSignals[0])),
      challenge: BigInt(pubSignals[1]),
      GISTRoot: import_js_merkletree.Hash.fromString(pubSignals[2])
    };
  }
};
var provingMethodGroth16AuthV2Instance = new ProvingMethodGroth16AuthV2(
  new ProvingMethodAlg(Groth16, AuthV2Circuit)
);

// src/index.ts
registerProvingMethod(
  provingMethodGroth16AuthInstance.methodAlg,
  () => provingMethodGroth16AuthInstance
);
registerProvingMethod(
  provingMethodGroth16AuthV2Instance.methodAlg,
  () => provingMethodGroth16AuthV2Instance
);
var proving = {
  registerProvingMethod,
  getProvingMethod,
  provingMethodGroth16AuthInstance,
  provingMethodGroth16AuthV2Instance
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Header,
  ProvingMethodAlg,
  Token,
  hash,
  proving,
  verifyGroth16Proof,
  witnessBuilder
});
//# sourceMappingURL=index.cjs.map
