{
  "version": 3,
  "sources": ["../../../src/hash.ts", "../../../src/proving.ts", "../../../src/jwz.ts", "../../../src/authGroth16.ts", "../../../src/witness_calculator.ts", "../../../src/common.ts", "../../../src/authV2Groth16.ts", "../../../src/index.ts"],
  "sourcesContent": ["import { fromBigEndian } from '@iden3/js-iden3-core';\nimport { poseidon, sha256 } from '@iden3/js-crypto';\n// Q is the order of the integer field (Zq) that fits inside the SNARK.\nexport const qString =\n  '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport function hash(message: Uint8Array): bigint {\n  // 1. sha256 hash\n  const hashBytes = sha256(message);\n\n  // 2. swap hash before hashing\n  const bi = fromBigEndian(hashBytes.reverse());\n\n  let m = BigInt(0);\n  if (checkBigIntInField(bi)) {\n    m = bi;\n  } else {\n    m = bi % BigInt(qString);\n  }\n\n  return poseidon.hash([m]);\n}\n\n// checkBigIntInField checks if given *big.Int fits in a Field Q element\nexport function checkBigIntInField(a: bigint): boolean {\n  return a < BigInt(qString);\n}\n", "export interface ZKProof {\n  proof: ProofData;\n  pub_signals: string[];\n}\nexport interface ProofData {\n  pi_a: string[];\n  pi_b: string[][];\n  pi_c: string[];\n  protocol: string;\n}\n\nexport class ProvingMethodAlg {\n  constructor(public readonly alg: string, public readonly circuitId: string) {}\n\n  toString(): string {\n    return `${this.alg}:${this.circuitId}`;\n  }\n}\n\nconst provingMethods = new Map<string, () => ProvingMethod>(); // map[string]func() ProvingMethod{}\n\n// ProvingMethod can be used add new methods for signing or verifying tokens.\nexport interface ProvingMethod {\n  // Returns true if proof is valid\n  verify(messageHash: Uint8Array, proof: ZKProof, verificationKey: Uint8Array): Promise<boolean>;\n  // Returns proof or error\n  prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof>;\n\n  readonly methodAlg: ProvingMethodAlg;\n\n  readonly alg: string;\n  // Returns the alg identifier for this method (example: 'AUTH-GROTH-16')\n  readonly circuitId: string;\n}\n\n// RegisterProvingMethod registers the \"alg\" name and a factory function for proving method.\n// This is typically done during init() in the method's implementation\nexport function registerProvingMethod(\n  alg: ProvingMethodAlg,\n  f: () => ProvingMethod\n): Promise<void> {\n  return new Promise((res) => {\n    provingMethods.set(alg.toString(), f);\n    res();\n  });\n}\n\n// GetProvingMethod retrieves a proving method from an \"alg\" string\nexport function getProvingMethod(alg: ProvingMethodAlg): Promise<ProvingMethod> {\n  return new Promise((res, rej) => {\n    const func = provingMethods.get(alg.toString());\n    if (func) {\n      const method: ProvingMethod = func();\n      res(method);\n    } else {\n      rej('unknown alg');\n    }\n  });\n}\n\nexport function getAlgorithms(): Promise<string[]> {\n  return Promise.resolve(Array.from(provingMethods.keys()).map((k) => k.split(':')[0]));\n}\n\n// ProofInputsPreparerHandlerFunc prepares inputs using hash message and circuit id\nexport type ProofInputsPreparerHandlerFunc = (\n  hash: Uint8Array,\n  circuitId: string\n) => Promise<Uint8Array>;\n\n// Prepare function is responsible to call provided handler for inputs preparation\nexport function prepare(\n  f: ProofInputsPreparerHandlerFunc,\n  hash: Uint8Array,\n  circuitId: string\n): Promise<Uint8Array> {\n  return f(hash, circuitId);\n}\n", "import { hash } from './hash';\nimport {\n  ZKProof,\n  ProvingMethod,\n  ProvingMethodAlg,\n  ProofInputsPreparerHandlerFunc,\n  getProvingMethod,\n  prepare\n} from './proving';\n\nimport { base64url as base64 } from 'rfc4648';\nimport { toBigEndian } from '@iden3/js-iden3-core';\n\nexport enum Header {\n  Type = 'typ',\n  Alg = 'alg',\n  CircuitId = 'circuitId',\n  Critical = 'crit'\n}\n\nexport interface IRawJSONWebZeroknowledge {\n  payload: Uint8Array;\n  protectedHeaders: Uint8Array;\n  header: { [key: string]: unknown };\n  zkp: Uint8Array;\n\n  sanitized(): Promise<Token>;\n}\n\nexport class RawJSONWebZeroknowledge implements IRawJSONWebZeroknowledge {\n  constructor(\n    public payload: Uint8Array,\n    public protectedHeaders: Uint8Array,\n    public header: { [key: string]: unknown },\n    public zkp: Uint8Array\n  ) {}\n\n  async sanitized(): Promise<Token> {\n    if (!this.payload) {\n      throw new Error('iden3/js-jwz: missing payload in JWZ message');\n    }\n\n    const headers: { [key: string]: unknown } = JSON.parse(\n      new TextDecoder().decode(this.protectedHeaders)\n    );\n    const criticalHeaders = headers[Header.Critical] as string[];\n    criticalHeaders.forEach((key: string) => {\n      if (!headers[key]) {\n        throw new Error(`iden3/js-jwz: header is listed in critical ${key}, but not presented`);\n      }\n    });\n\n    const alg = headers[Header.Alg] as string;\n    const circuitId = headers[Header.CircuitId] as string;\n\n    const method = await getProvingMethod(new ProvingMethodAlg(alg, circuitId));\n    const zkp = JSON.parse(new TextDecoder().decode(this.zkp));\n    const token = new Token(method, new TextDecoder().decode(this.payload));\n    token.alg = alg;\n    token.circuitId = circuitId;\n    token.zkProof = zkp;\n    for (const [key, value] of Object.entries(headers)) {\n      token.setHeader(key, value);\n    }\n\n    return token;\n  }\n}\n\n// Token represents a JWZ Token.\nexport class Token {\n  public alg: string;\n  public circuitId: string;\n  private raw: IRawJSONWebZeroknowledge;\n  public zkProof: ZKProof = {} as ZKProof;\n\n  constructor(\n    public readonly method: ProvingMethod,\n    payload: string,\n    private readonly inputsPreparer?: ProofInputsPreparerHandlerFunc\n  ) {\n    this.alg = this.method.alg;\n    this.circuitId = this.method.circuitId;\n    this.raw = {} as IRawJSONWebZeroknowledge;\n    this.raw.header = this.getDefaultHeaders();\n\n    this.raw.payload = new TextEncoder().encode(payload);\n  }\n\n  public setHeader(key: string, value: unknown): void {\n    this.raw.header[key] = value;\n  }\n\n  public getPayload(): string {\n    return new TextDecoder().decode(this.raw.payload);\n  }\n\n  private getDefaultHeaders(): { [key: string]: string | string[] } {\n    return {\n      [Header.Alg]: this.alg,\n      [Header.Critical]: [Header.CircuitId],\n      [Header.CircuitId]: this.circuitId,\n      [Header.Type]: 'JWZ'\n    };\n  }\n\n  // Parse parses a jwz message in compact or full serialization format.\n  static parse(tokenStr: string): Promise<Token> {\n    // Parse parses a jwz message in compact or full serialization format.\n    const token = tokenStr?.trim();\n    return token.startsWith('{') ? Token.parseFull(tokenStr) : Token.parseCompact(tokenStr);\n  }\n\n  // parseCompact parses a message in compact format.\n  private static async parseCompact(tokenStr: string): Promise<Token> {\n    const parts = tokenStr.split('.');\n    if (parts.length != 3) {\n      throw new Error('iden3/js-jwz: compact JWZ format must have three segments');\n    }\n    const rawProtected = base64.parse(parts[0], { loose: true });\n\n    const rawPayload = base64.parse(parts[1], { loose: true });\n\n    const proof = base64.parse(parts[2], { loose: true });\n\n    const raw: IRawJSONWebZeroknowledge = new RawJSONWebZeroknowledge(\n      rawPayload,\n      rawProtected,\n      {},\n      proof\n    );\n\n    return await raw.sanitized();\n  }\n\n  // parseFull parses a message in full format.\n  private static async parseFull(tokenStr: string): Promise<Token> {\n    const raw: IRawJSONWebZeroknowledge = JSON.parse(tokenStr);\n    return await raw.sanitized();\n  }\n\n  // Prove creates and returns a complete, proved JWZ.\n  // The token is proven using the Proving Method specified in the token.\n  async prove(provingKey: Uint8Array, wasm: Uint8Array): Promise<string> {\n    // all headers must be protected\n    const headers = this.serializeHeaders();\n\n    this.raw.protectedHeaders = new TextEncoder().encode(headers);\n\n    const msgHash: Uint8Array = await this.getMessageHash();\n\n    if (!this.inputsPreparer) {\n      throw new Error('iden3/jwz: prepare func must be defined');\n    }\n    const inputs: Uint8Array = await prepare(this.inputsPreparer, msgHash, this.circuitId);\n\n    const proof: ZKProof = await this.method.prove(inputs, provingKey, wasm);\n\n    const marshaledProof = JSON.stringify(proof);\n\n    this.zkProof = proof;\n    this.raw.zkp = new TextEncoder().encode(marshaledProof);\n\n    return this.compactSerialize();\n  }\n\n  // CompactSerialize returns token serialized in three parts: base64 encoded headers, payload and proof.\n  compactSerialize(): string {\n    if (!this.raw.header || !this.raw.protectedHeaders || !this.zkProof) {\n      throw new Error(\"iden3/jwz:can't serialize without one of components\");\n    }\n\n    const serializedProtected = base64.stringify(this.raw.protectedHeaders, {\n      pad: false\n    });\n    const serializedProof = base64.stringify(this.raw.zkp, { pad: false });\n    const serializedPayload = base64.stringify(this.raw.payload, {\n      pad: false\n    });\n    return `${serializedProtected}.${serializedPayload}.${serializedProof}`;\n  }\n\n  // fullSerialize returns marshaled presentation of raw token as json string.\n  fullSerialize(): string {\n    return JSON.stringify(this.raw);\n  }\n\n  async getMessageHash(): Promise<Uint8Array> {\n    const serializedHeadersJSON = this.serializeHeaders();\n\n    const serializedHeaders = new TextEncoder().encode(serializedHeadersJSON);\n    const protectedHeaders = base64.stringify(serializedHeaders, {\n      pad: false\n    });\n\n    const payload = base64.stringify(this.raw.payload, { pad: false });\n\n    // JWZ ZkProof input value is ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)).\n    const messageToProof = new TextEncoder().encode(`${protectedHeaders}.${payload}`);\n\n    const hashInt: bigint = await hash(messageToProof);\n\n    return toBigEndian(hashInt, 32);\n  }\n\n  // Verify  perform zero knowledge verification.\n  async verify(verificationKey: Uint8Array): Promise<boolean> {\n    // 1. prepare hash o payload message that had to be proven\n    const msgHash = await this.getMessageHash();\n\n    // 2. verify that zkp is valid\n\n    return this.method.verify(msgHash, this.zkProof, verificationKey);\n  }\n\n  serializeHeaders() {\n    return JSON.stringify(this.raw.header, Object.keys(this.raw.header).sort());\n  }\n}\n", "import { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { Id } from '@iden3/js-iden3-core';\nimport { AuthCircuit, Groth16, prove, verify } from './common';\n\n// AuthPubSignals auth.circom public signals\ninterface AuthPubSignals {\n  challenge: bigint;\n  userState: bigint;\n  userId: Id;\n}\n\n// ProvingMethodGroth16Auth defines proofs family and specific circuit\nclass ProvingMethodGroth16Auth implements ProvingMethod {\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  unmarshall(pubsignals: string[]): AuthPubSignals {\n    const outputs: AuthPubSignals = {} as AuthPubSignals;\n    if (pubsignals.length != 3) {\n      throw new Error(`invalid number of Output values expected ${3} got ${pubsignals.length}`);\n    }\n    outputs.challenge = BigInt(pubsignals[0]);\n    outputs.userState = BigInt(pubsignals[1]);\n    outputs.userId = Id.fromBigInt(BigInt(pubsignals[2]));\n\n    return outputs;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array\n  ): Promise<boolean> {\n    return verify<AuthPubSignals>(messageHash, proof, verificationKey, this.unmarshall);\n  }\n\n  prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof> {\n    return prove(inputs, provingKey, wasm);\n  }\n}\n\nexport const provingMethodGroth16AuthInstance: ProvingMethod = new ProvingMethodGroth16Auth(\n  new ProvingMethodAlg(Groth16, AuthCircuit)\n);\n", "/* eslint-disable require-await */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport async function witnessBuilder(code: BufferSource, options?: any) {\n  options = options || {};\n\n  let wasmModule;\n  try {\n    wasmModule = await WebAssembly.compile(code);\n  } catch (err: any) {\n    throw new Error(err);\n  }\n\n  let errStr = '';\n  let msgStr = '';\n\n  const instance = await WebAssembly.instantiate(wasmModule, {\n    runtime: {\n      exceptionHandler: function (code: number) {\n        let err;\n        if (code == 1) {\n          err = 'Signal not found.\\n';\n        } else if (code == 2) {\n          err = 'Too many signals set.\\n';\n        } else if (code == 3) {\n          err = 'Signal already set.\\n';\n        } else if (code == 4) {\n          err = 'Assert Failed.\\n';\n        } else if (code == 5) {\n          err = 'Not enough memory.\\n';\n        } else if (code == 6) {\n          err = 'Input signal array access exceeds the size.\\n';\n        } else {\n          err = 'Unknown error.\\n';\n        }\n        throw new Error(err + errStr);\n      },\n      printErrorMessage: function () {\n        errStr += getMessage() + '\\n';\n      },\n      writeBufferMessage: function () {\n        const msg = getMessage();\n        // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n        if (msg === '\\n') {\n          msgStr = '';\n        } else {\n          // If we've buffered other content, put a space in between the items\n          if (msgStr !== '') {\n            msgStr += ' ';\n          }\n          // Then append the message to the message we are creating\n          msgStr += msg;\n        }\n      },\n      showSharedRWMemory: function () {\n        printSharedRWMemory();\n      }\n    }\n  });\n\n  const sanityCheck = options;\n\n  const wc = new WitnessCalculator(instance, sanityCheck);\n  return wc;\n\n  function getMessage() {\n    let message = '';\n    let c = (instance as any).exports.getMessageChar();\n    while (c != 0) {\n      message += String.fromCharCode(c);\n      c = (instance as any).exports.getMessageChar();\n    }\n    return message;\n  }\n\n  function printSharedRWMemory() {\n    const shared_rw_memory_size = (instance as any).exports.getFieldNumLen32();\n    const arr = new Uint32Array(shared_rw_memory_size);\n    for (let j = 0; j < shared_rw_memory_size; j++) {\n      arr[shared_rw_memory_size - 1 - j] = (instance as any).exports.readSharedRWMemory(j);\n    }\n\n    // If we've buffered other content, put a space in between the items\n    if (msgStr !== '') {\n      msgStr += ' ';\n    }\n    // Then append the value to the message we are creating\n    msgStr += fromArray32(arr).toString();\n  }\n}\n\nclass WitnessCalculator {\n  version: any;\n  n32: any;\n  prime: any;\n  witnessSize: any;\n  sanityCheck: any;\n  constructor(private instance: any, sanityCheck: any) {\n    this.instance = instance;\n    this.version = (this.instance.exports as any).getVersion();\n    this.n32 = (this.instance.exports as any).getFieldNumLen32();\n\n    (this.instance.exports as any).getRawPrime();\n    const arr = new Uint32Array(this.n32);\n    for (let i = 0; i < this.n32; i++) {\n      arr[this.n32 - 1 - i] = (this.instance.exports as any).readSharedRWMemory(i);\n    }\n    this.prime = fromArray32(arr);\n\n    this.witnessSize = (this.instance.exports as any).getWitnessSize();\n\n    this.sanityCheck = sanityCheck;\n  }\n\n  circom_version() {\n    return (this.instance.exports as any).getVersion();\n  }\n\n  async _doCalculateWitness(input: any, sanityCheck: any) {\n    //input is assumed to be a map from signals to arrays of bigints\n    (this.instance.exports as any).init(this.sanityCheck || sanityCheck ? 1 : 0);\n    const keys = Object.keys(input);\n    let input_counter = 0;\n    keys.forEach((k) => {\n      const h = fnvHash(k);\n      const hMSB = parseInt(h.slice(0, 8), 16);\n      const hLSB = parseInt(h.slice(8, 16), 16);\n      const fArr = flatArray(input[k]);\n      const signalSize = (this.instance.exports as any).getInputSignalSize(hMSB, hLSB);\n      if (signalSize < 0) {\n        throw new Error(`Signal ${k} not found\\n`);\n      }\n      if (fArr.length < signalSize) {\n        throw new Error(`Not enough values for input signal ${k}\\n`);\n      }\n      if (fArr.length > signalSize) {\n        throw new Error(`Too many values for input signal ${k}\\n`);\n      }\n      for (let i = 0; i < fArr.length; i++) {\n        const arrFr = toArray32(BigInt(fArr[i]) % this.prime, this.n32);\n        for (let j = 0; j < this.n32; j++) {\n          (this.instance.exports as any).writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n        }\n        try {\n          (this.instance.exports as any).setInputSignal(hMSB, hLSB, i);\n          input_counter++;\n        } catch (err: any) {\n          // console.log(`After adding signal ${i} of ${k}`)\n          throw new Error(err);\n        }\n      }\n    });\n    if (input_counter < (this.instance.exports as any).getInputSize()) {\n      throw new Error(\n        `Not all inputs have been set. Only ${input_counter} out of ${(\n          this.instance.exports as any\n        ).getInputSize()}`\n      );\n    }\n  }\n\n  async calculateWitness(input: any, sanityCheck: any) {\n    const w = [];\n\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const arr = new Uint32Array(this.n32);\n      for (let j = 0; j < this.n32; j++) {\n        arr[this.n32 - 1 - j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n      w.push(fromArray32(arr));\n    }\n\n    return w;\n  }\n\n  async calculateBinWitness(input: any, sanityCheck: any) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const pos = i * this.n32;\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n    }\n\n    return buff;\n  }\n\n  async calculateWTNSBin(input: any, sanityCheck: any) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    //\"wtns\"\n    buff[0] = 'w'.charCodeAt(0);\n    buff[1] = 't'.charCodeAt(0);\n    buff[2] = 'n'.charCodeAt(0);\n    buff[3] = 's'.charCodeAt(0);\n\n    //version 2\n    buff32[1] = 2;\n\n    //number of sections: 2\n    buff32[2] = 2;\n\n    //id section 1\n    buff32[3] = 1;\n\n    const n8 = this.n32 * 4;\n    //id section 1 length in 64bytes\n    const idSection1length = 8 + n8;\n    const idSection1lengthHex = idSection1length.toString(16);\n    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n    //this.n32\n    buff32[6] = n8;\n\n    //prime number\n    this.instance.exports.getRawPrime();\n\n    let pos = 7;\n    for (let j = 0; j < this.n32; j++) {\n      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n    }\n    pos += this.n32;\n\n    // witness size\n    buff32[pos] = this.witnessSize;\n    pos++;\n\n    //id section 2\n    buff32[pos] = 2;\n    pos++;\n\n    // section 2 length\n    const idSection2length = n8 * this.witnessSize;\n    const idSection2lengthHex = idSection2length.toString(16);\n    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n    pos += 2;\n    for (let i = 0; i < this.witnessSize; i++) {\n      this.instance.exports.getWitness(i);\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n      }\n      pos += this.n32;\n    }\n\n    return buff;\n  }\n}\n\nfunction toArray32(rem: bigint, size: number) {\n  const res = []; //new Uint32Array(size); //has no unshift\n  const radix = BigInt(0x100000000);\n  while (rem) {\n    res.unshift(Number(rem % radix));\n    rem = rem / radix;\n  }\n  if (size) {\n    let i = size - res.length;\n    while (i > 0) {\n      res.unshift(0);\n      i--;\n    }\n  }\n  return res;\n}\n\nfunction fromArray32(arr: Uint32Array) {\n  //returns a BigInt\n  let res = BigInt(0);\n  const radix = BigInt(0x100000000);\n  for (let i = 0; i < arr.length; i++) {\n    res = res * radix + BigInt(arr[i]);\n  }\n  return res;\n}\n\nfunction flatArray(a: any[]) {\n  const res: any[] = [];\n  fillArray(res, a);\n  return res;\n\n  function fillArray(res: any[], a: any[]) {\n    if (Array.isArray(a)) {\n      for (let i = 0; i < a.length; i++) {\n        fillArray(res, a[i]);\n      }\n    } else {\n      res.push(a);\n    }\n  }\n}\n\nfunction fnvHash(str: any) {\n  const uint64_max = BigInt(2) ** BigInt(64);\n  let hash = BigInt('0xCBF29CE484222325');\n  for (let i = 0; i < str.length; i++) {\n    hash ^= BigInt(str[i].charCodeAt());\n    hash *= BigInt(0x100000001b3);\n    hash %= uint64_max;\n  }\n  let hashHex = hash.toString(16);\n  const n = 16 - hashHex.length;\n  hashHex = '0'.repeat(n).concat(hashHex);\n  return hashHex;\n}\n", "import { ZKProof } from './proving';\nimport { witnessBuilder } from './witness_calculator';\nimport { groth16 } from 'snarkjs';\nimport { fromBigEndian } from '@iden3/js-iden3-core';\nimport { bn254 } from '@noble/curves/bn254';\n\nexport const Groth16 = 'groth16';\nexport const AuthCircuit = 'auth';\nexport const AuthV2Circuit = 'authV2';\nconst textDecoder = new TextDecoder();\nconst ZERO_BIGINT = BigInt(0);\n\nconst Fp2 = bn254.fields.Fp2;\nconst Fp12 = bn254.fields.Fp12;\n\nexport type Groth16VerificationKey = {\n  protocol: 'groth16';\n  curve: 'bn128';\n  nPublic: number;\n  vk_alpha_1: [string, string, string];\n  vk_beta_2: [[string, string], [string, string], [string, string]];\n  vk_gamma_2: [[string, string], [string, string], [string, string]];\n  vk_delta_2: [[string, string], [string, string], [string, string]];\n  vk_alphabeta_12: [\n    [[string, string], [string, string], [string, string]],\n    [[string, string], [string, string], [string, string]]\n  ];\n  IC: [string, string, string][];\n};\n\nexport async function prove(\n  inputs: Uint8Array,\n  provingKey: Uint8Array,\n  wasm: Uint8Array\n): Promise<ZKProof> {\n  const witnessCalculator = await witnessBuilder(wasm);\n\n  const jsonString = new TextDecoder().decode(inputs);\n\n  const parsedData = JSON.parse(jsonString);\n  const wtnsBytes: Uint8Array = await witnessCalculator.calculateWTNSBin(parsedData, 0);\n\n  const { proof, publicSignals } = await groth16.prove(provingKey, wtnsBytes);\n\n  return {\n    proof: proof,\n    pub_signals: publicSignals\n  };\n}\n\nconst [G1PP, G2PP] = [bn254.G1.ProjectivePoint, bn254.G2.ProjectivePoint];\n\nconst toG1 = ([x, y]: string[]) => G1PP.fromAffine({ x: BigInt(x), y: BigInt(y) });\n\nconst toG2 = ([[x0, y0], [x1, y1]]: string[][]) => {\n  return G2PP.fromAffine({\n    x: Fp2.fromBigTuple([BigInt(x0), BigInt(y0)]),\n    y: Fp2.fromBigTuple([BigInt(x1), BigInt(y1)])\n  });\n};\n\nexport async function verify<T extends { challenge: bigint }>(\n  messageHash: Uint8Array,\n  proof: ZKProof,\n  verificationKey: Uint8Array,\n  unmarshall: (pubSignals: string[]) => T\n): Promise<boolean> {\n  const outputs: T = unmarshall(proof.pub_signals);\n  if (outputs.challenge !== fromBigEndian(messageHash)) {\n    throw new Error('challenge is not equal to message hash');\n  }\n\n  const vk: Groth16VerificationKey = JSON.parse(textDecoder.decode(verificationKey));\n\n  return verifyGroth16Proof(proof, vk);\n}\n\nexport function verifyGroth16Proof(zkp: ZKProof, vk: Groth16VerificationKey): boolean {\n  if (!vk.IC) {\n    throw new Error(`verification file doesn't exist for circuit`);\n  }\n  const { proof, pub_signals } = zkp;\n\n  if (pub_signals.length + 1 !== vk.IC.length) {\n    throw new Error(\n      `Invalid number of public signals, expected ${vk.IC.length - 1} but got ${pub_signals.length}`\n    );\n  }\n\n  let cpub = G1PP.ZERO;\n\n  for (let i = 0; i < pub_signals.length; i++) {\n    // check input inside field\n    if (BigInt(pub_signals[i]) < ZERO_BIGINT || BigInt(pub_signals[i]) >= bn254.G1.CURVE.n) {\n      throw new Error(`Input value is not in the field ${bn254.G1.CURVE.n}`);\n    }\n    // Skip multiplication by 0 since it contributes nothing to the sum\n    if (BigInt(pub_signals[i]) !== ZERO_BIGINT) {\n      const [x, y] = vk.IC[i + 1].map(BigInt);\n      cpub = cpub.add(G1PP.fromAffine({ x, y }).multiply(BigInt(pub_signals[i])));\n    }\n  }\n  cpub = cpub.add(toG1(vk.IC[0]));\n\n  const newRes = bn254.pairingBatch([\n    { g1: toG1(proof.pi_a).negate(), g2: toG2(proof.pi_b) },\n    { g1: cpub, g2: toG2(vk.vk_gamma_2) },\n    { g1: toG1(proof.pi_c), g2: toG2(vk.vk_delta_2) },\n    { g1: toG1(vk.vk_alpha_1), g2: toG2(vk.vk_beta_2) }\n  ]);\n\n  return Fp12.eql(newRes, Fp12.ONE);\n}\n", "import { Id } from '@iden3/js-iden3-core';\nimport { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { AuthV2Circuit, Groth16, prove, verify } from './common';\nimport { Hash } from '@iden3/js-merkletree';\nimport { getCurveFromName } from 'ffjavascript';\n\n// AuthV2PubSignals auth.circom public signals\nexport interface AuthV2PubSignals {\n  userID: Id;\n  challenge: bigint;\n  GISTRoot: Hash;\n}\n\nexport const AuthV2Groth16Alg = new ProvingMethodAlg(Groth16, AuthV2Circuit);\n\n// ProvingMethodGroth16AuthV2 instance for Groth16 proving method with an authV2 circuit\nexport class ProvingMethodGroth16AuthV2 implements ProvingMethod {\n  private static readonly curveName = 'bn128';\n\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array\n  ): Promise<boolean> {\n    return verify<AuthV2PubSignals>(messageHash, proof, verificationKey, this.unmarshall);\n  }\n\n  async prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof> {\n    const zkProof = await prove(inputs, provingKey, wasm);\n    await this.terminateCurve();\n    return zkProof;\n  }\n\n  private async terminateCurve(): Promise<void> {\n    const curve = await getCurveFromName(ProvingMethodGroth16AuthV2.curveName);\n    curve.terminate();\n  }\n\n  unmarshall(pubSignals: string[]): AuthV2PubSignals {\n    const len = 3;\n\n    if (pubSignals.length !== len) {\n      throw new Error(`invalid number of Output values expected ${len} got ${pubSignals.length}`);\n    }\n\n    return {\n      userID: Id.fromBigInt(BigInt(pubSignals[0])),\n      challenge: BigInt(pubSignals[1]),\n      GISTRoot: Hash.fromString(pubSignals[2])\n    };\n  }\n}\n\nexport const provingMethodGroth16AuthV2Instance: ProvingMethod = new ProvingMethodGroth16AuthV2(\n  new ProvingMethodAlg(Groth16, AuthV2Circuit)\n);\n", "import { hash } from './hash';\nimport { Token, Header } from './jwz';\nimport { provingMethodGroth16AuthInstance } from './authGroth16';\nimport {\n  getProvingMethod,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  registerProvingMethod,\n  ZKProof,\n  ProofData\n} from './proving';\nimport { provingMethodGroth16AuthV2Instance } from './authV2Groth16';\nimport { Groth16VerificationKey, verifyGroth16Proof } from './common';\nimport { witnessBuilder } from './witness_calculator';\n\nregisterProvingMethod(\n  provingMethodGroth16AuthInstance.methodAlg,\n  () => provingMethodGroth16AuthInstance\n);\n\nregisterProvingMethod(\n  provingMethodGroth16AuthV2Instance.methodAlg,\n  () => provingMethodGroth16AuthV2Instance\n);\n\nconst proving = {\n  registerProvingMethod,\n  getProvingMethod,\n  provingMethodGroth16AuthInstance,\n  provingMethodGroth16AuthV2Instance\n};\n\nexport {\n  proving,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  Token,\n  hash,\n  ZKProof,\n  ProofData,\n  Header,\n  verifyGroth16Proof,\n  Groth16VerificationKey,\n  witnessBuilder\n};\n"],
  "mappings": "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",
  "names": ["hash", "Header", "code", "res", "a", "hash", "fromBigEndian", "Id", "Id"]
}
