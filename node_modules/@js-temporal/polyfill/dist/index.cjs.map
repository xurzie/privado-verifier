{"version":3,"file":"index.cjs","sources":["../lib/bigintmath.ts","../lib/slots.ts","../lib/intrinsicclass.ts","../lib/math.ts","../lib/timeduration.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/calendar.ts","../lib/intl.ts","../lib/instant.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["import JSBI from 'jsbi';\n\nexport const ZERO = JSBI.BigInt(0);\nexport const ONE = JSBI.BigInt(1);\nexport const TWO = JSBI.BigInt(2);\nexport const TEN = JSBI.BigInt(10);\nconst TWENTY_FOUR = JSBI.BigInt(24);\nconst SIXTY = JSBI.BigInt(60);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst HOUR_SECONDS = 3600;\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\nexport const MINUTE_NANOS_JSBI = JSBI.multiply(SIXTY, BILLION);\nexport const DAY_NANOS_JSBI = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\n\n/** Handle a JSBI or native BigInt. For user input, use ES.ToBigInt instead */\nexport function ensureJSBI(value: JSBI | bigint) {\n  return typeof value === 'bigint' ? JSBI.BigInt(value.toString(10)) : value;\n}\n\nexport function isEven(value: JSBI): boolean {\n  return JSBI.equal(JSBI.remainder(value, TWO), ZERO);\n}\n\nexport function abs(x: JSBI): JSBI {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.unaryMinus(x);\n  return x;\n}\n\nexport function compare(x: JSBI, y: JSBI): -1 | 0 | 1 {\n  return JSBI.lessThan(x, y) ? -1 : JSBI.greaterThan(x, y) ? 1 : 0;\n}\n\nexport function divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return { quotient, remainder };\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  AnySlottedType,\n  FormatterOrAmender,\n  ISODate,\n  ISODateTime,\n  TimeRecord\n} from './internaltypes';\nimport type { DateTimeFormatImpl } from './intl';\n\n// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_DATE = 'slot-iso-date';\nexport const ISO_DATE_TIME = 'slot-iso-date-time';\nexport const TIME = 'slot-time';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n\n// ZonedDateTime\nexport const TIME_ZONE = 'slot-time-zone';\n\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n\n// DateTimeFormatImpl\nexport const DATE = 'date';\nexport const YM = 'ym';\nexport const MD = 'md';\nexport const TIME_FMT = 'time';\nexport const DATETIME = 'datetime';\nexport const INST = 'instant';\nexport const ORIGINAL = 'original';\nexport const TZ_CANONICAL = 'timezone-canonical';\nexport const TZ_ORIGINAL = 'timezone-original';\nexport const CAL_ID = 'calendar-id';\nexport const LOCALE = 'locale';\nexport const OPTIONS = 'options';\n\ninterface SlotInfo<ValueType, UsedByType extends AnySlottedType> {\n  value: ValueType;\n  usedBy: UsedByType;\n}\n\ninterface SlotInfoRecord {\n  [k: string]: SlotInfo<unknown, AnySlottedType>;\n}\n\ninterface Slots extends SlotInfoRecord {\n  // Instant\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_DATE]: SlotInfo<ISODate, Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth>;\n  [ISO_DATE_TIME]: SlotInfo<ISODateTime, Temporal.PlainDateTime>;\n  [TIME]: SlotInfo<TimeRecord, Temporal.PlainTime>;\n  [CALENDAR]: SlotInfo<BuiltinCalendarId, TypesWithCalendarUnits>;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\n\n  // ZonedDateTime\n  [TIME_ZONE]: SlotInfo<string, Temporal.ZonedDateTime>;\n\n  // Duration\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\n\n  // DateTimeFormatImpl\n  [DATE]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [YM]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [MD]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [TIME_FMT]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [DATETIME]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [INST]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [ORIGINAL]: SlotInfo<globalThis.Intl.DateTimeFormat, DateTimeFormatImpl>;\n  [TZ_CANONICAL]: SlotInfo<string, DateTimeFormatImpl>;\n  [TZ_ORIGINAL]: SlotInfo<string, DateTimeFormatImpl>;\n  [CAL_ID]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'], DateTimeFormatImpl>;\n  [LOCALE]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['locale'], DateTimeFormatImpl>;\n  [OPTIONS]: SlotInfo<Intl.DateTimeFormatOptions, DateTimeFormatImpl>;\n}\n\ntype TypesWithCalendarUnits =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime;\n\ninterface SlotsToTypes {\n  // Instant\n  [EPOCHNANOSECONDS]: Temporal.Instant;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_DATE]: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay;\n  [ISO_DATE_TIME]: Temporal.PlainDateTime;\n  [TIME]: Temporal.PlainTime;\n  [CALENDAR]: TypesWithCalendarUnits;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: Temporal.PlainDate;\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\n\n  // ZonedDateTime\n  [TIME_ZONE]: Temporal.ZonedDateTime;\n\n  // Duration\n  [YEARS]: Temporal.Duration;\n  [MONTHS]: Temporal.Duration;\n  [WEEKS]: Temporal.Duration;\n  [DAYS]: Temporal.Duration;\n  [HOURS]: Temporal.Duration;\n  [MINUTES]: Temporal.Duration;\n  [SECONDS]: Temporal.Duration;\n  [MILLISECONDS]: Temporal.Duration;\n  [MICROSECONDS]: Temporal.Duration;\n  [NANOSECONDS]: Temporal.Duration;\n\n  // DateTimeFormatImpl\n  [DATE]: DateTimeFormatImpl;\n  [YM]: DateTimeFormatImpl;\n  [MD]: DateTimeFormatImpl;\n  [TIME_FMT]: DateTimeFormatImpl;\n  [DATETIME]: DateTimeFormatImpl;\n  [INST]: DateTimeFormatImpl;\n  [ORIGINAL]: DateTimeFormatImpl;\n  [TZ_CANONICAL]: DateTimeFormatImpl;\n  [TZ_ORIGINAL]: DateTimeFormatImpl;\n  [CAL_ID]: DateTimeFormatImpl;\n  [LOCALE]: DateTimeFormatImpl;\n  [OPTIONS]: DateTimeFormatImpl;\n}\n\ntype SlotKey = keyof SlotsToTypes;\n\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\n\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\n  return globalSlots.get(container);\n}\n\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\n\n// expose GetSlots to avoid dual package hazards\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\n\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\n\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\n  globalSlots.set(container, Object.create(null));\n}\n\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\n\n// expose CreateSlots to avoid dual package hazards\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\n\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\n\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\n// guard that takes a variable number of parameters?\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey,\n  ID9 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8,\n  id9: ID9\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container as AnySlottedType);\n  return !!myslots && ids.every((id) => id in myslots);\n}\nexport function GetSlot<KeyT extends keyof Slots>(\n  container: Slots[typeof id]['usedBy'],\n  id: KeyT\n): Slots[KeyT]['value'] {\n  const value = GetSlots(container)?.[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\nexport function SetSlot<KeyT extends SlotKey>(\n  container: Slots[KeyT]['usedBy'],\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot) throw new TypeError(`${id} already has set`);\n\n  slots[id] = value;\n}\n\nexport function ResetSlot<KeyT extends SlotKey>(\n  container: DateTimeFormatImpl,\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot === undefined) throw new TypeError(`tried to reset ${id} which was not set`);\n\n  slots[id] = value;\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { CalendarImpl } from './calendar';\nimport type { BuiltinCalendarId } from './internaltypes';\nimport type { DateTimeFormatImpl } from './intl';\n\nimport { DEBUG } from './debug';\nimport { GetSlot, ORIGINAL } from './slots';\n\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\n\ntype TemporalIntrinsics = {\n  ['Intl.DateTimeFormat']: typeof globalThis.Intl.DateTimeFormat;\n  ['Temporal.Duration']: typeof Temporal.Duration;\n  ['Temporal.Instant']: OmitConstructor<Temporal.Instant> &\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\n  ['Temporal.PlainDate']: typeof Temporal.PlainDate;\n  ['Temporal.PlainDateTime']: typeof Temporal.PlainDateTime;\n  ['Temporal.PlainMonthDay']: typeof Temporal.PlainMonthDay;\n  ['Temporal.PlainTime']: typeof Temporal.PlainTime;\n  ['Temporal.PlainYearMonth']: typeof Temporal.PlainYearMonth;\n  ['Temporal.ZonedDateTime']: OmitConstructor<Temporal.ZonedDateTime> &\n    (new (epochNanoseconds: JSBI, timeZone: string, calendar?: string) => Temporal.ZonedDateTime) & {\n      prototype: typeof Temporal.ZonedDateTime.prototype;\n      from: typeof Temporal.ZonedDateTime.from;\n      compare: typeof Temporal.ZonedDateTime.compare;\n    };\n};\ntype TemporalIntrinsicRegistrations = {\n  [key in keyof TemporalIntrinsics]: TemporalIntrinsics[key];\n};\ntype TemporalIntrinsicPrototypeRegistrations = {\n  [key in keyof TemporalIntrinsics as `${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\n};\ntype TemporalIntrinsicRegisteredKeys = {\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\n};\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\n};\n\ntype OtherIntrinsics = {\n  calendarImpl: (id: BuiltinCalendarId) => CalendarImpl;\n};\ntype OtherIntrinsicKeys = { [key in keyof OtherIntrinsics as `%${key}%`]: OtherIntrinsics[key] };\n\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\n  TemporalIntrinsicPrototypeRegisteredKeys &\n  OtherIntrinsicKeys;\n\ntype StylizeOption = (value: unknown, type: 'number' | 'special') => string;\n\ntype customFormatFunction<T> = (\n  this: T & { _repr_: string }, // _repr_ is present if DEBUG\n  depth: number,\n  options: { stylize: StylizeOption },\n  inspect: (object: T, options?: { depth: number; stylize: StylizeOption }) => string\n) => string;\nconst customUtilInspectFormatters: Partial<{\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\n    InstanceType<TemporalIntrinsicRegistrations[key]>\n  >;\n}> = {\n  ['Intl.DateTimeFormat'](depth, options, inspect) {\n    return inspect(GetSlot(this as DateTimeFormatImpl, ORIGINAL), { depth, ...options });\n  },\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(this._repr_, 'special');\n    if (depth < 1) return descr;\n    const entries: string[] = [];\n    const props = [\n      'years',\n      'months',\n      'weeks',\n      'days',\n      'hours',\n      'minutes',\n      'seconds',\n      'milliseconds',\n      'microseconds',\n      'nanoseconds'\n    ] as const;\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (this[prop] !== 0) {\n        entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n      }\n    }\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n};\n\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\n  return options.stylize(this._repr_, 'special');\n}\n\nexport function MakeIntrinsicClass(\n  Class: TemporalIntrinsicRegistrations[typeof name],\n  name: keyof TemporalIntrinsicRegistrations\n) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  if (DEBUG) {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  const staticNames = Object.getOwnPropertyNames(Class);\n  for (let i = 0; i < staticNames.length; i++) {\n    const prop = staticNames[i];\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n  const protoNames = Object.getOwnPropertyNames(Class.prototype);\n  for (let i = 0; i < protoNames.length; i++) {\n    const prop = protoNames[i];\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\ntype IntrinsicDefinitionKeys =\n  | keyof TemporalIntrinsicRegistrations\n  | keyof TemporalIntrinsicPrototypeRegistrations\n  | keyof OtherIntrinsics;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof OtherIntrinsics>(name: KeyT, value: OtherIntrinsics[KeyT]): void;\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): (typeof INTRINSICS)[KeyT] {\n  return INTRINSICS[intrinsic];\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\n\n// Computes trunc(x / 10**p) and x % 10**p, returning { div, mod }, with\n// precision loss only once in the quotient, by string manipulation. If the\n// quotient and remainder are safe integers, then they are exact. x must be an\n// integer. p must be a non-negative integer. Both div and mod have the sign of\n// x.\nexport function TruncatingDivModByPowerOf10(xParam: number, p: number) {\n  let x = xParam;\n  if (x === 0) return { div: x, mod: x }; // preserves signed zero\n\n  const sign = Math.sign(x);\n  x = Math.abs(x);\n\n  const xDigits = Math.trunc(1 + Math.log10(x));\n  if (p >= xDigits) return { div: sign * 0, mod: sign * x };\n  if (p === 0) return { div: sign * x, mod: sign * 0 };\n\n  // would perform nearest rounding if x was not an integer:\n  const xStr = x.toPrecision(xDigits);\n  const div = sign * Number.parseInt(xStr.slice(0, xDigits - p), 10);\n  const mod = sign * Number.parseInt(xStr.slice(xDigits - p), 10);\n\n  return { div, mod };\n}\n\n// Computes x * 10**p + z with precision loss only at the end, by string\n// manipulation. If the result is a safe integer, then it is exact. x must be\n// an integer. p must be a non-negative integer. z must have the same sign as\n// x and be less than 10**p.\nexport function FMAPowerOf10(xParam: number, p: number, zParam: number) {\n  let x = xParam;\n  let z = zParam;\n  if (x === 0) return z;\n\n  const sign = Math.sign(x) || Math.sign(z);\n  x = Math.abs(x);\n  z = Math.abs(z);\n\n  const xStr = x.toPrecision(Math.trunc(1 + Math.log10(x)));\n\n  if (z === 0) return sign * Number.parseInt(xStr + '0'.repeat(p), 10);\n\n  const zStr = z.toPrecision(Math.trunc(1 + Math.log10(z)));\n\n  const resStr = xStr + zStr.padStart(p, '0');\n  return sign * Number.parseInt(resStr, 10);\n}\n\ntype UnsignedRoundingMode = 'half-even' | 'half-infinity' | 'half-zero' | 'infinity' | 'zero';\n\nexport function GetUnsignedRoundingMode(\n  mode: Temporal.RoundingMode,\n  sign: 'positive' | 'negative'\n): UnsignedRoundingMode {\n  const isNegative = sign === 'negative';\n  switch (mode) {\n    case 'ceil':\n      return isNegative ? 'zero' : 'infinity';\n    case 'floor':\n      return isNegative ? 'infinity' : 'zero';\n    case 'expand':\n      return 'infinity';\n    case 'trunc':\n      return 'zero';\n    case 'halfCeil':\n      return isNegative ? 'half-zero' : 'half-infinity';\n    case 'halfFloor':\n      return isNegative ? 'half-infinity' : 'half-zero';\n    case 'halfExpand':\n      return 'half-infinity';\n    case 'halfTrunc':\n      return 'half-zero';\n    case 'halfEven':\n      return 'half-even';\n  }\n}\n\n// Omits first step from spec algorithm so that it can be used both for\n// RoundNumberToIncrement and RoundTimeDurationToIncrement\nexport function ApplyUnsignedRoundingMode<T extends number | JSBI>(\n  r1: T,\n  r2: T,\n  cmp: -1 | 0 | 1,\n  evenCardinality: boolean,\n  unsignedRoundingMode: UnsignedRoundingMode\n) {\n  if (unsignedRoundingMode === 'zero') return r1;\n  if (unsignedRoundingMode === 'infinity') return r2;\n  if (cmp < 0) return r1;\n  if (cmp > 0) return r2;\n  if (unsignedRoundingMode === 'half-zero') return r1;\n  if (unsignedRoundingMode === 'half-infinity') return r2;\n  return evenCardinality ? r1 : r2;\n}\n","import JSBI from 'jsbi';\n\nimport { assert } from './assert';\nimport {\n  abs,\n  BILLION,\n  compare,\n  DAY_NANOS_JSBI,\n  divmod,\n  ensureJSBI,\n  HOUR_NANOS,\n  isEven,\n  MILLION,\n  MINUTE_NANOS_JSBI,\n  ONE,\n  TEN,\n  THOUSAND,\n  TWO,\n  ZERO\n} from './bigintmath';\nimport { ApplyUnsignedRoundingMode, GetUnsignedRoundingMode } from './math';\nimport type { Temporal } from '..';\n\nexport class TimeDuration {\n  static MAX = JSBI.BigInt('9007199254740991999999999');\n  static ZERO = new TimeDuration(ZERO);\n\n  totalNs: JSBI;\n  sec: number;\n  subsec: number;\n\n  constructor(totalNs: bigint | JSBI) {\n    assert(typeof totalNs !== 'number', 'big integer required');\n    this.totalNs = ensureJSBI(totalNs);\n    assert(JSBI.lessThanOrEqual(abs(this.totalNs), TimeDuration.MAX), 'integer too big');\n\n    this.sec = JSBI.toNumber(JSBI.divide(this.totalNs, BILLION));\n    this.subsec = JSBI.toNumber(JSBI.remainder(this.totalNs, BILLION));\n    assert(Number.isSafeInteger(this.sec), 'seconds too big');\n    assert(Math.abs(this.subsec) <= 999_999_999, 'subseconds too big');\n  }\n\n  static validateNew(totalNs: JSBI, operation: string) {\n    if (JSBI.greaterThan(abs(totalNs), TimeDuration.MAX)) {\n      throw new RangeError(`${operation} of duration time units cannot exceed ${TimeDuration.MAX} s`);\n    }\n    return new TimeDuration(totalNs);\n  }\n\n  static fromEpochNsDiff(epochNs1: JSBI | bigint, epochNs2: JSBI | bigint) {\n    const diff = JSBI.subtract(ensureJSBI(epochNs1), ensureJSBI(epochNs2));\n    // No extra validate step. Should instead fail assertion if too big\n    return new TimeDuration(diff);\n  }\n\n  static fromComponents(h: number, min: number, s: number, ms: number, µs: number, ns: number) {\n    const totalNs = JSBI.add(\n      JSBI.add(\n        JSBI.add(\n          JSBI.add(\n            JSBI.add(JSBI.BigInt(ns), JSBI.multiply(JSBI.BigInt(µs), THOUSAND)),\n            JSBI.multiply(JSBI.BigInt(ms), MILLION)\n          ),\n          JSBI.multiply(JSBI.BigInt(s), BILLION)\n        ),\n        JSBI.multiply(JSBI.BigInt(min), MINUTE_NANOS_JSBI)\n      ),\n      JSBI.multiply(JSBI.BigInt(h), HOUR_NANOS)\n    );\n    return TimeDuration.validateNew(totalNs, 'total');\n  }\n\n  abs() {\n    return new TimeDuration(abs(this.totalNs));\n  }\n\n  add(other: TimeDuration) {\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, other.totalNs), 'sum');\n  }\n\n  add24HourDays(days: number) {\n    assert(Number.isInteger(days), 'days must be an integer');\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, JSBI.multiply(JSBI.BigInt(days), DAY_NANOS_JSBI)), 'sum');\n  }\n\n  addToEpochNs(epochNs: JSBI | bigint) {\n    return JSBI.add(ensureJSBI(epochNs), this.totalNs);\n  }\n\n  cmp(other: TimeDuration) {\n    return compare(this.totalNs, other.totalNs);\n  }\n\n  divmod(n: number) {\n    assert(n !== 0, 'division by zero');\n    const { quotient, remainder } = divmod(this.totalNs, JSBI.BigInt(n));\n    const q = JSBI.toNumber(quotient);\n    const r = new TimeDuration(remainder);\n    return { quotient: q, remainder: r };\n  }\n\n  fdiv(nParam: JSBI | bigint) {\n    const n = ensureJSBI(nParam);\n    assert(!JSBI.equal(n, ZERO), 'division by zero');\n    const nBigInt = JSBI.BigInt(n);\n    let { quotient, remainder } = divmod(this.totalNs, nBigInt);\n\n    // Perform long division to calculate the fractional part of the quotient\n    // remainder / n with more accuracy than 64-bit floating point division\n    const precision = 50;\n    const decimalDigits: number[] = [];\n    let digit;\n    const sign = (JSBI.lessThan(this.totalNs, ZERO) ? -1 : 1) * Math.sign(JSBI.toNumber(n));\n    while (!JSBI.equal(remainder, ZERO) && decimalDigits.length < precision) {\n      remainder = JSBI.multiply(remainder, TEN);\n      ({ quotient: digit, remainder } = divmod(remainder, nBigInt));\n      decimalDigits.push(Math.abs(JSBI.toNumber(digit)));\n    }\n    return sign * Number(abs(quotient).toString() + '.' + decimalDigits.join(''));\n  }\n\n  isZero() {\n    return JSBI.equal(this.totalNs, ZERO);\n  }\n\n  round(incrementParam: JSBI | bigint, mode: Temporal.RoundingMode) {\n    const increment = ensureJSBI(incrementParam);\n    if (JSBI.equal(increment, ONE)) return this;\n    const { quotient, remainder } = divmod(this.totalNs, increment);\n    const sign = JSBI.lessThan(this.totalNs, ZERO) ? 'negative' : 'positive';\n    const r1 = JSBI.multiply(abs(quotient), increment);\n    const r2 = JSBI.add(r1, increment);\n    const cmp = compare(abs(JSBI.multiply(remainder, TWO)), increment);\n    const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\n    const rounded = JSBI.equal(abs(this.totalNs), r1)\n      ? r1\n      : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(quotient), unsignedRoundingMode);\n    const result = sign === 'positive' ? rounded : JSBI.unaryMinus(rounded);\n    return TimeDuration.validateNew(result, 'rounding');\n  }\n\n  sign() {\n    return this.cmp(new TimeDuration(ZERO));\n  }\n\n  subtract(other: TimeDuration) {\n    return TimeDuration.validateNew(JSBI.subtract(this.totalNs, other.totalNs), 'difference');\n  }\n}\n","const offsetIdentifierNoCapture = /(?:[+-](?:[01][0-9]|2[0-3])(?::?[0-5][0-9])?)/;\nconst tzComponent = /[A-Za-z._][A-Za-z._0-9+-]*/;\nexport const timeZoneID = new RegExp(\n  `(?:${offsetIdentifierNoCapture.source}|(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*)`\n);\n\nconst yearpart = /(?:[+-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\n);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offsetWithParts = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /((?:[+-])(?:[01][0-9]|2[0-3])(?::?(?:[0-5][0-9])(?::?(?:[0-5][0-9])(?:[.,](?:\\d{1,9}))?)?)?)/;\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\nexport const offsetIdentifier = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])?)?/;\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\n\nexport const zoneddatetime = new RegExp(\n  [\n    `^${datesplit.source}`,\n    `(?:(?:[tT]|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join('')\n);\n\nexport const time = new RegExp(\n  [\n    `^[tT]?${timesplit.source}`,\n    `(?:${offsetpart.source})?`,\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join('')\n);\n\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\n// annotations are still allowed, and will throw if the calendar annotation is\n// not ISO.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n// UTC offsets are not allowed, because they are not allowed with any date-only\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\nexport const yearmonth = new RegExp(\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\nexport const monthday = new RegExp(\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\n\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\n\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n","import { DEBUG, ENABLE_ASSERTS } from './debug';\nimport JSBI from 'jsbi';\n\nimport type { Temporal } from '..';\nimport { assert, assertNotReached } from './assert';\nimport { abs, compare, DAY_NANOS_JSBI, divmod, ensureJSBI, isEven, MILLION, ONE, TWO, ZERO } from './bigintmath';\nimport type { CalendarImpl } from './calendar';\nimport type {\n  AnyTemporalLikeType,\n  UnitSmallerThanOrEqualTo,\n  InstantParams,\n  PlainMonthDayParams,\n  ZonedDateTimeParams,\n  PlainDateParams,\n  PlainTimeParams,\n  DurationParams,\n  PlainDateTimeParams,\n  PlainYearMonthParams,\n  BuiltinCalendarId,\n  Keys,\n  AnyTemporalKey,\n  FieldKey,\n  InternalDuration,\n  ISODateTime,\n  ISODate,\n  TimeRecord,\n  ISODateToFieldsType,\n  DateDuration,\n  CalendarFieldsRecord,\n  MonthDayFromFieldsObject,\n  Overflow,\n  Resolve,\n  AnySlottedType\n} from './internaltypes';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { ApplyUnsignedRoundingMode, FMAPowerOf10, GetUnsignedRoundingMode, TruncatingDivModByPowerOf10 } from './math';\nimport { TimeDuration } from './timeduration';\nimport {\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot,\n  EPOCHNANOSECONDS,\n  ISO_DATE,\n  ISO_DATE_TIME,\n  TIME,\n  DATE_BRAND,\n  YEAR_MONTH_BRAND,\n  MONTH_DAY_BRAND,\n  TIME_ZONE,\n  CALENDAR,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS\n} from './slots';\n\nconst DAY_MS = 86400_000;\nexport const DAY_NANOS = DAY_MS * 1e6;\nconst MINUTE_NANOS = 60e9;\n// Instant range is 100 million days (inclusive) before or after epoch.\nconst MS_MAX = DAY_MS * 1e8;\nconst NS_MAX = epochMsToNs(MS_MAX);\nconst NS_MIN = JSBI.unaryMinus(NS_MAX);\n// PlainDateTime range is 24 hours wider (exclusive) than the Instant range on\n// both ends, to allow for valid Instant=>PlainDateTime conversion for all\n// built-in time zones (whose offsets must have a magnitude less than 24 hours).\nconst DATETIME_NS_MIN = JSBI.add(JSBI.subtract(NS_MIN, DAY_NANOS_JSBI), ONE);\nconst DATETIME_NS_MAX = JSBI.subtract(JSBI.add(NS_MAX, DAY_NANOS_JSBI), ONE);\n// The pattern of leap years in the ISO 8601 calendar repeats every 400 years.\n// The constant below is the number of nanoseconds in 400 years. It is used to\n// avoid overflows when dealing with values at the edge legacy Date's range.\nconst MS_IN_400_YEAR_CYCLE = (400 * 365 + 97) * DAY_MS;\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_DST = Date.UTC(1847, 0, 1); // 1847-01-01T00:00:00Z\n\nconst BUILTIN_CALENDAR_IDS = [\n  'iso8601',\n  'hebrew',\n  'islamic',\n  'islamic-umalqura',\n  'islamic-tbla',\n  'islamic-civil',\n  'islamic-rgsa',\n  'islamicc',\n  'persian',\n  'ethiopic',\n  'ethioaa',\n  'ethiopic-amete-alem',\n  'coptic',\n  'chinese',\n  'dangi',\n  'roc',\n  'indian',\n  'buddhist',\n  'japanese',\n  'gregory'\n];\n\nconst ICU_LEGACY_TIME_ZONE_IDS = new Set([\n  'ACT',\n  'AET',\n  'AGT',\n  'ART',\n  'AST',\n  'BET',\n  'BST',\n  'CAT',\n  'CNT',\n  'CST',\n  'CTT',\n  'EAT',\n  'ECT',\n  'IET',\n  'IST',\n  'JST',\n  'MIT',\n  'NET',\n  'NST',\n  'PLT',\n  'PNT',\n  'PRT',\n  'PST',\n  'SST',\n  'VST'\n]);\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\n/**\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\n * the type parameter. This should only be used to help TS understand when variables change types,\n * but TS can't or won't infer this automatically. They should be used sparingly, because\n * if used incorrectly can lead to difficult-to-diagnose problems.\n * */\nexport function uncheckedAssertNarrowedType<T = unknown>(\n  arg: unknown,\n  justification: string\n): asserts arg is T extends typeof arg ? T : never {}\n/* eslint-enable */\n\n/**\n * In debug builds, this function verifies that the given argument \"exists\" (is not\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\n * @param arg\n */\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\n  if (ENABLE_ASSERTS) {\n    if (arg == null) {\n      throw new Error('Expected arg to be set.');\n    }\n  }\n}\n\n/** Similar to assertExists, but returns the argument. */\nfunction castExists<A>(arg: A): NonNullable<A> {\n  assertExists(arg);\n  return arg;\n}\n\n// For unknown values, this narrows the result to a Record. But for union types\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\n// leaving the object type(s) unchanged.\nexport function IsObject<T>(\n  value: T\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\n\nexport function ToNumber(value: unknown): number {\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\n  // we'll leave ToNumber as-is.\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return Number(value);\n}\n\nfunction IsIntegralNumber(argument: unknown) {\n  if (typeof argument !== 'number' || Number.isNaN(argument) || argument === Infinity || argument === -Infinity) {\n    return false;\n  }\n  const absValue = Math.abs(argument);\n  return Math.floor(absValue) === absValue;\n}\n\nexport function ToString(value: unknown): string {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n  return String(value);\n}\n\nexport function ToIntegerWithTruncation(value: unknown): number {\n  const number = ToNumber(value);\n  if (number === 0) return 0;\n  if (Number.isNaN(number) || number === Infinity || number === -Infinity) {\n    throw new RangeError('invalid number value');\n  }\n  const integer = Math.trunc(number);\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return integer;\n}\n\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\n  const integer = ToIntegerWithTruncation(valueParam);\n  if (integer <= 0) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n  return integer;\n}\n\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\n  const number = ToNumber(valueParam);\n  if (Number.isNaN(number)) throw new RangeError('not a number');\n  if (number === Infinity || number === -Infinity) throw new RangeError('infinity is out of range');\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return number;\n}\n\nfunction ToZeroPaddedDecimalString(n: number, minLength: number) {\n  if (DEBUG) {\n    if (!IsIntegralNumber(n) || n < 0) {\n      throw new RangeError('Assertion failed: `${n}` must be a non-negative integer');\n    }\n  }\n  const s = String(n);\n  return s.padStart(minLength, '0');\n}\n\n// This convenience function isn't in the spec, but is useful in the polyfill\n// for DRY and better error messages.\nexport function RequireString(value: unknown): string {\n  if (typeof value !== 'string') {\n    // Use String() to ensure that Symbols won't throw\n    throw new TypeError(`expected a string, not ${String(value)}`);\n  }\n  return value;\n}\n\nfunction ToSyntacticallyValidMonthCode(valueParam: unknown) {\n  const value = RequireString(ToPrimitive(valueParam, String));\n  if (\n    value.length < 3 ||\n    value.length > 4 ||\n    value[0] !== 'M' ||\n    '0123456789'.indexOf(value[1]) === -1 ||\n    '0123456789'.indexOf(value[2]) === -1 ||\n    (value[1] + value[2] === '00' && value[3] !== 'L') ||\n    (value[3] !== 'L' && value[3] !== undefined)\n  ) {\n    throw new RangeError(`bad month code ${value}; must match M01-M99 or M00L-M99L`);\n  }\n  return value;\n}\n\nfunction ToOffsetString(valueParam: unknown) {\n  const value = RequireString(ToPrimitive(valueParam, String));\n  ParseDateTimeUTCOffset(value);\n  return value;\n}\n\n// Limited implementation of ToPrimitive that only handles the string case,\n// because that's all that's used in this polyfill.\nfunction ToPrimitive(value: unknown, preferredType: typeof String): string | number {\n  assertExists(preferredType === String);\n  if (IsObject(value)) {\n    const result = value?.toString();\n    if (typeof result === 'string' || typeof result === 'number') return result;\n    throw new TypeError('Cannot convert object to primitive value');\n  }\n  return value;\n}\n\nconst CALENDAR_FIELD_KEYS: readonly FieldKey[] = [\n  'era',\n  'eraYear',\n  'year',\n  'month',\n  'monthCode',\n  'day',\n  'hour',\n  'minute',\n  'second',\n  'millisecond',\n  'microsecond',\n  'nanosecond',\n  'offset',\n  'timeZone'\n] as const;\n\ntype BuiltinCastFunction = (v: unknown) => string | number;\nconst BUILTIN_CASTS: Partial<Record<FieldKey, BuiltinCastFunction>> = {\n  era: ToString,\n  eraYear: ToIntegerWithTruncation,\n  year: ToIntegerWithTruncation,\n  month: ToPositiveIntegerWithTruncation,\n  monthCode: ToSyntacticallyValidMonthCode,\n  day: ToPositiveIntegerWithTruncation,\n  hour: ToIntegerWithTruncation,\n  minute: ToIntegerWithTruncation,\n  second: ToIntegerWithTruncation,\n  millisecond: ToIntegerWithTruncation,\n  microsecond: ToIntegerWithTruncation,\n  nanosecond: ToIntegerWithTruncation,\n  offset: ToOffsetString,\n  timeZone: ToTemporalTimeZoneIdentifier\n};\n\nconst BUILTIN_DEFAULTS: Partial<Record<FieldKey, number>> = {\n  hour: 0,\n  minute: 0,\n  second: 0,\n  millisecond: 0,\n  microsecond: 0,\n  nanosecond: 0\n};\n\n// each item is [plural, singular, category, (length in ns)]\nconst TEMPORAL_UNITS = [\n  ['years', 'year', 'date'],\n  ['months', 'month', 'date'],\n  ['weeks', 'week', 'date'],\n  ['days', 'day', 'date'],\n  ['hours', 'hour', 'time'],\n  ['minutes', 'minute', 'time'],\n  ['seconds', 'second', 'time'],\n  ['milliseconds', 'millisecond', 'time'],\n  ['microseconds', 'microsecond', 'time'],\n  ['nanoseconds', 'nanosecond', 'time']\n] as const;\nconst SINGULAR_FOR = Object.fromEntries(TEMPORAL_UNITS.map((e) => [e[0], e[1]] as const));\nconst PLURAL_FOR = Object.fromEntries(TEMPORAL_UNITS.map(([p, s]) => [s, p] as const));\nconst UNITS_DESCENDING = TEMPORAL_UNITS.map(([, s]) => s);\ntype TimeUnitOrDay = Temporal.TimeUnit | 'day';\nconst NS_PER_TIME_UNIT = {\n  day: DAY_NANOS,\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\n\nconst DURATION_FIELDS = [\n  'days',\n  'hours',\n  'microseconds',\n  'milliseconds',\n  'minutes',\n  'months',\n  'nanoseconds',\n  'seconds',\n  'weeks',\n  'years'\n] as const;\n\nimport * as PARSE from './regex';\n\n// Save the original Intl.DateTimeFormat, it will likely be overwritten with the\n// one from this polyfill. Caching the formatter below may be reentrant, so we\n// need to use the original one\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\n  const lowercaseIdentifier = ASCIILowercase(timeZoneIdentifier);\n  let instance = IntlDateTimeFormatEnUsCache.get(lowercaseIdentifier);\n  if (instance === undefined) {\n    instance = new OriginalIntlDateTimeFormat('en-us', {\n      timeZone: lowercaseIdentifier,\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(lowercaseIdentifier, instance);\n  }\n  return instance;\n}\n\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : Record<PropertyKey, unknown> {\n  if (typeof value === 'undefined' || value === null) {\n    throw new TypeError(`Expected object not ${value}`);\n  }\n  return Object(value);\n}\n\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\nexport function CopyDataProperties<K extends PropertyKey, T extends Record<K, unknown>>(\n  target: T,\n  source: T | undefined,\n  excludedKeys: K[],\n  excludedValues?: unknown[]\n) {\n  if (typeof source === 'undefined' || source === null) return;\n\n  const keys = Reflect.ownKeys(source) as (keyof T)[];\n  for (let index = 0; index < keys.length; index++) {\n    const nextKey = keys[index];\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\n      const propValue = source[nextKey];\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\n\n      target[nextKey] = propValue;\n    }\n  }\n}\n\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\n  return HasSlot(item, DATE_BRAND);\n}\n\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\n  return HasSlot(item, TIME);\n}\n\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\n  return HasSlot(item, ISO_DATE_TIME);\n}\n\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\n\nexport function CheckReceiver<T extends AnySlottedType>(\n  item: unknown,\n  test: (item: unknown) => item is T\n): asserts item is T {\n  if (!test(item)) throw new TypeError('invalid receiver: method called with the wrong type of this-object');\n}\n\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n  if (IsTemporalTime(item)) {\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\n  }\n  if ((item as { calendar: unknown }).calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\n\nfunction FormatCalendarAnnotation(id: BuiltinCalendarId, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  const flag = showCalendar === 'critical' ? '!' : '';\n  return `[${flag}u-ca=${id}]`;\n}\n\n// Not a separate abstract operation in the spec, because it only occurs in one\n// place: ParseISODateTime. In the code it's more convenient to split up\n// ParseISODateTime for the YYYY-MM, MM-DD, and THH:MM:SS parse goals, so it's\n// repeated four times.\nfunction processAnnotations(annotations: string) {\n  let calendar;\n  let calendarWasCritical = false;\n  // Avoid the user code minefield of matchAll.\n  let match;\n  PARSE.annotation.lastIndex = 0;\n  while ((match = PARSE.annotation.exec(annotations))) {\n    const { 1: critical, 2: key, 3: value } = match;\n    if (key === 'u-ca') {\n      if (calendar === undefined) {\n        calendar = value;\n        calendarWasCritical = critical === '!';\n      } else if (critical === '!' || calendarWasCritical) {\n        throw new RangeError(`Invalid annotations in ${annotations}: more than one u-ca present with critical flag`);\n      }\n    } else if (critical === '!') {\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n    }\n  }\n  return calendar;\n}\n\nfunction ParseISODateTime(isoString: string) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = PARSE.zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n  const calendar = processAnnotations(match[16]);\n  let yearString = match[1];\n  if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n  const year = +yearString;\n  const month = +(match[2] ?? match[4] ?? 1);\n  const day = +(match[3] ?? match[5] ?? 1);\n  const hasTime = match[6] !== undefined;\n  const hour = +(match[6] ?? 0);\n  const minute = +(match[7] ?? match[10] ?? 0);\n  let second = +(match[8] ?? match[11] ?? 0);\n  if (second === 60) second = 59;\n  const fraction = (match[9] ?? match[12] ?? '') + '000000000';\n  const millisecond = +fraction.slice(0, 3);\n  const microsecond = +fraction.slice(3, 6);\n  const nanosecond = +fraction.slice(6, 9);\n  let offset;\n  let z = false;\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14]) {\n    offset = match[14];\n  }\n  const tzAnnotation = match[15];\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  return {\n    year,\n    month,\n    day,\n    time: hasTime ? { hour, minute, second, millisecond, microsecond, nanosecond } : ('start-of-day' as const),\n    tzAnnotation,\n    offset,\n    z,\n    calendar\n  };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.tzAnnotation) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString: string) {\n  const match = PARSE.time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n  if (match) {\n    calendar = processAnnotations(match[10]);\n    hour = +(match[1] ?? 0);\n    minute = +(match[2] ?? match[5] ?? 0);\n    second = +(match[3] ?? match[6] ?? 0);\n    if (second === 60) second = 59;\n    const fraction = (match[4] ?? match[7] ?? '') + '000000000';\n    millisecond = +fraction.slice(0, 3);\n    microsecond = +fraction.slice(3, 6);\n    nanosecond = +fraction.slice(6, 9);\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\n  } else {\n    let time, z;\n    ({ time, z, calendar } = ParseISODateTime(isoString));\n    if (time === 'start-of-day') throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = time);\n  }\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  // if it's a date-time string, OK\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n  }\n  try {\n    const { month, day } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const { year, month } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n  }\n  throw new RangeError(`invalid RFC 9557 time-only string ${isoString}; may need a T prefix`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString: string) {\n  const match = PARSE.yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n  if (match) {\n    calendar = processAnnotations(match[3]);\n    let yearString = match[1];\n    if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n    year = +yearString;\n    month = +match[2];\n    referenceISODay = 1;\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n  return { year, month, calendar, referenceISODay };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString: string) {\n  const match = PARSE.monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n  if (match) {\n    calendar = processAnnotations(match[3]);\n    month = +match[1];\n    day = +match[2];\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n  return { month, day, calendar, referenceISOYear };\n}\n\nconst TIMEZONE_IDENTIFIER = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\nconst OFFSET_IDENTIFIER = new RegExp(`^${PARSE.offsetIdentifier.source}$`);\n\nfunction throwBadTimeZoneStringError(timeZoneString: string): never {\n  // Offset identifiers only support minute precision, but offsets in ISO\n  // strings support nanosecond precision. If the identifier is invalid but\n  // it's a valid ISO offset, then it has sub-minute precision. Show a clearer\n  // error message in that case.\n  const msg = OFFSET.test(timeZoneString) ? 'Seconds not allowed in offset time zone' : 'Invalid time zone';\n  throw new RangeError(`${msg}: ${timeZoneString}`);\n}\n\nexport function ParseTimeZoneIdentifier(\n  identifier: string\n): { tzName: string; offsetMinutes?: undefined } | { tzName?: undefined; offsetMinutes: number } {\n  if (!TIMEZONE_IDENTIFIER.test(identifier)) {\n    throwBadTimeZoneStringError(identifier);\n  }\n  if (OFFSET_IDENTIFIER.test(identifier)) {\n    const offsetNanoseconds = ParseDateTimeUTCOffset(identifier);\n    // The regex limits the input to minutes precision, so we know that the\n    // division below will result in an integer.\n    return { offsetMinutes: offsetNanoseconds / 60e9 };\n  }\n  return { tzName: identifier };\n}\n\n// This operation doesn't exist in the spec, but in the polyfill it's split from\n// ParseTemporalTimeZoneString so that parsing can be tested separately from the\n// logic of converting parsed values into a named or offset identifier.\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneStringRaw(timeZoneString: string): {\n  tzAnnotation: string;\n  offset: string | undefined;\n  z: boolean;\n} {\n  if (TIMEZONE_IDENTIFIER.test(timeZoneString)) {\n    return { tzAnnotation: timeZoneString, offset: undefined, z: false };\n  }\n  try {\n    // Try parsing ISO string instead\n    const { tzAnnotation, offset, z } = ParseISODateTime(timeZoneString);\n    if (z || tzAnnotation || offset) {\n      return { tzAnnotation, offset, z };\n    }\n  } catch {\n    // fall through\n  }\n  throwBadTimeZoneStringError(timeZoneString);\n}\n\nfunction ParseTemporalTimeZoneString(stringIdent: string): ReturnType<typeof ParseTimeZoneIdentifier> {\n  const { tzAnnotation, offset, z } = ParseTemporalTimeZoneStringRaw(stringIdent);\n  if (tzAnnotation) return ParseTimeZoneIdentifier(tzAnnotation);\n  if (z) return ParseTimeZoneIdentifier('UTC');\n  if (offset) return ParseTimeZoneIdentifier(offset);\n  /* c8 ignore next */ assertNotReached();\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationStringRaw(isoString: string) {\n  const match = PARSE.duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n  if (match.every((part, i) => i < 2 || part === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n  const sign = match[1] === '-' ? -1 : 1;\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\n  const fHours = match[7];\n  const minutesStr = match[8];\n  const fMinutes = match[9];\n  const secondsStr = match[10];\n  const fSeconds = match[11];\n  let minutes = 0;\n  let seconds = 0;\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\n  let excessNanoseconds = 0;\n\n  if (fHours !== undefined) {\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\n      throw new RangeError('only the smallest unit can be fractional');\n    }\n    excessNanoseconds = ToIntegerWithTruncation((fHours + '000000000').slice(0, 9)) * 3600 * sign;\n  } else {\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\n    if (fMinutes !== undefined) {\n      if (secondsStr ?? fSeconds ?? false) {\n        throw new RangeError('only the smallest unit can be fractional');\n      }\n      excessNanoseconds = ToIntegerWithTruncation((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\n    } else {\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\n      if (fSeconds !== undefined) {\n        excessNanoseconds = ToIntegerWithTruncation((fSeconds + '000000000').slice(0, 9)) * sign;\n      }\n    }\n  }\n\n  const nanoseconds = excessNanoseconds % 1000;\n  const microseconds = Math.trunc(excessNanoseconds / 1000) % 1000;\n  const milliseconds = Math.trunc(excessNanoseconds / 1e6) % 1000;\n  seconds += Math.trunc(excessNanoseconds / 1e9) % 60;\n  minutes += Math.trunc(excessNanoseconds / 60e9);\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction ParseTemporalDurationString(isoString: string) {\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ParseTemporalDurationStringRaw(isoString);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n}\n\nexport function RegulateISODate(yearParam: number, monthParam: number, dayParam: number, overflow: Overflow) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n    case 'constrain':\n      ({ year, month, day } = ConstrainISODate(year, month, day));\n      break;\n  }\n  return { year, month, day };\n}\n\nexport function RegulateTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  overflow: Overflow\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n    case 'constrain':\n      hour = ConstrainToRange(hour, 0, 23);\n      minute = ConstrainToRange(minute, 0, 59);\n      second = ConstrainToRange(second, 0, 59);\n      millisecond = ConstrainToRange(millisecond, 0, 999);\n      microsecond = ConstrainToRange(microsecond, 0, 999);\n      nanosecond = ConstrainToRange(nanosecond, 0, 999);\n      break;\n  }\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\n  if (!IsObject(temporalDurationLike)) {\n    throw new TypeError('invalid duration-like');\n  }\n  const result: Record<(typeof DURATION_FIELDS)[number], number | undefined> = {\n    years: undefined,\n    months: undefined,\n    weeks: undefined,\n    days: undefined,\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined,\n    milliseconds: undefined,\n    microseconds: undefined,\n    nanoseconds: undefined\n  };\n  let any = false;\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\n    const property = DURATION_FIELDS[index];\n    const value = temporalDurationLike[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = ToIntegerIfIntegral(value);\n    }\n  }\n  if (!any) {\n    throw new TypeError('invalid duration-like');\n  }\n  return result;\n}\n\nexport function AdjustDateDurationRecord(\n  { years, months, weeks, days }: DateDuration,\n  newDays: number,\n  newWeeks?: number,\n  newMonths?: number\n) {\n  return {\n    years,\n    months: newMonths ?? months,\n    weeks: newWeeks ?? weeks,\n    days: newDays ?? days\n  };\n}\n\nexport function ZeroDateDuration() {\n  return { years: 0, months: 0, weeks: 0, days: 0 };\n}\n\nexport function CombineISODateAndTimeRecord(isoDate: ISODate, time: TimeRecord) {\n  return { isoDate, time };\n}\n\nexport function MidnightTimeRecord() {\n  return { deltaDays: 0, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n}\n\nexport function NoonTimeRecord() {\n  return { deltaDays: 0, hour: 12, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n}\n\nexport function GetTemporalOverflowOption(options: Temporal.AssignmentOptions) {\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nexport function GetTemporalDisambiguationOption(options: Temporal.ToInstantOptions) {\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nexport function GetRoundingModeOption(\n  options: { roundingMode?: Temporal.RoundingMode },\n  fallback: Temporal.RoundingMode\n) {\n  return GetOption(\n    options,\n    'roundingMode',\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\n    fallback\n  );\n}\n\nfunction NegateRoundingMode(roundingMode: Temporal.RoundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n    case 'floor':\n      return 'ceil';\n    case 'halfCeil':\n      return 'halfFloor';\n    case 'halfFloor':\n      return 'halfCeil';\n    default:\n      return roundingMode;\n  }\n}\n\nexport function GetTemporalOffsetOption(\n  options: Temporal.OffsetDisambiguationOptions,\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\n) {\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nexport function GetTemporalShowCalendarNameOption(options: Temporal.ShowCalendarOption) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\n}\n\nexport function GetTemporalShowTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\n}\n\nexport function GetTemporalShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nexport function GetDirectionOption(options: { direction?: 'next' | 'previous' }) {\n  return GetOption(options, 'direction', ['next', 'previous'], REQUIRED);\n}\n\nexport function GetTemporalRoundingIncrementOption(options: { roundingIncrement?: number }) {\n  let increment = options.roundingIncrement;\n  if (increment === undefined) return 1;\n  const integerIncrement = ToIntegerWithTruncation(increment);\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\n  }\n  return integerIncrement;\n}\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\n  const maximum = inclusive ? dividend : dividend - 1;\n  if (increment > maximum) {\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\n  }\n  if (dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n}\n\nexport function GetTemporalFractionalSecondDigitsOption(\n  normalizedOptions: Temporal.ToStringPrecisionOptions\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\n  if (digitsValue === undefined) return 'auto';\n  if (typeof digitsValue !== 'number') {\n    if (ToString(digitsValue) !== 'auto') {\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n    }\n    return 'auto';\n  }\n  const digitCount = Math.floor(digitsValue);\n  if (!Number.isFinite(digitCount) || digitCount < 0 || digitCount > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n  }\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\n}\n\ninterface SecondsStringPrecisionRecord {\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\n  increment: number;\n}\n\nexport function ToSecondsStringPrecisionRecord(\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\n): SecondsStringPrecisionRecord {\n  switch (smallestUnit) {\n    case 'minute':\n      return { precision: 'minute', unit: 'minute', increment: 1 };\n    case 'second':\n      return { precision: 0, unit: 'second', increment: 1 };\n    case 'millisecond':\n      return { precision: 3, unit: 'millisecond', increment: 1 };\n    case 'microsecond':\n      return { precision: 6, unit: 'microsecond', increment: 1 };\n    case 'nanosecond':\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\n    default: // fall through if option not given\n  }\n  switch (precision) {\n    case 'auto':\n      return { precision, unit: 'nanosecond', increment: 1 };\n    case 0:\n      return { precision, unit: 'second', increment: 1 };\n    case 1:\n    case 2:\n    case 3:\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n    case 4:\n    case 5:\n    case 6:\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n    case 7:\n    case 8:\n    case 9:\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\n  }\n}\n\nexport const REQUIRED = Symbol('~required~');\n\ninterface TemporalUnitOptionsBag {\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n}\ntype UnitTypeMapping = {\n  date: Temporal.DateUnit;\n  time: Temporal.TimeUnit;\n  datetime: Temporal.DateTimeUnit;\n};\n// This type specifies the allowed defaults for each unit key type.\ntype AllowedGetTemporalUnitDefaultValues = {\n  smallestUnit: undefined;\n  largestUnit: 'auto' | undefined;\n  unit: undefined;\n};\n\nexport function GetTemporalUnitValuedOption<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\nexport function GetTemporalUnitValuedOption<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnitValuedOption<\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(\n  options: TemporalUnitOptionsBag,\n  key: keyof typeof options,\n  unitGroup: T,\n  requiredOrDefault: D,\n  extraValues: ReadonlyArray<E> | never[] = []\n): R {\n  let allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\n  for (let index = 0; index < TEMPORAL_UNITS.length; index++) {\n    const unitInfo = TEMPORAL_UNITS[index];\n    const singular = unitInfo[1];\n    const category = unitInfo[2];\n    if (unitGroup === 'datetime' || unitGroup === category) {\n      allowedSingular.push(singular);\n    }\n  }\n  allowedSingular = allowedSingular.concat(extraValues);\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\n  if (defaultVal === REQUIRED) {\n    defaultVal = undefined;\n  } else if (defaultVal !== undefined) {\n    allowedSingular.push(defaultVal);\n  }\n  let allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [];\n  allowedValues = allowedValues.concat(allowedSingular);\n  for (let index = 0; index < allowedSingular.length; index++) {\n    const singular = allowedSingular[index];\n    const plural = PLURAL_FOR[singular];\n    if (plural !== undefined) allowedValues.push(plural);\n  }\n  let retval = GetOption(options, key, allowedValues, defaultVal);\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\n    throw new RangeError(`${key} is required`);\n  }\n  // Coerce any plural units into their singular form\n  return (retval && retval in SINGULAR_FOR ? SINGULAR_FOR[retval] : retval) as R;\n}\n\nexport function GetTemporalRelativeToOption(options: {\n  relativeTo?:\n    | Temporal.ZonedDateTime\n    | Temporal.PlainDateTime\n    | Temporal.ZonedDateTimeLike\n    | Temporal.PlainDateTimeLike\n    | string\n    | undefined;\n}):\n  | { zonedRelativeTo?: Temporal.ZonedDateTime; plainRelativeTo?: never }\n  | { plainRelativeTo?: Temporal.PlainDate; zonedRelativeTo?: never } {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return {};\n\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let matchMinutes = false;\n  let isoDate, time, calendar, timeZone, offset;\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      return { zonedRelativeTo: relativeTo };\n    }\n    if (IsTemporalDate(relativeTo)) return { plainRelativeTo: relativeTo };\n    if (IsTemporalDateTime(relativeTo)) {\n      return {\n        plainRelativeTo: CreateTemporalDate(GetSlot(relativeTo, ISO_DATE_TIME).isoDate, GetSlot(relativeTo, CALENDAR))\n      };\n    }\n    calendar = GetTemporalCalendarIdentifierWithISODefault(relativeTo);\n    const fields = PrepareCalendarFields(\n      calendar,\n      relativeTo,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\n      []\n    );\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, 'constrain'));\n    ({ offset, timeZone } = fields);\n    if (offset === undefined) offsetBehaviour = 'wall';\n  } else {\n    let tzAnnotation, z, year, month, day;\n    ({ year, month, day, time, calendar, tzAnnotation, offset, z } = ParseISODateTime(RequireString(relativeTo)));\n    if (tzAnnotation) {\n      timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\n      if (z) {\n        offsetBehaviour = 'exact';\n      } else if (!offset) {\n        offsetBehaviour = 'wall';\n      }\n      matchMinutes = true;\n    } else if (z) {\n      throw new RangeError(\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\n      );\n    }\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    isoDate = { year, month, day };\n  }\n  if (timeZone === undefined) {\n    return { plainRelativeTo: CreateTemporalDate(isoDate, calendar) };\n  }\n  const offsetNs = offsetBehaviour === 'option' ? ParseDateTimeUTCOffset(castExists(offset)) : 0;\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    isoDate,\n    time,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    'compatible',\n    'reject',\n    matchMinutes\n  );\n  return { zonedRelativeTo: CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar) };\n}\n\nexport function DefaultTemporalLargestUnit(duration: Temporal.Duration) {\n  if (GetSlot(duration, YEARS) !== 0) return 'year';\n  if (GetSlot(duration, MONTHS) !== 0) return 'month';\n  if (GetSlot(duration, WEEKS) !== 0) return 'week';\n  if (GetSlot(duration, DAYS) !== 0) return 'day';\n  if (GetSlot(duration, HOURS) !== 0) return 'hour';\n  if (GetSlot(duration, MINUTES) !== 0) return 'minute';\n  if (GetSlot(duration, SECONDS) !== 0) return 'second';\n  if (GetSlot(duration, MILLISECONDS) !== 0) return 'millisecond';\n  if (GetSlot(duration, MICROSECONDS) !== 0) return 'microsecond';\n  return 'nanosecond';\n}\n\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\n  unit1: T1,\n  unit2: T2\n) {\n  const i1 = UNITS_DESCENDING.indexOf(unit1);\n  const i2 = UNITS_DESCENDING.indexOf(unit2);\n  if (i1 > i2) {\n    return unit2;\n  }\n  return unit1;\n}\n\nexport function IsCalendarUnit(unit: Temporal.DateTimeUnit): unit is Exclude<Temporal.DateUnit, 'day'> {\n  return unit === 'year' || unit === 'month' || unit === 'week';\n}\n\nexport function TemporalUnitCategory(unit: Temporal.DateTimeUnit) {\n  if (IsCalendarUnit(unit) || unit === 'day') return 'date';\n  return 'time';\n}\n\nfunction calendarImplForID(calendar: BuiltinCalendarId) {\n  return GetIntrinsic('%calendarImpl%')(calendar);\n}\n\nexport function calendarImplForObj(\n  temporalObj:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainMonthDay\n    | Temporal.PlainYearMonth\n    | Temporal.ZonedDateTime\n) {\n  return GetIntrinsic('%calendarImpl%')(GetSlot(temporalObj, CALENDAR));\n}\n\ntype ISODateToFieldsReturn<Type extends ISODateToFieldsType> = Resolve<{\n  year: Type extends 'date' | 'year-month' ? number : never;\n  monthCode: string;\n  day: Type extends 'date' | 'month-day' ? number : never;\n}>;\n\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate): ISODateToFieldsReturn<'date'>;\nexport function ISODateToFields<T extends ISODateToFieldsType>(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  type: T\n): ISODateToFieldsReturn<T>;\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate, type = 'date') {\n  const fields = Object.create(null);\n  const calendarImpl = calendarImplForID(calendar);\n  const calendarDate = calendarImpl.isoToDate(isoDate, { year: true, monthCode: true, day: true });\n\n  fields.monthCode = calendarDate.monthCode;\n  if (type === 'month-day' || type === 'date') {\n    fields.day = calendarDate.day;\n  }\n  if (type === 'year-month' || type === 'date') {\n    fields.year = calendarDate.year;\n  }\n  return fields;\n}\n\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\n\ntype FieldObjectWithRequired<FieldKeys extends FieldKey> = Resolve<\n  // The resulting object type contains:\n  // - All keys in FieldKeys, which are required properties and their values\n  //   don't include undefined.\n  // - All the other keys in CalendarFieldsRecord that aren't in FieldKeys,\n  //   which are optional properties and their value types explicitly include\n  //   undefined.\n  {\n    -readonly [k in FieldKeys]: Exclude<Prop<CalendarFieldsRecord, k>, undefined>;\n  } & {\n    -readonly [k in Exclude<Keys<CalendarFieldsRecord>, FieldKeys>]?: Prop<CalendarFieldsRecord, k> | undefined;\n  }\n>;\n\ntype PrepareCalendarFieldsReturn<\n  FieldKeys extends FieldKey,\n  RequiredFieldsOpt extends ReadonlyArray<FieldKey> | 'partial'\n> = RequiredFieldsOpt extends 'partial' ? Partial<CalendarFieldsRecord> : FieldObjectWithRequired<FieldKeys>;\n\nexport function PrepareCalendarFields<\n  FieldKeys extends FieldKey,\n  RequiredFields extends ReadonlyArray<FieldKey> | 'partial'\n>(\n  calendar: BuiltinCalendarId,\n  bag: Partial<Record<FieldKeys, unknown>>,\n  calendarFieldNames: Array<FieldKeys>,\n  nonCalendarFieldNames: Array<FieldKeys>,\n  requiredFields: RequiredFields\n): PrepareCalendarFieldsReturn<FieldKeys, RequiredFields> {\n  const extraFieldNames = calendarImplForID(calendar).extraFields(calendarFieldNames) as FieldKeys[];\n  const fields = calendarFieldNames.concat(nonCalendarFieldNames, extraFieldNames);\n  const result: Partial<Record<AnyTemporalKey, unknown>> = Object.create(null);\n  let any = false;\n  fields.sort();\n  for (let index = 0; index < fields.length; index++) {\n    const property = fields[index];\n    const value = bag[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = castExists(BUILTIN_CASTS[property])(value);\n    } else if (requiredFields !== 'partial') {\n      if (requiredFields.includes(property)) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n      result[property] = BUILTIN_DEFAULTS[property];\n    }\n  }\n  if (requiredFields === 'partial' && !any) {\n    throw new TypeError('no supported properties found');\n  }\n  return result as unknown as PrepareCalendarFieldsReturn<FieldKeys, RequiredFields>;\n}\n\ntype FieldCompleteness = 'complete' | 'partial';\n\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): TimeRecord;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: 'partial'\n): Partial<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\n  completeness: 'complete'\n): TimeRecord;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: FieldCompleteness = 'complete'\n): Partial<TimeRecord> {\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n  let any = false;\n  const result: Partial<TimeRecord> = Object.create(null);\n  for (let index = 0; index < fields.length; index++) {\n    const field = fields[index];\n    const value = bag[field];\n    if (value !== undefined) {\n      result[field] = ToIntegerWithTruncation(value);\n      any = true;\n    } else if (completeness === 'complete') {\n      result[field] = 0;\n    }\n  }\n  if (!any) throw new TypeError('invalid time-like');\n  return result;\n}\n\nexport function ToTemporalDate(\n  item: PlainDateParams['from'][0],\n  options?: PlainDateParams['from'][1]\n): Temporal.PlainDate {\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDate(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n      const isoDate = isoDateTime.isoDate;\n      return CreateTemporalDate(isoDate, GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n      return CreateTemporalDate(GetSlot(item, ISO_DATE_TIME).isoDate, GetSlot(item, CALENDAR));\n    }\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarDateFromFields(calendar, fields, overflow);\n    return CreateTemporalDate(isoDate, calendar);\n  }\n  let { year, month, day, calendar, z } = ParseTemporalDateString(RequireString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  if (!calendar) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n  GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n  return CreateTemporalDate({ year, month, day }, calendar);\n}\n\nexport function InterpretTemporalDateTimeFields(\n  calendar: BuiltinCalendarId,\n  fields: CalendarFieldsRecord & TimeRecord,\n  overflow: Overflow\n) {\n  const isoDate = CalendarDateFromFields(calendar, fields, overflow);\n  const time = RegulateTime(\n    fields.hour,\n    fields.minute,\n    fields.second,\n    fields.millisecond,\n    fields.microsecond,\n    fields.nanosecond,\n    overflow\n  );\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\n  let isoDate, time, calendar;\n\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(GetSlot(item, ISO_DATE_TIME), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(isoDateTime, GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDate(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(\n        CombineISODateAndTimeRecord(GetSlot(item, ISO_DATE), MidnightTimeRecord()),\n        GetSlot(item, CALENDAR)\n      );\n    }\n\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(\n      calendar,\n      item,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\n      []\n    );\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\n  } else {\n    let z, year, month, day;\n    ({ year, month, day, time, calendar, z } = ParseTemporalDateTimeString(RequireString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    if (time === 'start-of-day') time = MidnightTimeRecord();\n    RejectDateTime(\n      year,\n      month,\n      day,\n      time.hour,\n      time.minute,\n      time.second,\n      time.millisecond,\n      time.microsecond,\n      time.nanosecond\n    );\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    GetTemporalOverflowOption(GetOptionsObject(options));\n    isoDate = { year, month, day };\n  }\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, time);\n  return CreateTemporalDateTime(isoDateTime, calendar);\n}\n\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  if (IsTemporalDuration(item)) {\n    return new TemporalDuration(\n      GetSlot(item, YEARS),\n      GetSlot(item, MONTHS),\n      GetSlot(item, WEEKS),\n      GetSlot(item, DAYS),\n      GetSlot(item, HOURS),\n      GetSlot(item, MINUTES),\n      GetSlot(item, SECONDS),\n      GetSlot(item, MILLISECONDS),\n      GetSlot(item, MICROSECONDS),\n      GetSlot(item, NANOSECONDS)\n    );\n  }\n  if (!IsObject(item)) {\n    return ParseTemporalDurationString(RequireString(item));\n  }\n  const result = {\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0\n  };\n  let partial = ToTemporalPartialDurationRecord(item);\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\n    const property = DURATION_FIELDS[index];\n    const value = partial[property];\n    if (value !== undefined) {\n      result[property] = value;\n    }\n  }\n  return new TemporalDuration(\n    result.years,\n    result.months,\n    result.weeks,\n    result.days,\n    result.hours,\n    result.minutes,\n    result.seconds,\n    result.milliseconds,\n    result.microseconds,\n    result.nanoseconds\n  );\n}\n\nexport function ToTemporalInstant(itemParam: InstantParams['from'][0]) {\n  let item: string | number;\n  if (IsObject(itemParam)) {\n    if (IsTemporalInstant(itemParam) || IsTemporalZonedDateTime(itemParam)) {\n      return CreateTemporalInstant(GetSlot(itemParam, EPOCHNANOSECONDS));\n    }\n    item = ToPrimitive(itemParam, String);\n  } else {\n    item = itemParam;\n  }\n  const { year, month, day, time, offset, z } = ParseTemporalInstantString(RequireString(item));\n  const {\n    hour = 0,\n    minute = 0,\n    second = 0,\n    millisecond = 0,\n    microsecond = 0,\n    nanosecond = 0\n  } = time === 'start-of-day' ? {} : time;\n\n  // ParseTemporalInstantString ensures that either `z` is true or or `offset` is non-undefined\n  const offsetNanoseconds = z ? 0 : ParseDateTimeUTCOffset(castExists(offset));\n  const balanced = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond - offsetNanoseconds\n  );\n  CheckISODaysRange(balanced.isoDate);\n  const epochNanoseconds = GetUTCEpochNanoseconds(balanced);\n  return CreateTemporalInstant(epochNanoseconds);\n}\n\nexport function ToTemporalMonthDay(item: PlainMonthDayParams['from'][0], options?: PlainMonthDayParams['from'][1]) {\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalMonthDay(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    let calendar;\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n    } else {\n      calendar = item.calendar;\n      if (calendar === undefined) calendar = 'iso8601';\n      calendar = ToTemporalCalendarIdentifier(calendar);\n    }\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarMonthDayFromFields(calendar, fields, overflow);\n    return CreateTemporalMonthDay(isoDate, calendar);\n  }\n\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(RequireString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n\n  GetTemporalOverflowOption(GetOptionsObject(options));\n  if (calendar === 'iso8601') {\n    const isoCalendarReferenceYear = 1972; // First leap year after Unix epoch\n    return CreateTemporalMonthDay({ year: isoCalendarReferenceYear, month, day }, calendar);\n  }\n  assertExists(referenceISOYear);\n  let isoDate = { year: referenceISOYear, month, day };\n  RejectDateRange(isoDate);\n  const result = ISODateToFields(calendar, isoDate, 'month-day');\n  isoDate = CalendarMonthDayFromFields(calendar, result, 'constrain');\n  return CreateTemporalMonthDay(isoDate, calendar);\n}\n\nexport function ToTemporalTime(item: PlainTimeParams['from'][0], options?: PlainTimeParams['from'][1]) {\n  let time;\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(GetSlot(item, TIME));\n    }\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(GetSlot(item, ISO_DATE_TIME).time);\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(isoDateTime.time);\n    }\n    const { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow);\n  } else {\n    time = ParseTemporalTimeString(RequireString(item));\n    GetTemporalOverflowOption(GetOptionsObject(options));\n  }\n  return CreateTemporalTime(time);\n}\n\nexport function ToTimeRecordOrMidnight(item: PlainTimeParams['from'][0] | undefined) {\n  if (item === undefined) return MidnightTimeRecord();\n  return GetSlot(ToTemporalTime(item), TIME);\n}\n\nexport function ToTemporalYearMonth(\n  item: PlainYearMonthParams['from'][0],\n  options?: PlainYearMonthParams['from'][1]\n): Temporal.PlainYearMonth {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalYearMonth(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarYearMonthFromFields(calendar, fields, overflow);\n    return CreateTemporalYearMonth(isoDate, calendar);\n  }\n\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(RequireString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n\n  GetTemporalOverflowOption(GetOptionsObject(options));\n  let isoDate = { year, month, day: referenceISODay };\n  RejectYearMonthRange(isoDate);\n  const result = ISODateToFields(calendar, isoDate, 'year-month');\n  isoDate = CalendarYearMonthFromFields(calendar, result, 'constrain');\n  return CreateTemporalYearMonth(isoDate, calendar);\n}\n\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\n\nexport function InterpretISODateTimeOffset(\n  isoDate: ISODate,\n  time: 'start-of-day' | TimeRecord,\n  offsetBehaviour: OffsetBehaviour,\n  offsetNs: number,\n  timeZone: string,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\n  matchMinute: boolean\n) {\n  // start-of-day signifies that we had a string such as YYYY-MM-DD[Zone]. It is\n  // grammatically not possible to specify a UTC offset in that string, so the\n  // behaviour collapses into ~WALL~, which is equivalent to offset: \"ignore\".\n  if (time === 'start-of-day') {\n    assert(offsetBehaviour === 'wall', 'offset cannot be provided in YYYY-MM-DD[Zone] string');\n    assert(offsetNs === 0, 'offset cannot be provided in YYYY-MM-DD[Zone] string');\n    return GetStartOfDay(timeZone, isoDate);\n  }\n\n  const dt = CombineISODateAndTimeRecord(isoDate, time);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    return GetEpochNanosecondsFor(timeZone, dt, disambiguation);\n  }\n\n  // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const balanced = BalanceISODateTime(\n      isoDate.year,\n      isoDate.month,\n      isoDate.day,\n      time.hour,\n      time.minute,\n      time.second,\n      time.millisecond,\n      time.microsecond,\n      time.nanosecond - offsetNs\n    );\n    CheckISODaysRange(balanced.isoDate);\n    const epochNs = GetUTCEpochNanoseconds(balanced);\n    ValidateEpochNanoseconds(epochNs);\n    return epochNs;\n  }\n\n  CheckISODaysRange(isoDate);\n  const utcEpochNs = GetUTCEpochNanoseconds(dt);\n\n  // \"prefer\" or \"reject\"\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, dt);\n  for (let index = 0; index < possibleEpochNs.length; index++) {\n    const candidate = possibleEpochNs[index];\n    const candidateOffset = JSBI.toNumber(JSBI.subtract(utcEpochNs, candidate));\n    const roundedCandidateOffset = RoundNumberToIncrement(candidateOffset, 60e9, 'halfExpand');\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n      return candidate;\n    }\n  }\n\n  // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatUTCOffsetNanoseconds(offsetNs);\n    const dtStr = ISODateTimeToString(dt, 'iso8601', 'auto');\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dtStr} in ${timeZone}`);\n  }\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, dt, disambiguation);\n}\n\nexport function ToTemporalZonedDateTime(\n  item: ZonedDateTimeParams['from'][0],\n  options?: ZonedDateTimeParams['from'][1]\n) {\n  let isoDate, time, timeZone, offset, calendar;\n  let matchMinute = false;\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let disambiguation, offsetOpt;\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) {\n      const resolvedOptions = GetOptionsObject(options);\n      GetTemporalDisambiguationOption(resolvedOptions); // validate and ignore\n      GetTemporalOffsetOption(resolvedOptions, 'reject');\n      GetTemporalOverflowOption(resolvedOptions);\n      return CreateTemporalZonedDateTime(\n        GetSlot(item, EPOCHNANOSECONDS),\n        GetSlot(item, TIME_ZONE),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(\n      calendar,\n      item,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\n      ['timeZone']\n    );\n    ({ offset, timeZone } = fields);\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    }\n    const resolvedOptions = GetOptionsObject(options);\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\n    const overflow = GetTemporalOverflowOption(resolvedOptions);\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\n  } else {\n    let tzAnnotation, z, year, month, day;\n    ({ year, month, day, time, tzAnnotation, offset, z, calendar } = ParseTemporalZonedDateTimeString(\n      RequireString(item)\n    ));\n    timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n    const resolvedOptions = GetOptionsObject(options);\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\n    GetTemporalOverflowOption(resolvedOptions); // validate and ignore\n    isoDate = { year, month, day };\n  }\n  let offsetNs = 0;\n  if (offsetBehaviour === 'option') offsetNs = ParseDateTimeUTCOffset(castExists(offset));\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    isoDate,\n    time,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    disambiguation,\n    offsetOpt,\n    matchMinute\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function CreateTemporalDateSlots(result: Temporal.PlainDate, isoDate: ISODate, calendar: BuiltinCalendarId) {\n  RejectDateRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalDateToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainDate <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDate(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = Object.create(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalDateTimeSlots(\n  result: Temporal.PlainDateTime,\n  isoDateTime: ISODateTime,\n  calendar: BuiltinCalendarId\n) {\n  RejectDateTimeRange(isoDateTime);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE_TIME, isoDateTime);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    let repr = ISODateTimeToString(isoDateTime, calendar, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainDateTime <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDateTime(isoDateTime: ISODateTime, calendar: BuiltinCalendarId) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = Object.create(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoDateTime, calendar);\n  return result;\n}\n\nexport function CreateTemporalMonthDaySlots(\n  result: Temporal.PlainMonthDay,\n  isoDate: ISODate,\n  calendar: BuiltinCalendarId\n) {\n  RejectDateRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalMonthDayToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainMonthDay <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalMonthDay(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = Object.create(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalTimeSlots(result: Temporal.PlainTime, time: TimeRecord) {\n  CreateSlots(result);\n  SetSlot(result, TIME, time);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainTime <${TimeRecordToString(time, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalTime(time: TimeRecord) {\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  const result = Object.create(TemporalPlainTime.prototype);\n  CreateTemporalTimeSlots(result, time);\n  return result;\n}\n\nexport function CreateTemporalYearMonthSlots(\n  result: Temporal.PlainYearMonth,\n  isoDate: ISODate,\n  calendar: BuiltinCalendarId\n) {\n  RejectYearMonthRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalYearMonthToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainYearMonth <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalYearMonth(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = Object.create(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalInstantSlots(result: Temporal.Instant, epochNanoseconds: JSBI) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n\n  if (DEBUG) {\n    const iso = GetISOPartsFromEpoch(epochNanoseconds);\n    const repr = ISODateTimeToString(iso, 'iso8601', 'auto', 'never') + 'Z';\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalInstant(epochNanoseconds: JSBI) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const result: Temporal.Instant = Object.create(TemporalInstant.prototype);\n  CreateTemporalInstantSlots(result, epochNanoseconds);\n  return result;\n}\n\nexport function CreateTemporalZonedDateTimeSlots(\n  result: Temporal.ZonedDateTime,\n  epochNanoseconds: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId\n) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    const repr = TemporalZonedDateTimeToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.ZonedDateTime <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalZonedDateTime(\n  epochNanoseconds: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId = 'iso8601'\n) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result: Temporal.ZonedDateTime = Object.create(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\nfunction CalendarFieldKeysPresent(fields: Record<FieldKey, unknown>) {\n  return CALENDAR_FIELD_KEYS.filter((key) => fields[key] !== undefined);\n}\n\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\n  calendar: BuiltinCalendarId,\n  fields: Base,\n  additionalFields: ToAdd\n) {\n  const additionalKeys = CalendarFieldKeysPresent(additionalFields);\n  const overriddenKeys = calendarImplForID(calendar).fieldKeysToIgnore(additionalKeys);\n  const merged = Object.create(null);\n  const fieldsKeys = CalendarFieldKeysPresent(fields);\n  for (let ix = 0; ix < CALENDAR_FIELD_KEYS.length; ix++) {\n    let propValue = undefined;\n    const key = CALENDAR_FIELD_KEYS[ix];\n    if (fieldsKeys.includes(key) && !overriddenKeys.includes(key)) {\n      propValue = fields[key];\n    }\n    if (additionalKeys.includes(key)) {\n      propValue = additionalFields[key];\n    }\n    if (propValue !== undefined) merged[key] = propValue;\n  }\n  return merged as Base & ToAdd;\n}\n\nexport function CalendarDateAdd(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  dateDuration: Partial<DateDuration>,\n  overflow: Overflow\n) {\n  const result = calendarImplForID(calendar).dateAdd(isoDate, dateDuration, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nfunction CalendarDateUntil(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  isoOtherDate: ISODate,\n  largestUnit: Temporal.DateUnit\n) {\n  return calendarImplForID(calendar).dateUntil(isoDate, isoOtherDate, largestUnit);\n}\n\nexport function ToTemporalCalendarIdentifier(calendarLike: Temporal.CalendarLike): BuiltinCalendarId {\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n  }\n  const identifier = RequireString(calendarLike);\n  try {\n    // Fast path: identifier is a calendar type, no ISO string parsing needed\n    return CanonicalizeCalendar(identifier);\n  } catch {\n    // fall through\n  }\n  let calendar;\n  try {\n    ({ calendar } = ParseISODateTime(identifier));\n  } catch {\n    try {\n      ({ calendar } = ParseTemporalTimeString(identifier));\n    } catch {\n      try {\n        ({ calendar } = ParseTemporalYearMonthString(identifier));\n      } catch {\n        ({ calendar } = ParseTemporalMonthDayString(identifier));\n      }\n    }\n  }\n  if (!calendar) calendar = 'iso8601';\n  return CanonicalizeCalendar(calendar);\n}\n\nfunction GetTemporalCalendarIdentifierWithISODefault(item: { calendar?: Temporal.CalendarLike }) {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const { calendar } = item;\n  if (calendar === undefined) return 'iso8601';\n  return ToTemporalCalendarIdentifier(calendar);\n}\n\nexport function CalendarEquals(one: BuiltinCalendarId, two: BuiltinCalendarId) {\n  return CanonicalizeCalendar(one) === CanonicalizeCalendar(two);\n}\n\nexport function CalendarDateFromFields(calendar: BuiltinCalendarId, fields: CalendarFieldsRecord, overflow: Overflow) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'date');\n  const result = calendarImpl.dateToISO(fields, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nexport function CalendarYearMonthFromFields(\n  calendar: BuiltinCalendarId,\n  fields: CalendarFieldsRecord,\n  overflow: Overflow\n) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'year-month');\n  fields.day = 1;\n  const result = calendarImpl.dateToISO(fields, overflow);\n  RejectYearMonthRange(result);\n  return result;\n}\n\nexport function CalendarMonthDayFromFields(\n  calendar: BuiltinCalendarId,\n  fields: MonthDayFromFieldsObject,\n  overflow: Overflow\n) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'month-day');\n  const result = calendarImpl.monthDayToISOReferenceDate(fields, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nexport function ToTemporalTimeZoneIdentifier(temporalTimeZoneLike: unknown): string {\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n  }\n  const timeZoneString = RequireString(temporalTimeZoneLike);\n  if (timeZoneString === 'UTC') return 'UTC'; // UTC fast path\n\n  const { tzName, offsetMinutes } = ParseTemporalTimeZoneString(timeZoneString);\n  if (offsetMinutes !== undefined) {\n    return FormatOffsetTimeZoneIdentifier(offsetMinutes);\n  }\n  // if offsetMinutes is undefined, then tzName must be present\n  const record = GetAvailableNamedTimeZoneIdentifier(castExists(tzName));\n  if (!record) throw new RangeError(`Unrecognized time zone ${tzName}`);\n  return record.identifier;\n}\n\nexport function TimeZoneEquals(one: string, two: string) {\n  if (one === two) return true;\n  const offsetMinutes1 = ParseTimeZoneIdentifier(one).offsetMinutes;\n  const offsetMinutes2 = ParseTimeZoneIdentifier(two).offsetMinutes;\n  if (offsetMinutes1 === undefined && offsetMinutes2 === undefined) {\n    // Calling GetAvailableNamedTimeZoneIdentifier is costly, so (unlike the\n    // spec) the polyfill will early-return if one of them isn't recognized. Try\n    // the second ID first because it's more likely to be unknown, because it\n    // can come from the argument of TimeZone.p.equals as opposed to the first\n    // ID which comes from the receiver.\n    const idRecord2 = GetAvailableNamedTimeZoneIdentifier(two);\n    if (!idRecord2) return false;\n    const idRecord1 = GetAvailableNamedTimeZoneIdentifier(one);\n    if (!idRecord1) return false;\n    return idRecord1.primaryIdentifier === idRecord2.primaryIdentifier;\n  } else {\n    return offsetMinutes1 === offsetMinutes2;\n  }\n}\n\nexport function GetOffsetNanosecondsFor(timeZone: string, epochNs: JSBI) {\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\n  if (offsetMinutes !== undefined) return offsetMinutes * 60e9;\n\n  return GetNamedTimeZoneOffsetNanoseconds(timeZone, epochNs);\n}\n\nexport function FormatUTCOffsetNanoseconds(offsetNs: number): string {\n  const sign = offsetNs < 0 ? '-' : '+';\n  const absoluteNs = Math.abs(offsetNs);\n  const hour = Math.floor(absoluteNs / 3600e9);\n  const minute = Math.floor(absoluteNs / 60e9) % 60;\n  const second = Math.floor(absoluteNs / 1e9) % 60;\n  const subSecondNs = absoluteNs % 1e9;\n  const precision = second === 0 && subSecondNs === 0 ? 'minute' : 'auto';\n  const timeString = FormatTimeString(hour, minute, second, subSecondNs, precision);\n  return `${sign}${timeString}`;\n}\n\nexport function GetISODateTimeFor(timeZone: string, epochNs: JSBI) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, epochNs);\n  let {\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  } = GetISOPartsFromEpoch(epochNs);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\n}\n\nexport function GetEpochNanosecondsFor(\n  timeZone: string,\n  isoDateTime: ISODateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, isoDateTime, disambiguation);\n}\n\n// TODO: See if this logic can be removed in favour of GetNamedTimeZoneEpochNanoseconds\nfunction DisambiguatePossibleEpochNanoseconds(\n  possibleEpochNs: JSBI[],\n  timeZone: string,\n  isoDateTime: ISODateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const numInstants = possibleEpochNs.length;\n\n  if (numInstants === 1) return possibleEpochNs[0];\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible':\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n      case 'earlier':\n        return possibleEpochNs[0];\n      case 'later':\n        return possibleEpochNs[numInstants - 1];\n      case 'reject': {\n        throw new RangeError('multiple instants found');\n      }\n    }\n  }\n\n  if (disambiguation === 'reject') throw new RangeError('multiple instants found');\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\n\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayBefore);\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const dayAfter = JSBI.add(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayAfter);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n  assert(Math.abs(nanoseconds) <= DAY_NANOS, 'UTC offset shift longer than 24 hours');\n\n  switch (disambiguation) {\n    case 'earlier': {\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, -nanoseconds);\n      const earlierTime = AddTime(isoDateTime.time, timeDuration);\n      const earlierDate = BalanceISODate(\n        isoDateTime.isoDate.year,\n        isoDateTime.isoDate.month,\n        isoDateTime.isoDate.day + earlierTime.deltaDays\n      );\n      const earlier = CombineISODateAndTimeRecord(earlierDate, earlierTime);\n      return GetPossibleEpochNanoseconds(timeZone, earlier)[0];\n    }\n    case 'compatible':\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n    case 'later': {\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, nanoseconds);\n      const laterTime = AddTime(isoDateTime.time, timeDuration);\n      const laterDate = BalanceISODate(\n        isoDateTime.isoDate.year,\n        isoDateTime.isoDate.month,\n        isoDateTime.isoDate.day + laterTime.deltaDays\n      );\n      const later = CombineISODateAndTimeRecord(laterDate, laterTime);\n      const possible = GetPossibleEpochNanoseconds(timeZone, later);\n      return possible[possible.length - 1];\n    }\n  }\n}\n\nfunction GetPossibleEpochNanoseconds(timeZone: string, isoDateTime: ISODateTime) {\n  // UTC fast path\n  if (timeZone === 'UTC') {\n    CheckISODaysRange(isoDateTime.isoDate);\n    return [GetUTCEpochNanoseconds(isoDateTime)];\n  }\n\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\n  if (offsetMinutes !== undefined) {\n    const balanced = BalanceISODateTime(\n      isoDateTime.isoDate.year,\n      isoDateTime.isoDate.month,\n      isoDateTime.isoDate.day,\n      isoDateTime.time.hour,\n      isoDateTime.time.minute - offsetMinutes,\n      isoDateTime.time.second,\n      isoDateTime.time.millisecond,\n      isoDateTime.time.microsecond,\n      isoDateTime.time.nanosecond\n    );\n    CheckISODaysRange(balanced.isoDate);\n    const epochNs = GetUTCEpochNanoseconds(balanced);\n    ValidateEpochNanoseconds(epochNs);\n    return [epochNs];\n  }\n\n  CheckISODaysRange(isoDateTime.isoDate);\n  return GetNamedTimeZoneEpochNanoseconds(timeZone, isoDateTime);\n}\n\nexport function GetStartOfDay(timeZone: string, isoDate: ISODate) {\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\n  // If not a DST gap, return the single or earlier epochNs\n  if (possibleEpochNs.length) return possibleEpochNs[0];\n\n  // Otherwise, 00:00:00 lies within a DST gap. Compute an epochNs that's\n  // guaranteed to be before the transition\n  assert(!IsOffsetTimeZoneIdentifier(timeZone), 'should only be reached with named time zone');\n\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayBefore);\n  return castExists(GetNamedTimeZoneNextTransition(timeZone, dayBefore));\n}\n\nexport function ISOYearString(year: number) {\n  let yearString;\n  if (year < 0 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = Math.abs(year);\n    yearString = sign + ToZeroPaddedDecimalString(yearNumber, 6);\n  } else {\n    yearString = ToZeroPaddedDecimalString(year, 4);\n  }\n  return yearString;\n}\n\nexport function ISODateTimePartString(part: number) {\n  return ToZeroPaddedDecimalString(part, 2);\n}\n\nfunction FormatFractionalSeconds(\n  subSecondNanoseconds: number,\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\n): string {\n  let fraction;\n  if (precision === 'auto') {\n    if (subSecondNanoseconds === 0) return '';\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\n    // now remove any trailing zeroes\n    fraction = fractionFullPrecision.replace(/0+$/, '');\n  } else {\n    if (precision === 0) return '';\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\n    fraction = fractionFullPrecision.slice(0, precision);\n  }\n  return `.${fraction}`;\n}\n\nfunction FormatTimeString(\n  hour: number,\n  minute: number,\n  second: number,\n  subSecondNanoseconds: number,\n  precision: SecondsStringPrecisionRecord['precision']\n): string {\n  let result = `${ISODateTimePartString(hour)}:${ISODateTimePartString(minute)}`;\n  if (precision === 'minute') return result;\n\n  result += `:${ISODateTimePartString(second)}`;\n  result += FormatFractionalSeconds(subSecondNanoseconds, precision);\n  return result;\n}\n\nexport function TemporalInstantToString(\n  instant: Temporal.Instant,\n  timeZone: string | undefined,\n  precision: SecondsStringPrecisionRecord['precision']\n) {\n  let outputTimeZone = timeZone;\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\n  const epochNs = GetSlot(instant, EPOCHNANOSECONDS);\n  const iso = GetISODateTimeFor(outputTimeZone, epochNs);\n  const dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\n  let timeZoneString = 'Z';\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, epochNs);\n    timeZoneString = FormatDateTimeUTCOffsetRounded(offsetNs);\n  }\n  return `${dateTimeString}${timeZoneString}`;\n}\n\ninterface ToStringOptions {\n  unit: SecondsStringPrecisionRecord['unit'];\n  increment: number;\n  roundingMode: ReturnType<typeof GetRoundingModeOption>;\n}\n\nexport function TemporalDurationToString(\n  duration: Temporal.Duration,\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\n) {\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  const sign = DurationSign(duration);\n\n  let datePart = '';\n  if (years !== 0) datePart += `${Math.abs(years)}Y`;\n  if (months !== 0) datePart += `${Math.abs(months)}M`;\n  if (weeks !== 0) datePart += `${Math.abs(weeks)}W`;\n  if (days !== 0) datePart += `${Math.abs(days)}D`;\n\n  let timePart = '';\n  if (hours !== 0) timePart += `${Math.abs(hours)}H`;\n  if (minutes !== 0) timePart += `${Math.abs(minutes)}M`;\n\n  // Keeping sub-second units separate avoids losing precision after resolving\n  // any overflows from rounding\n  const secondsDuration = TimeDuration.fromComponents(\n    0,\n    0,\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  );\n  if (\n    !secondsDuration.isZero() ||\n    ['second', 'millisecond', 'microsecond', 'nanosecond'].includes(DefaultTemporalLargestUnit(duration)) ||\n    precision !== 'auto'\n  ) {\n    const secondsPart = Math.abs(secondsDuration.sec);\n    const subSecondsPart = FormatFractionalSeconds(Math.abs(secondsDuration.subsec), precision);\n    timePart += `${secondsPart}${subSecondsPart}S`;\n  }\n  let result = `${sign < 0 ? '-' : ''}P${datePart}`;\n  if (timePart) result = `${result}T${timePart}`;\n  return result;\n}\n\nexport function TemporalDateToString(\n  date: Temporal.PlainDate,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(date, ISO_DATE);\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const calendar = FormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\n  return `${yearString}-${monthString}-${dayString}${calendar}`;\n}\n\nexport function TimeRecordToString(\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\n  precision: SecondsStringPrecisionRecord['precision']\n) {\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  return FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\n}\n\nexport function ISODateTimeToString(\n  isoDateTime: ISODateTime,\n  calendar: BuiltinCalendarId,\n  precision: SecondsStringPrecisionRecord['precision'],\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto'\n) {\n  const {\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  } = isoDateTime;\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  const timeString = FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${timeString}${calendarString}`;\n}\n\nexport function TemporalMonthDayToString(\n  monthDay: Temporal.PlainMonthDay,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(monthDay, ISO_DATE);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  let resultString = `${monthString}-${dayString}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\n    const yearString = ISOYearString(year);\n    resultString = `${yearString}-${resultString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalYearMonthToString(\n  yearMonth: Temporal.PlainYearMonth,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(yearMonth, ISO_DATE);\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  let resultString = `${yearString}-${monthString}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\n    const dayString = ISODateTimePartString(day);\n    resultString += `-${dayString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalZonedDateTimeToString(\n  zdt: Temporal.ZonedDateTime,\n  precision: SecondsStringPrecisionRecord['precision'],\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto',\n  showTimeZone: ReturnType<typeof GetTemporalShowTimeZoneNameOption> = 'auto',\n  showOffset: ReturnType<typeof GetTemporalShowOffsetOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let epochNs = GetSlot(zdt, EPOCHNANOSECONDS);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    epochNs = RoundTemporalInstant(epochNs, increment, unit, roundingMode);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const offsetNs = GetOffsetNanosecondsFor(tz, epochNs);\n  const iso = GetISODateTimeFor(tz, epochNs);\n  let dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\n  if (showOffset !== 'never') {\n    dateTimeString += FormatDateTimeUTCOffsetRounded(offsetNs);\n  }\n  if (showTimeZone !== 'never') {\n    const flag = showTimeZone === 'critical' ? '!' : '';\n    dateTimeString += `[${flag}${tz}]`;\n  }\n  dateTimeString += FormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\n  return dateTimeString;\n}\n\nexport function IsOffsetTimeZoneIdentifier(string: string) {\n  return OFFSET_IDENTIFIER.test(string);\n}\n\nexport function ParseDateTimeUTCOffset(string: string): number {\n  const match = OFFSET_WITH_PARTS.exec(string);\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}; must match ±HH:MM[:SS.SSSSSSSSS]`);\n  }\n  const sign = match[1] === '-' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  const offsetNanoseconds = sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n  return offsetNanoseconds;\n}\n\nlet canonicalTimeZoneIdsCache: Map<string, string> | undefined | null = undefined;\nconst isTZIDSep = Object.assign(Object.create(null), { '/': true, '-': true, _: true });\n\nexport function GetAvailableNamedTimeZoneIdentifier(\n  identifier: string\n): { identifier: string; primaryIdentifier: string } | undefined {\n  // The most common case is when the identifier is a canonical time zone ID.\n  // Fast-path that case by caching all canonical IDs. For old ECMAScript\n  // implementations lacking this API, set the cache to `null` to avoid retries.\n  if (canonicalTimeZoneIdsCache === undefined) {\n    const canonicalTimeZoneIds = Intl.supportedValuesOf?.('timeZone');\n    if (canonicalTimeZoneIds) {\n      canonicalTimeZoneIdsCache = new Map();\n      for (let ix = 0; ix < canonicalTimeZoneIds.length; ix++) {\n        const id = canonicalTimeZoneIds[ix];\n        canonicalTimeZoneIdsCache.set(ASCIILowercase(id), id);\n      }\n    } else {\n      canonicalTimeZoneIdsCache = null;\n    }\n  }\n\n  const lower = ASCIILowercase(identifier);\n  let primaryIdentifier = canonicalTimeZoneIdsCache?.get(lower);\n  if (primaryIdentifier) return { identifier: primaryIdentifier, primaryIdentifier };\n\n  // It's not already a primary identifier, so get its primary identifier (or\n  // return if it's not an available named time zone ID).\n  try {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(identifier);\n    primaryIdentifier = formatter.resolvedOptions().timeZone;\n  } catch {\n    return undefined;\n  }\n\n  // Special case this legacy identifier that is listed both in `backzone` and\n  // `backward` in the TZDB. Work around implementations that incorrectly use\n  // the `backward` data.\n  if (lower === 'antarctica/south_pole') primaryIdentifier = 'Antarctica/McMurdo';\n\n  // Some legacy identifiers are aliases in ICU but not legal IANA identifiers.\n  // Reject them even if the implementation's Intl supports them, as they are\n  // not present in the IANA time zone database.\n  if (ICU_LEGACY_TIME_ZONE_IDS.has(identifier)) {\n    throw new RangeError(`${identifier} is a legacy time zone identifier from ICU. Use ${primaryIdentifier} instead`);\n  }\n\n  // The identifier is an alias (a deprecated identifier that's a synonym for a\n  // primary identifier), so we need to case-normalize the identifier to match\n  // the IANA TZDB, e.g. america/new_york => America/New_York. There's no\n  // built-in way to do this using Intl.DateTimeFormat, but the we can normalize\n  // almost all aliases (modulo a few special cases) using the TZDB's basic\n  // capitalization pattern:\n  // 1. capitalize the first letter of the identifier\n  // 2. capitalize the letter after every slash, dash, or underscore delimiter\n  const chars = [...lower].map((c, i) => (i === 0 || isTZIDSep[lower[i - 1]] ? c.toUpperCase() : c));\n  const standardCase = chars.join('');\n  const segments = standardCase.split('/');\n\n  if (segments.length === 1) {\n    // If a single-segment legacy ID is 2-3 chars or contains a number or dash, then\n    // (except for the \"GB-Eire\" special case) the case-normalized form is uppercase.\n    // These are: GMT+0, GMT-0, GB, NZ, PRC, ROC, ROK, UCT, GMT, GMT0, CET, CST6CDT,\n    // EET, EST, HST, MET, MST, MST7MDT, PST8PDT, WET, NZ-CHAT, and W-SU.\n    // Otherwise it's standard form: first letter capitalized, e.g. Iran, Egypt, Hongkong\n    if (lower === 'gb-eire') return { identifier: 'GB-Eire', primaryIdentifier };\n    return {\n      identifier: lower.length <= 3 || /[-0-9]/.test(lower) ? lower.toUpperCase() : segments[0],\n      primaryIdentifier\n    };\n  }\n\n  // All Etc zone names are uppercase except three exceptions.\n  if (segments[0] === 'Etc') {\n    const etcName = ['Zulu', 'Greenwich', 'Universal'].includes(segments[1]) ? segments[1] : segments[1].toUpperCase();\n    return { identifier: `Etc/${etcName}`, primaryIdentifier };\n  }\n\n  // Legacy US identifiers like US/Alaska or US/Indiana-Starke are 2 segments and use standard form.\n  if (segments[0] === 'Us') return { identifier: `US/${segments[1]}`, primaryIdentifier };\n\n  // For multi-segment IDs, there's a few special cases in the second/third segments\n  const specialCases = new Map([\n    ['Act', 'ACT'],\n    ['Lhi', 'LHI'],\n    ['Nsw', 'NSW'],\n    ['Dar_Es_Salaam', 'Dar_es_Salaam'],\n    ['Port_Of_Spain', 'Port_of_Spain'],\n    ['Port-Au-Prince', 'Port-au-Prince'],\n    ['Isle_Of_Man', 'Isle_of_Man'],\n    ['Comodrivadavia', 'ComodRivadavia'],\n    ['Knox_In', 'Knox_IN'],\n    ['Dumontdurville', 'DumontDUrville'],\n    ['Mcmurdo', 'McMurdo'],\n    ['Denoronha', 'DeNoronha'],\n    ['Easterisland', 'EasterIsland'],\n    ['Bajanorte', 'BajaNorte'],\n    ['Bajasur', 'BajaSur']\n  ]);\n  segments[1] = specialCases.get(segments[1]) ?? segments[1];\n  if (segments.length > 2) segments[2] = specialCases.get(segments[2]) ?? segments[2];\n  return { identifier: segments.join('/'), primaryIdentifier };\n}\n\nfunction GetNamedTimeZoneOffsetNanosecondsImpl(id: string, epochMilliseconds: number) {\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  let millisecond = epochMilliseconds % 1000;\n  if (millisecond < 0) millisecond += 1000;\n  const utc = GetUTCEpochMilliseconds({ isoDate: { year, month, day }, time: { hour, minute, second, millisecond } });\n  return (utc - epochMilliseconds) * 1e6;\n}\n\nfunction GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\n  // Optimization: We get the offset nanoseconds only with millisecond\n  // resolution, assuming that time zone offset changes don't happen in the\n  // middle of a millisecond\n  return GetNamedTimeZoneOffsetNanosecondsImpl(id, epochNsToMs(epochNanoseconds, 'floor'));\n}\n\nexport function FormatOffsetTimeZoneIdentifier(offsetMinutes: number): string {\n  const sign = offsetMinutes < 0 ? '-' : '+';\n  const absoluteMinutes = Math.abs(offsetMinutes);\n  const hour = Math.floor(absoluteMinutes / 60);\n  const minute = absoluteMinutes % 60;\n  const timeString = FormatTimeString(hour, minute, 0, 0, 'minute');\n  return `${sign}${timeString}`;\n}\n\nfunction FormatDateTimeUTCOffsetRounded(offsetNanosecondsParam: number): string {\n  const offsetNanoseconds = RoundNumberToIncrement(offsetNanosecondsParam, MINUTE_NANOS, 'halfExpand');\n  return FormatOffsetTimeZoneIdentifier(offsetNanoseconds / 60e9);\n}\n\nfunction GetUTCEpochMilliseconds({\n  isoDate: { year, month, day },\n  time: { hour, minute, second, millisecond }\n}: {\n  isoDate: ISODate;\n  time: Omit<TimeRecord, 'microsecond' | 'nanosecond'>;\n}) {\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. To avoid overflowing at the edges of the range, we reduce the year\n  // to the remainder after dividing by 400, and then add back all the\n  // nanoseconds from the multiples of 400 years at the end.\n  const reducedYear = year % 400;\n  const yearCycles = (year - reducedYear) / 400;\n\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(reducedYear, month - 1, day);\n  const ms = legacyDate.getTime();\n  return ms + MS_IN_400_YEAR_CYCLE * yearCycles;\n}\n\nfunction GetUTCEpochNanoseconds(isoDateTime: ISODateTime) {\n  const ms = GetUTCEpochMilliseconds(isoDateTime);\n  const subMs = isoDateTime.time.microsecond * 1e3 + isoDateTime.time.nanosecond;\n  return JSBI.add(epochMsToNs(ms), JSBI.BigInt(subMs));\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\n  let epochMilliseconds = epochNsToMs(epochNanoseconds, 'trunc');\n  let nanos = JSBI.toNumber(JSBI.remainder(epochNanoseconds, MILLION));\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n  const microsecond = Math.floor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n\n  return {\n    epochMilliseconds,\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\n  const {\n    epochMilliseconds,\n    time: { millisecond, microsecond, nanosecond }\n  } = GetISOPartsFromEpoch(epochNanoseconds);\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (id === 'UTC') return null; // UTC fast path\n\n  // Optimization: we floor the instant to the previous millisecond boundary\n  // so that we can do Number math instead of BigInt math. This assumes that\n  // time zone transitions don't happen in the middle of a millisecond.\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'floor');\n  if (epochMilliseconds < BEFORE_FIRST_DST) {\n    return GetNamedTimeZoneNextTransition(id, epochMsToNs(BEFORE_FIRST_DST));\n  }\n\n  // Optimization: the farthest that we'll look for a next transition is 3 years\n  // after the later of epochNanoseconds or the current time. If there are no\n  // transitions found before then, we'll assume that there will not be any more\n  // transitions after that.\n  const now = Date.now();\n  const base = Math.max(epochMilliseconds, now);\n  const uppercap = base + DAY_MS * 366 * 3;\n  let leftMs = epochMilliseconds;\n  let leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\n  let rightMs = leftMs;\n  let rightOffsetNs = leftOffsetNs;\n  while (leftOffsetNs === rightOffsetNs && leftMs < uppercap) {\n    rightMs = leftMs + DAY_MS * 2 * 7;\n    if (rightMs > MS_MAX) return null;\n    rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\n    if (leftOffsetNs === rightOffsetNs) {\n      leftMs = rightMs;\n    }\n  }\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\n    leftMs,\n    rightMs,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return epochMsToNs(result);\n}\n\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (id === 'UTC') return null; // UTC fast path\n\n  // Optimization: we raise the instant to the next millisecond boundary so\n  // that we can do Number math instead of BigInt math. This assumes that time\n  // zone transitions don't happen in the middle of a millisecond.\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'ceil');\n\n  // Optimization: if the instant is more than 3 years in the future and there\n  // are no transitions between the present day and 3 years from now, assume\n  // there are none after.\n  const now = Date.now();\n  const lookahead = now + DAY_MS * 366 * 3;\n  if (epochMilliseconds > lookahead) {\n    const prevBeforeLookahead = GetNamedTimeZonePreviousTransition(id, epochMsToNs(lookahead));\n    if (prevBeforeLookahead === null || JSBI.lessThan(prevBeforeLookahead, epochMsToNs(now))) {\n      return prevBeforeLookahead;\n    }\n  }\n\n  // We assume most time zones either have regular DST rules that extend\n  // indefinitely into the future, or they have no DST transitions between now\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\n  // that fit neither of these. Their irregular DST transitions are\n  // precomputed until 2087 in the current time zone database, so requesting\n  // the previous transition for an instant far in the future may take an\n  // extremely long time as it loops backward 2 weeks at a time.\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\n    const lastPrecomputed = Date.UTC(2088, 0, 1); // 2088-01-01T00Z\n    if (lastPrecomputed < epochMilliseconds) {\n      return GetNamedTimeZonePreviousTransition(id, epochMsToNs(lastPrecomputed));\n    }\n  }\n\n  let rightMs = epochMilliseconds - 1;\n  if (rightMs < BEFORE_FIRST_DST) return null;\n  let rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\n  let leftMs = rightMs;\n  let leftOffsetNs = rightOffsetNs;\n  while (rightOffsetNs === leftOffsetNs && rightMs > BEFORE_FIRST_DST) {\n    leftMs = rightMs - DAY_MS * 2 * 7;\n    if (leftMs < BEFORE_FIRST_DST) return null;\n    leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\n    if (rightOffsetNs === leftOffsetNs) {\n      rightMs = leftMs;\n    }\n  }\n  if (rightOffsetNs === leftOffsetNs) return null;\n  const result = bisect(\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\n    leftMs,\n    rightMs,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return epochMsToNs(result);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime: string) {\n  const splits = datetime.split(/[^\\w]+/);\n\n  if (splits.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +splits[0];\n  const day = +splits[1];\n  let year = +splits[2];\n  const era = splits[3];\n  if (era[0] === 'b' || era[0] === 'B') {\n    year = -year + 1;\n  } else if (era[0] !== 'a' && era[0] !== 'A') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n  const hour = splits[4] === '24' ? 0 : +splits[4]; // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n  const minute = +splits[5];\n  const second = +splits[6];\n\n  if (\n    !Number.isFinite(year) ||\n    !Number.isFinite(month) ||\n    !Number.isFinite(day) ||\n    !Number.isFinite(hour) ||\n    !Number.isFinite(minute) ||\n    !Number.isFinite(second)\n  ) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return { year, month, day, hour, minute, second };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n  // Using `format` instead of `formatToParts` for compatibility with older\n  // clients and because it is twice as fast\n  const datetime = formatter.format(epochMilliseconds);\n  return parseFromEnUsFormat(datetime);\n}\n\n// The goal of this function is to find the exact time(s) that correspond to a\n// calendar date and clock time in a particular time zone. Normally there will\n// be only one match. But for repeated clock times after backwards transitions\n// (like when DST ends) there may be two matches. And for skipped clock times\n// after forward transitions, there will be no matches.\nfunction GetNamedTimeZoneEpochNanoseconds(id: string, isoDateTime: ISODateTime) {\n  // Get the offset of one day before and after the requested calendar date and\n  // clock time, avoiding overflows if near the edge of the Instant range.\n  let ns = GetUTCEpochNanoseconds(isoDateTime);\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS_JSBI);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS_JSBI);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earlierOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\n  const laterOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\n\n  // If before and after offsets are the same, then we assume there was no\n  // offset transition in between, and therefore only one exact time can\n  // correspond to the provided calendar date and clock time. But if they're\n  // different, then there was an offset transition in between, so test both\n  // offsets to see which one(s) will yield a matching exact time.\n  const found = earlierOffsetNs === laterOffsetNs ? [earlierOffsetNs] : [earlierOffsetNs, laterOffsetNs];\n  const candidates = found.map((offsetNanoseconds) => {\n    const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n    const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n    if (CompareISODateTime(isoDateTime, parts) !== 0) return undefined;\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return epochNanoseconds;\n  });\n  return candidates.filter((x) => x !== undefined) as JSBI[];\n}\n\nexport function LeapYear(year: number) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nexport function ISODaysInMonth(year: number, month: number) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nexport function DurationSign(duration: Temporal.Duration) {\n  const fields = [\n    GetSlot(duration, YEARS),\n    GetSlot(duration, MONTHS),\n    GetSlot(duration, WEEKS),\n    GetSlot(duration, DAYS),\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  ];\n  for (let index = 0; index < fields.length; index++) {\n    const prop = fields[index];\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction DateDurationSign(dateDuration: DateDuration) {\n  const fieldNames = ['years', 'months', 'weeks', 'days'] as const;\n  for (let index = 0; index < fieldNames.length; index++) {\n    const prop = dateDuration[fieldNames[index]];\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction InternalDurationSign(duration: InternalDuration) {\n  const dateSign = DateDurationSign(duration.date);\n  if (dateSign !== 0) return dateSign;\n  return duration.time.sign();\n}\n\nexport function BalanceISOYearMonth(yearParam: number, monthParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += Math.floor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return { year, month };\n}\n\nexport function BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\n  ({ year, month } = BalanceISOYearMonth(year, month));\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. So if we have more than 400 years in days, there's no need to\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\n  // once.\n  const daysIn400YearCycle = 400 * 365 + 97;\n  if (Math.abs(day) > daysIn400YearCycle) {\n    const nCycles = Math.trunc(day / daysIn400YearCycle);\n    year += 400 * nCycles;\n    day -= nCycles * daysIn400YearCycle;\n  }\n\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n  testYear += 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return { year, month, day };\n}\n\nfunction BalanceISODateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  const time = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nfunction BalanceTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n  let div;\n\n  ({ div, mod: nanosecond } = TruncatingDivModByPowerOf10(nanosecond, 3));\n  microsecond += div;\n  if (nanosecond < 0) {\n    microsecond -= 1;\n    nanosecond += 1000;\n  }\n\n  ({ div, mod: microsecond } = TruncatingDivModByPowerOf10(microsecond, 3));\n  millisecond += div;\n  if (microsecond < 0) {\n    millisecond -= 1;\n    microsecond += 1000;\n  }\n\n  second += Math.trunc(millisecond / 1000);\n  millisecond %= 1000;\n  if (millisecond < 0) {\n    second -= 1;\n    millisecond += 1000;\n  }\n\n  minute += Math.trunc(second / 60);\n  second %= 60;\n  if (second < 0) {\n    minute -= 1;\n    second += 60;\n  }\n\n  hour += Math.trunc(minute / 60);\n  minute %= 60;\n  if (minute < 0) {\n    hour -= 1;\n    minute += 60;\n  }\n\n  let deltaDays = Math.trunc(hour / 24);\n  hour %= 24;\n  if (hour < 0) {\n    deltaDays -= 1;\n    hour += 24;\n  }\n\n  // Results are possibly -0 at this point, but these are mathematical values in\n  // the spec. Force -0 to +0.\n  deltaDays += 0;\n  hour += 0;\n  minute += 0;\n  second += 0;\n  millisecond += 0;\n  microsecond += 0;\n  nanosecond += 0;\n\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function DateDurationDays(dateDuration: DateDuration, plainRelativeTo: Temporal.PlainDate) {\n  const yearsMonthsWeeksDuration = AdjustDateDurationRecord(dateDuration, 0);\n  if (DateDurationSign(yearsMonthsWeeksDuration) === 0) return dateDuration.days;\n\n  // balance years, months, and weeks down to days\n  const isoDate = GetSlot(plainRelativeTo, ISO_DATE);\n  const later = CalendarDateAdd(GetSlot(plainRelativeTo, CALENDAR), isoDate, yearsMonthsWeeksDuration, 'constrain');\n  const epochDaysEarlier = ISODateToEpochDays(isoDate.year, isoDate.month - 1, isoDate.day);\n  const epochDaysLater = ISODateToEpochDays(later.year, later.month - 1, later.day);\n  const yearsMonthsWeeksInDays = epochDaysLater - epochDaysEarlier;\n  return dateDuration.days + yearsMonthsWeeksInDays;\n}\n\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    -GetSlot(duration, YEARS),\n    -GetSlot(duration, MONTHS),\n    -GetSlot(duration, WEEKS),\n    -GetSlot(duration, DAYS),\n    -GetSlot(duration, HOURS),\n    -GetSlot(duration, MINUTES),\n    -GetSlot(duration, SECONDS),\n    -GetSlot(duration, MILLISECONDS),\n    -GetSlot(duration, MICROSECONDS),\n    -GetSlot(duration, NANOSECONDS)\n  );\n}\n\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return Math.min(max, Math.max(min, value as number));\n}\nexport function ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return { year, month, day };\n}\n\nexport function RejectToRange(value: number, min: number, max: number) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nexport function RejectISODate(year: number, month: number, day: number) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(isoDate: ISODate) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(CombineISODateAndTimeRecord(isoDate, NoonTimeRecord()));\n}\n\nexport function RejectTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nexport function RejectDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function RejectDateTimeRange(isoDateTime: ISODateTime) {\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\n  if (JSBI.lessThan(ns, DATETIME_NS_MIN) || JSBI.greaterThan(ns, DATETIME_NS_MAX)) {\n    // Because PlainDateTime's range is wider than Instant's range, the line\n    // below will always throw. Calling `ValidateEpochNanoseconds` avoids\n    // repeating the same error message twice.\n    ValidateEpochNanoseconds(ns);\n  }\n}\n\n// Same as above, but throws a different, non-user-facing error\nfunction AssertISODateTimeWithinLimits(isoDateTime: ISODateTime) {\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\n  assert(\n    JSBI.greaterThanOrEqual(ns, DATETIME_NS_MIN) && JSBI.lessThanOrEqual(ns, DATETIME_NS_MAX),\n    `${ISODateTimeToString(isoDateTime, 'iso8601', 'auto')} is outside the representable range`\n  );\n}\n\n// In the spec, IsValidEpochNanoseconds returns a boolean and call sites are\n// responsible for throwing. In the polyfill, ValidateEpochNanoseconds takes its\n// place so that we can DRY the throwing code.\nfunction ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('date/time value is outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange({ year, month }: Omit<ISODate, 'day'>) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nexport function RejectDuration(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  let sign: -1 | 0 | 1 = 0;\n  const fields = [y, mon, w, d, h, min, s, ms, µs, ns];\n  for (let index = 0; index < fields.length; index++) {\n    const prop = fields[index];\n    if (prop === Infinity || prop === -Infinity) throw new RangeError('infinite values not allowed as duration fields');\n    if (prop !== 0) {\n      const propSign = prop < 0 ? -1 : 1;\n      if (sign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n      sign = propSign;\n    }\n  }\n  if (Math.abs(y) >= 2 ** 32 || Math.abs(mon) >= 2 ** 32 || Math.abs(w) >= 2 ** 32) {\n    throw new RangeError('years, months, and weeks must be < 2³²');\n  }\n  const msResult = TruncatingDivModByPowerOf10(ms, 3);\n  const µsResult = TruncatingDivModByPowerOf10(µs, 6);\n  const nsResult = TruncatingDivModByPowerOf10(ns, 9);\n  const remainderSec = TruncatingDivModByPowerOf10(msResult.mod * 1e6 + µsResult.mod * 1e3 + nsResult.mod, 9).div;\n  const totalSec = d * 86400 + h * 3600 + min * 60 + s + msResult.div + µsResult.div + nsResult.div + remainderSec;\n  if (!Number.isSafeInteger(totalSec)) {\n    throw new RangeError('total of duration time units cannot exceed 9007199254740991.999999999 s');\n  }\n}\n\nexport function ToInternalDurationRecord(duration: Temporal.Duration) {\n  const date = {\n    years: GetSlot(duration, YEARS),\n    months: GetSlot(duration, MONTHS),\n    weeks: GetSlot(duration, WEEKS),\n    days: GetSlot(duration, DAYS)\n  };\n  const time = TimeDuration.fromComponents(\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  );\n  return { date, time };\n}\n\nexport function ToInternalDurationRecordWith24HourDays(duration: Temporal.Duration) {\n  const time = TimeDuration.fromComponents(\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  ).add24HourDays(GetSlot(duration, DAYS));\n  const date = {\n    years: GetSlot(duration, YEARS),\n    months: GetSlot(duration, MONTHS),\n    weeks: GetSlot(duration, WEEKS),\n    days: 0\n  };\n  return { date, time };\n}\n\nfunction ToDateDurationRecordWithoutTime(duration: Temporal.Duration) {\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const days = Math.trunc(internalDuration.time.sec / 86400);\n  RejectDuration(\n    internalDuration.date.years,\n    internalDuration.date.months,\n    internalDuration.date.weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  return { ...internalDuration.date, days };\n}\n\nexport function TemporalDurationFromInternal(internalDuration: InternalDuration, largestUnit: Temporal.DateTimeUnit) {\n  const sign = internalDuration.time.sign();\n  let nanoseconds = internalDuration.time.abs().subsec;\n  let microseconds = 0;\n  let milliseconds = 0;\n  let seconds = internalDuration.time.abs().sec;\n  let minutes = 0;\n  let hours = 0;\n  let days = 0;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      hours = Math.trunc(minutes / 60);\n      minutes %= 60;\n      days = Math.trunc(hours / 24);\n      hours %= 24;\n      break;\n    case 'hour':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      hours = Math.trunc(minutes / 60);\n      minutes %= 60;\n      break;\n    case 'minute':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      break;\n    case 'second':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      break;\n    case 'millisecond':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = FMAPowerOf10(seconds, 3, Math.trunc(microseconds / 1000));\n      microseconds %= 1000;\n      seconds = 0;\n      break;\n    case 'microsecond':\n      microseconds = FMAPowerOf10(seconds, 6, Math.trunc(nanoseconds / 1000));\n      nanoseconds %= 1000;\n      seconds = 0;\n      break;\n    case 'nanosecond':\n      nanoseconds = FMAPowerOf10(seconds, 9, nanoseconds);\n      seconds = 0;\n      break;\n    default:\n      /* c8 ignore next */ assertNotReached();\n  }\n\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    internalDuration.date.years,\n    internalDuration.date.months,\n    internalDuration.date.weeks,\n    internalDuration.date.days + sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function CombineDateAndTimeDuration(dateDuration: DateDuration, timeDuration: TimeDuration) {\n  const dateSign = DateDurationSign(dateDuration);\n  const timeSign = timeDuration.sign();\n  assert(\n    dateSign === 0 || timeSign === 0 || dateSign === timeSign,\n    'should not be able to create mixed sign duration fields here'\n  );\n  return { date: dateDuration, time: timeDuration };\n}\n\n// Caution: month is 0-based\nexport function ISODateToEpochDays(year: number, month: number, day: number) {\n  return (\n    GetUTCEpochMilliseconds({\n      isoDate: { year, month: month + 1, day },\n      time: { hour: 0, minute: 0, second: 0, millisecond: 0 }\n    }) / DAY_MS\n  );\n}\n\n// This is needed before calling GetUTCEpochNanoseconds, because it uses MakeDay\n// which is ill-defined in how it handles large year numbers. If the issue\n// https://github.com/tc39/ecma262/issues/1087 is fixed, this can be removed\n// with no observable changes.\nfunction CheckISODaysRange({ year, month, day }: ISODate) {\n  if (Math.abs(ISODateToEpochDays(year, month - 1, day)) > 1e8) {\n    throw new RangeError('date/time value is outside the supported range');\n  }\n}\n\nfunction DifferenceTime(time1: TimeRecord, time2: TimeRecord) {\n  const hours = time2.hour - time1.hour;\n  const minutes = time2.minute - time1.minute;\n  const seconds = time2.second - time1.second;\n  const milliseconds = time2.millisecond - time1.millisecond;\n  const microseconds = time2.microsecond - time1.microsecond;\n  const nanoseconds = time2.nanosecond - time1.nanosecond;\n  const timeDuration = TimeDuration.fromComponents(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  assert(timeDuration.abs().sec < 86400, '_bt_.[[Days]] should be 0');\n  return timeDuration;\n}\n\nfunction DifferenceInstant(\n  ns1: JSBI,\n  ns2: JSBI,\n  increment: number,\n  smallestUnit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let timeDuration = TimeDuration.fromEpochNsDiff(ns2, ns1);\n  timeDuration = RoundTimeDuration(timeDuration, increment, smallestUnit, roundingMode);\n  return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\n}\n\nfunction DifferenceISODateTime(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit\n) {\n  AssertISODateTimeWithinLimits(isoDateTime1);\n  AssertISODateTimeWithinLimits(isoDateTime2);\n  let timeDuration = DifferenceTime(isoDateTime1.time, isoDateTime2.time);\n\n  const timeSign = timeDuration.sign();\n  const dateSign = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\n\n  // back-off a day from date2 so that the signs of the date and time diff match\n  let adjustedDate = isoDateTime2.isoDate;\n  if (dateSign === timeSign) {\n    adjustedDate = BalanceISODate(adjustedDate.year, adjustedDate.month, adjustedDate.day + timeSign);\n    timeDuration = timeDuration.add24HourDays(-timeSign);\n  }\n\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n  const dateDifference = CalendarDateUntil(calendar, isoDateTime1.isoDate, adjustedDate, dateLargestUnit);\n  if (largestUnit !== dateLargestUnit) {\n    // largestUnit < days, so add the days in to the internal duration\n    timeDuration = timeDuration.add24HourDays(dateDifference.days);\n    dateDifference.days = 0;\n  }\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\n}\n\nfunction DifferenceZonedDateTime(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit\n) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n  if (JSBI.equal(nsDiff, ZERO)) return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\n  const sign = JSBI.lessThan(nsDiff, ZERO) ? -1 : 1;\n\n  // Convert start/end instants to datetimes\n  const isoDtStart = GetISODateTimeFor(timeZone, ns1);\n  const isoDtEnd = GetISODateTimeFor(timeZone, ns2);\n\n  // Simulate moving ns1 as many years/months/weeks/days as possible without\n  // surpassing ns2. This value is stored in intermediateDateTime/intermediateInstant/intermediateNs.\n  // We do not literally move years/months/weeks/days with calendar arithmetic,\n  // but rather assume intermediateDateTime will have the same time-parts as\n  // dtStart and the date-parts from dtEnd, and move backward from there.\n  // The number of days we move backward is stored in dayCorrection.\n  // Credit to Adam Shaw for devising this algorithm.\n  let dayCorrection = 0;\n  let intermediateDateTime: ISODateTime | undefined;\n\n  // The max number of allowed day corrections depends on the direction of travel.\n  // Both directions allow for 1 day correction due to an ISO wall-clock overshoot (see below).\n  // Only the forward direction allows for an additional 1 day correction caused by a push-forward\n  // 'compatible' DST transition causing the wall-clock to overshoot again.\n  // This max value is inclusive.\n  let maxDayCorrection = sign === 1 ? 2 : 1;\n\n  // Detect ISO wall-clock overshoot.\n  // If the diff of the ISO wall-clock times is opposite to the overall diff's sign,\n  // we are guaranteed to need at least one day correction.\n  let timeDuration = DifferenceTime(isoDtStart.time, isoDtEnd.time);\n  if (timeDuration.sign() === -sign) {\n    dayCorrection++;\n  }\n\n  for (; dayCorrection <= maxDayCorrection; dayCorrection++) {\n    const intermediateDate = BalanceISODate(\n      isoDtEnd.isoDate.year,\n      isoDtEnd.isoDate.month,\n      isoDtEnd.isoDate.day - dayCorrection * sign\n    );\n\n    // Incorporate time parts from dtStart\n    intermediateDateTime = CombineISODateAndTimeRecord(intermediateDate, isoDtStart.time);\n\n    // Convert intermediate datetime to epoch-nanoseconds (may disambiguate)\n    const intermediateNs = GetEpochNanosecondsFor(timeZone, intermediateDateTime, 'compatible');\n\n    // Compute the nanosecond diff between the intermediate instant and the final destination\n    timeDuration = TimeDuration.fromEpochNsDiff(ns2, intermediateNs);\n\n    // Did intermediateNs NOT surpass ns2?\n    // If so, exit the loop with success (without incrementing dayCorrection past maxDayCorrection)\n    if (timeDuration.sign() !== -sign) {\n      break;\n    }\n  }\n\n  assert(dayCorrection <= maxDayCorrection, `more than ${maxDayCorrection} day correction needed`);\n\n  // Output of the above loop\n  assertExists(intermediateDateTime);\n\n  // Similar to what happens in DifferenceISODateTime with date parts only:\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n  const dateDifference = CalendarDateUntil(calendar, isoDtStart.isoDate, intermediateDateTime.isoDate, dateLargestUnit);\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\n}\n\n// Epoch-nanosecond bounding technique where the start/end of the calendar-unit\n// interval are converted to epoch-nanosecond times and destEpochNs is nudged to\n// either one.\nfunction NudgeToCalendarUnit(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  increment: number,\n  unit: Temporal.DateUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be day, week, month, or year\n  // timeZone may be undefined\n  let duration = durationParam;\n\n  // Create a duration with smallestUnit trunc'd towards zero\n  // Create a separate duration that incorporates roundingIncrement\n  let r1, r2, startDuration, endDuration;\n  switch (unit) {\n    case 'year': {\n      const years = RoundNumberToIncrement(duration.date.years, increment, 'trunc');\n      r1 = years;\n      r2 = years + increment * sign;\n      startDuration = { years: r1, months: 0, weeks: 0, days: 0 };\n      endDuration = { ...startDuration, years: r2 };\n      break;\n    }\n    case 'month': {\n      const months = RoundNumberToIncrement(duration.date.months, increment, 'trunc');\n      r1 = months;\n      r2 = months + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, 0, 0, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, 0, 0, r2);\n      break;\n    }\n    case 'week': {\n      const yearsMonths = AdjustDateDurationRecord(duration.date, 0, 0);\n      const weeksStart = CalendarDateAdd(calendar, isoDateTime.isoDate, yearsMonths, 'constrain');\n      const weeksEnd = BalanceISODate(weeksStart.year, weeksStart.month, weeksStart.day + duration.date.days);\n      const untilResult = CalendarDateUntil(calendar, weeksStart, weeksEnd, 'week');\n      const weeks = RoundNumberToIncrement(duration.date.weeks + untilResult.weeks, increment, 'trunc');\n      r1 = weeks;\n      r2 = weeks + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, 0, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, 0, r2);\n      break;\n    }\n    case 'day': {\n      const days = RoundNumberToIncrement(duration.date.days, increment, 'trunc');\n      r1 = days;\n      r2 = days + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, r2);\n      break;\n    }\n    default:\n      /* c8 ignore next */ assertNotReached();\n  }\n\n  if (sign === 1) assert(r1 >= 0 && r1 < r2, `positive ordering of r1, r2: 0 ≤ ${r1} < ${r2}`);\n  if (sign === -1) assert(r1 <= 0 && r1 > r2, `negative ordering of r1, r2: 0 ≥ ${r1} > ${r2}`);\n\n  // Apply to origin, output PlainDateTimes\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, startDuration, 'constrain');\n  const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\n\n  // Convert to epoch-nanoseconds\n  let startEpochNs, endEpochNs;\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\n  const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\n  if (timeZone) {\n    startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\n    endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n  } else {\n    startEpochNs = GetUTCEpochNanoseconds(startDateTime);\n    endEpochNs = GetUTCEpochNanoseconds(endDateTime);\n  }\n\n  // Round the smallestUnit within the epoch-nanosecond span\n  if (sign === 1) {\n    assert(\n      JSBI.lessThanOrEqual(startEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, endEpochNs),\n      `${unit} was 0 days long`\n    );\n  }\n  if (sign === -1) {\n    assert(\n      JSBI.lessThanOrEqual(endEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, startEpochNs),\n      `${unit} was 0 days long`\n    );\n  }\n  assert(!JSBI.equal(endEpochNs, startEpochNs), 'startEpochNs must ≠ endEpochNs');\n  const numerator = TimeDuration.fromEpochNsDiff(destEpochNs, startEpochNs);\n  const denominator = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\n  const unsignedRoundingMode = GetUnsignedRoundingMode(roundingMode, sign < 0 ? 'negative' : 'positive');\n  const cmp = numerator.add(numerator).abs().subtract(denominator.abs()).sign();\n  const even = (Math.abs(r1) / increment) % 2 === 0;\n  // prettier-ignore\n  const roundedUnit = numerator.isZero()\n    ? Math.abs(r1)\n    : !numerator.cmp(denominator) // equal?\n      ? Math.abs(r2)\n      : ApplyUnsignedRoundingMode(Math.abs(r1), Math.abs(r2), cmp, even, unsignedRoundingMode);\n\n  // Trick to minimize rounding error, due to the lack of fma() in JS\n  const fakeNumerator = new TimeDuration(\n    JSBI.add(\n      JSBI.multiply(denominator.totalNs, JSBI.BigInt(r1)),\n      JSBI.multiply(numerator.totalNs, JSBI.BigInt(increment * sign))\n    )\n  );\n  const total = fakeNumerator.fdiv(denominator.totalNs);\n  assert(Math.abs(r1) <= Math.abs(total) && Math.abs(total) <= Math.abs(r2), 'r1 ≤ total ≤ r2');\n\n  // Determine whether expanded or contracted\n  const didExpandCalendarUnit = roundedUnit === Math.abs(r2);\n  duration = { date: didExpandCalendarUnit ? endDuration : startDuration, time: TimeDuration.ZERO };\n\n  const nudgeResult = {\n    duration,\n    nudgedEpochNs: didExpandCalendarUnit ? endEpochNs : startEpochNs,\n    didExpandCalendarUnit\n  };\n  return { nudgeResult, total };\n}\n\n// Attempts rounding of time units within a time zone's day, but if the rounding\n// causes time to exceed the total time within the day, rerun rounding in next\n// day.\nfunction NudgeToZonedTime(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  isoDateTime: ISODateTime,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  increment: number,\n  unit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be hour or smaller\n  let duration = durationParam;\n\n  // Apply to origin, output start/end of the day as PlainDateTimes\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, duration.date, 'constrain');\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\n  const endDate = BalanceISODate(start.year, start.month, start.day + sign);\n  const endDateTime = CombineISODateAndTimeRecord(endDate, isoDateTime.time);\n\n  // Compute the epoch-nanosecond start/end of the final whole-day interval\n  // If duration has negative sign, startEpochNs will be after endEpochNs\n  const startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\n  const endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n\n  // The signed amount of time from the start of the whole-day interval to the end\n  const daySpan = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\n  if (daySpan.sign() !== sign) throw new RangeError('time zone returned inconsistent Instants');\n\n  // Compute time parts of the duration to nanoseconds and round\n  // Result could be negative\n  const unitIncrement = JSBI.BigInt(NS_PER_TIME_UNIT[unit] * increment);\n  let roundedTimeDuration = duration.time.round(unitIncrement, roundingMode);\n\n  // Does the rounded time exceed the time-in-day?\n  const beyondDaySpan = roundedTimeDuration.subtract(daySpan);\n  const didRoundBeyondDay = beyondDaySpan.sign() !== -sign;\n\n  let dayDelta, nudgedEpochNs;\n  if (didRoundBeyondDay) {\n    // If rounded into next day, use the day-end as the local origin and rerun\n    // the rounding\n    dayDelta = sign;\n    roundedTimeDuration = beyondDaySpan.round(unitIncrement, roundingMode);\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(endEpochNs);\n  } else {\n    // Otherwise, if time not rounded beyond day, use the day-start as the local\n    // origin\n    dayDelta = 0;\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(startEpochNs);\n  }\n\n  const dateDuration = AdjustDateDurationRecord(duration.date, duration.date.days + dayDelta);\n  const resultDuration = CombineDateAndTimeDuration(dateDuration, roundedTimeDuration);\n  return {\n    duration: resultDuration,\n    nudgedEpochNs,\n    didExpandCalendarUnit: didRoundBeyondDay\n  };\n}\n\n// Converts all fields to nanoseconds and does integer rounding.\nfunction NudgeToDayOrTime(\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  increment: number,\n  smallestUnit: Temporal.TimeUnit | 'day',\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be day or smaller\n  let duration = durationParam;\n\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\n  // Convert to nanoseconds and round\n  const roundedTime = timeDuration.round(JSBI.BigInt(increment * NS_PER_TIME_UNIT[smallestUnit]), roundingMode);\n  const diffTime = roundedTime.subtract(timeDuration);\n\n  // Determine if whole days expanded\n  const { quotient: wholeDays } = timeDuration.divmod(DAY_NANOS);\n  const { quotient: roundedWholeDays } = roundedTime.divmod(DAY_NANOS);\n  const didExpandDays = Math.sign(roundedWholeDays - wholeDays) === timeDuration.sign();\n\n  const nudgedEpochNs = diffTime.addToEpochNs(destEpochNs);\n\n  let days = 0;\n  let remainder = roundedTime;\n  if (TemporalUnitCategory(largestUnit) === 'date') {\n    days = roundedWholeDays;\n    remainder = roundedTime.add(TimeDuration.fromComponents(-roundedWholeDays * 24, 0, 0, 0, 0, 0));\n  }\n\n  const dateDuration = AdjustDateDurationRecord(duration.date, days);\n  return {\n    duration: { date: dateDuration, time: remainder },\n    nudgedEpochNs,\n    didExpandCalendarUnit: didExpandDays\n  };\n}\n\n// Given a potentially bottom-heavy duration, bubble up smaller units to larger\n// units. Any units smaller than smallestUnit are already zeroed-out.\nfunction BubbleRelativeDuration(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  nudgedEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateUnit,\n  smallestUnit: Temporal.DateUnit\n) {\n  // smallestUnit is day or larger\n  let duration = durationParam;\n\n  if (smallestUnit === largestUnit) return duration;\n\n  // Check to see if nudgedEpochNs has hit the boundary of any units higher than\n  // smallestUnit, in which case increment the higher unit and clear smaller\n  // units.\n  const largestUnitIndex = UNITS_DESCENDING.indexOf(largestUnit);\n  const smallestUnitIndex = UNITS_DESCENDING.indexOf(smallestUnit);\n  for (let unitIndex = smallestUnitIndex - 1; unitIndex >= largestUnitIndex; unitIndex--) {\n    // The only situation where days and smaller bubble-up into weeks is when\n    // largestUnit is 'week' (not to be confused with the situation where\n    // smallestUnit is 'week', in which case days and smaller are ROUNDED-up\n    // into weeks, but that has already happened by the time this function\n    // executes)\n    // So, if days and smaller are NOT bubbled-up into weeks, and the current\n    // unit is weeks, skip.\n    const unit = UNITS_DESCENDING[unitIndex];\n    if (unit === 'week' && largestUnit !== 'week') {\n      continue;\n    }\n\n    let endDuration;\n    switch (unit) {\n      case 'year': {\n        const years = duration.date.years + sign;\n        endDuration = { years, months: 0, weeks: 0, days: 0 };\n        break;\n      }\n      case 'month': {\n        const months = duration.date.months + sign;\n        endDuration = AdjustDateDurationRecord(duration.date, 0, 0, months);\n        break;\n      }\n      case 'week': {\n        const weeks = duration.date.weeks + sign;\n        endDuration = AdjustDateDurationRecord(duration.date, 0, weeks);\n        break;\n      }\n      default:\n        /* c8 ignore next */ assertNotReached();\n    }\n\n    // Compute end-of-unit in epoch-nanoseconds\n    const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\n    const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\n    let endEpochNs;\n    if (timeZone) {\n      endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n    } else {\n      endEpochNs = GetUTCEpochNanoseconds(endDateTime);\n    }\n\n    const didExpandToEnd = compare(nudgedEpochNs, endEpochNs) !== -sign;\n\n    // Is nudgedEpochNs at the end-of-unit? This means it should bubble-up to\n    // the next highest unit (and possibly further...)\n    if (didExpandToEnd) {\n      duration = { date: endDuration, time: TimeDuration.ZERO };\n    } else {\n      // NOT at end-of-unit. Stop looking for bubbling\n      break;\n    }\n  }\n\n  return duration;\n}\n\nfunction RoundRelativeDuration(\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  largestUnitParam: Temporal.DateTimeUnit,\n  increment: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let duration = durationParam;\n  // The duration must already be balanced. This should be achieved by calling\n  // one of the non-rounding since/until internal methods prior. It's okay to\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\n  // >24 hours in its timezone. (should automatically end up like this if using\n  // non-rounding since/until internal methods prior)\n  const irregularLengthUnit = IsCalendarUnit(smallestUnit) || (timeZone && smallestUnit === 'day');\n  const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\n\n  let nudgeResult;\n  if (irregularLengthUnit) {\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\n    ({ nudgeResult } = NudgeToCalendarUnit(\n      sign,\n      duration,\n      destEpochNs,\n      isoDateTime,\n      timeZone,\n      calendar,\n      increment,\n      smallestUnit,\n      roundingMode\n    ));\n  } else if (timeZone) {\n    // Special-case for rounding time units within a zoned day\n    uncheckedAssertNarrowedType<Temporal.TimeUnit>(\n      smallestUnit,\n      'other values handled in irregularLengthUnit clause above'\n    );\n    nudgeResult = NudgeToZonedTime(\n      sign,\n      duration,\n      isoDateTime,\n      timeZone,\n      calendar,\n      increment,\n      smallestUnit,\n      roundingMode\n    );\n  } else {\n    // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\n    // math. years/months/weeks unchanged\n    nudgeResult = NudgeToDayOrTime(duration, destEpochNs, largestUnitParam, increment, smallestUnit, roundingMode);\n  }\n\n  duration = nudgeResult.duration;\n  // Did nudging cause the duration to expand to the next day or larger?\n  // Bubble-up smaller calendar units into higher ones, except for weeks, which\n  // don't balance up into months\n  if (nudgeResult.didExpandCalendarUnit && smallestUnit !== 'week') {\n    uncheckedAssertNarrowedType<Temporal.DateUnit>(\n      largestUnitParam,\n      'if we expanded to a calendar unit, then largestUnit is a calendar unit'\n    );\n    duration = BubbleRelativeDuration(\n      sign,\n      duration,\n      nudgeResult.nudgedEpochNs, // The destEpochNs after expanding/contracting\n      isoDateTime,\n      timeZone,\n      calendar,\n      largestUnitParam, // where to STOP bubbling\n      LargerOfTwoTemporalUnits(smallestUnit, 'day') as Temporal.DateUnit // where to START bubbling-up from\n    );\n  }\n\n  return duration;\n}\n\nfunction TotalRelativeDuration(\n  duration: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  // The duration must already be balanced. This should be achieved by calling\n  // one of the non-rounding since/until internal methods prior. It's okay to\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\n  // >24 hours in its timezone. (should automatically end up like this if using\n  // non-rounding since/until internal methods prior)\n  if (IsCalendarUnit(unit) || (timeZone && unit === 'day')) {\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\n    const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\n    return NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, 'trunc').total;\n  }\n  // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\n  // math. years/months/weeks unchanged\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\n  return TotalTimeDuration(timeDuration, unit);\n}\n\nexport function DifferencePlainDateTimeWithRounding(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit,\n  roundingIncrement: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) {\n    return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\n  }\n\n  RejectDateTimeRange(isoDateTime1);\n  RejectDateTimeRange(isoDateTime2);\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, largestUnit);\n\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\n\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\n  return RoundRelativeDuration(\n    duration,\n    destEpochNs,\n    isoDateTime1,\n    null,\n    calendar,\n    largestUnit,\n    roundingIncrement,\n    smallestUnit,\n    roundingMode\n  );\n}\n\nexport function DifferencePlainDateTimeWithTotal(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) return 0;\n\n  RejectDateTimeRange(isoDateTime1);\n  RejectDateTimeRange(isoDateTime2);\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, unit);\n\n  if (unit === 'nanosecond') return JSBI.toNumber(duration.time.totalNs);\n\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\n  return TotalRelativeDuration(duration, destEpochNs, isoDateTime1, null, calendar, unit);\n}\n\nexport function DifferenceZonedDateTimeWithRounding(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit,\n  roundingIncrement: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  if (TemporalUnitCategory(largestUnit) === 'time') {\n    // The user is only asking for a time difference, so return difference of instants.\n    return DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit as Temporal.TimeUnit, roundingMode);\n  }\n\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit);\n\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\n\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\n  return RoundRelativeDuration(\n    duration,\n    ns2,\n    dateTime,\n    timeZone,\n    calendar,\n    largestUnit,\n    roundingIncrement,\n    smallestUnit,\n    roundingMode\n  );\n}\n\nexport function DifferenceZonedDateTimeWithTotal(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  if (TemporalUnitCategory(unit) === 'time') {\n    // The user is only asking for a time difference, so return difference of instants.\n    return TotalTimeDuration(TimeDuration.fromEpochNsDiff(ns2, ns1), unit as Temporal.TimeUnit);\n  }\n\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, unit);\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\n  return TotalRelativeDuration(duration, ns2, dateTime, timeZone, calendar, unit);\n}\n\ntype DifferenceOperation = 'since' | 'until';\n\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\n  op: DifferenceOperation,\n  options: Temporal.DifferenceOptions<T>,\n  group: 'datetime' | 'date' | 'time',\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\n  fallbackSmallest: T,\n  smallestLargestDefaultUnit: T\n) {\n  const ALLOWED_UNITS = TEMPORAL_UNITS.reduce((allowed, unitInfo) => {\n    const p = unitInfo[0];\n    const s = unitInfo[1];\n    const c = unitInfo[2];\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\n      allowed.push(s, p);\n    }\n    return allowed;\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\n\n  let largestUnit = GetTemporalUnitValuedOption(options, 'largestUnit', group, 'auto');\n  if (disallowed.includes(largestUnit)) {\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n  }\n\n  const roundingIncrement = GetTemporalRoundingIncrementOption(options);\n\n  let roundingMode = GetRoundingModeOption(options, 'trunc');\n  if (op === 'since') roundingMode = NegateRoundingMode(roundingMode);\n\n  const smallestUnit = GetTemporalUnitValuedOption(options, 'smallestUnit', group, fallbackSmallest);\n  if (disallowed.includes(smallestUnit)) {\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n  }\n\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\n}\n\nexport function DifferenceTemporalInstant(\n  operation: DifferenceOperation,\n  instant: Temporal.Instant,\n  otherParam: InstantParams['until'][0],\n  options: InstantParams['until'][1]\n) {\n  const other = ToTemporalInstant(otherParam);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\n\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\n  const duration = DifferenceInstant(\n    onens,\n    twons,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainDate(\n  operation: DifferenceOperation,\n  plainDate: Temporal.PlainDate,\n  otherParam: PlainDateParams['until'][0],\n  options: PlainDateParams['until'][1]\n) {\n  const other = ToTemporalDate(otherParam);\n  const calendar = GetSlot(plainDate, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  const isoDate = GetSlot(plainDate, ISO_DATE);\n  const isoOther = GetSlot(other, ISO_DATE);\n  if (CompareISODate(isoDate, isoOther) === 0) return new Duration();\n\n  const dateDifference = CalendarDateUntil(calendar, isoDate, isoOther, settings.largestUnit);\n\n  let duration = { date: dateDifference, time: TimeDuration.ZERO };\n  const roundingIsNoop = settings.smallestUnit === 'day' && settings.roundingIncrement === 1;\n  if (!roundingIsNoop) {\n    const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\n    const isoDateTimeOther = CombineISODateAndTimeRecord(isoOther, MidnightTimeRecord());\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\n    duration = RoundRelativeDuration(\n      duration,\n      destEpochNs,\n      isoDateTime,\n      null,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n  }\n\n  let result = TemporalDurationFromInternal(duration, 'day');\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainDateTime(\n  operation: DifferenceOperation,\n  plainDateTime: Temporal.PlainDateTime,\n  otherParam: PlainDateTimeParams['until'][0],\n  options: PlainDateTimeParams['until'][1]\n) {\n  const other = ToTemporalDateTime(otherParam);\n  const calendar = GetSlot(plainDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  const isoDateTime1 = GetSlot(plainDateTime, ISO_DATE_TIME);\n  const isoDateTime2 = GetSlot(other, ISO_DATE_TIME);\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) === 0) return new Duration();\n\n  const duration = DifferencePlainDateTimeWithRounding(\n    isoDateTime1,\n    isoDateTime2,\n    calendar,\n    settings.largestUnit,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainTime(\n  operation: DifferenceOperation,\n  plainTime: Temporal.PlainTime,\n  otherParam: PlainTimeParams['until'][0],\n  options: PlainTimeParams['until'][1]\n) {\n  const other = ToTemporalTime(otherParam);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\n\n  let timeDuration = DifferenceTime(GetSlot(plainTime, TIME), GetSlot(other, TIME));\n  timeDuration = RoundTimeDuration(\n    timeDuration,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n  const duration = CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\n\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainYearMonth(\n  operation: DifferenceOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  otherParam: PlainYearMonthParams['until'][0],\n  options: PlainYearMonthParams['until'][1]\n) {\n  const other = ToTemporalYearMonth(otherParam);\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between months of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  if (CompareISODate(GetSlot(yearMonth, ISO_DATE), GetSlot(other, ISO_DATE)) == 0) {\n    return new Duration();\n  }\n\n  const thisFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\n  thisFields.day = 1;\n  const thisDate = CalendarDateFromFields(calendar, thisFields, 'constrain');\n  const otherFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(other, ISO_DATE), 'year-month');\n  otherFields.day = 1;\n  const otherDate = CalendarDateFromFields(calendar, otherFields, 'constrain');\n\n  const dateDifference = CalendarDateUntil(calendar, thisDate, otherDate, settings.largestUnit);\n  let duration = { date: AdjustDateDurationRecord(dateDifference, 0, 0), time: TimeDuration.ZERO };\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\n    const isoDateTime = CombineISODateAndTimeRecord(thisDate, MidnightTimeRecord());\n    const isoDateTimeOther = CombineISODateAndTimeRecord(otherDate, MidnightTimeRecord());\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\n    duration = RoundRelativeDuration(\n      duration,\n      destEpochNs,\n      isoDateTime,\n      null,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n  }\n\n  let result = TemporalDurationFromInternal(duration, 'day');\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalZonedDateTime(\n  operation: DifferenceOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  otherParam: ZonedDateTimeParams['until'][0],\n  options: ZonedDateTimeParams['until'][1]\n) {\n  const other = ToTemporalZonedDateTime(otherParam);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\n\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n\n  let result;\n  if (TemporalUnitCategory(settings.largestUnit) !== 'date') {\n    // The user is only asking for a time difference, so return difference of instants.\n    const duration = DifferenceInstant(\n      ns1,\n      ns2,\n      settings.roundingIncrement,\n      settings.smallestUnit as Temporal.TimeUnit,\n      settings.roundingMode\n    );\n    result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  } else {\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n      throw new RangeError(\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\n      );\n    }\n\n    if (JSBI.equal(ns1, ns2)) return new Duration();\n\n    const duration = DifferenceZonedDateTimeWithRounding(\n      ns1,\n      ns2,\n      timeZone,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n    result = TemporalDurationFromInternal(duration, 'hour');\n  }\n\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function AddTime(\n  { hour, minute, second: secondParam, millisecond, microsecond, nanosecond: nanosecondParam }: TimeRecord,\n  timeDuration: TimeDuration\n) {\n  let second = secondParam;\n  let nanosecond = nanosecondParam;\n\n  second += timeDuration.sec;\n  nanosecond += timeDuration.subsec;\n  return BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction AddInstant(epochNanoseconds: JSBI, timeDuration: TimeDuration) {\n  const result = timeDuration.addToEpochNs(epochNanoseconds);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nexport function AddZonedDateTime(\n  epochNs: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  duration: InternalDuration,\n  overflow: Overflow = 'constrain'\n) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  if (DateDurationSign(duration.date) === 0) return AddInstant(epochNs, duration.time);\n\n  // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n  const dt = GetISODateTimeFor(timeZone, epochNs);\n  const addedDate = CalendarDateAdd(calendar, dt.isoDate, duration.date, overflow);\n  const dtIntermediate = CombineISODateAndTimeRecord(addedDate, dt.time);\n\n  // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n  const intermediateNs = GetEpochNanosecondsFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(intermediateNs, duration.time);\n}\n\ntype AddSubtractOperation = 'add' | 'subtract';\n\nexport function AddDurations(\n  operation: AddSubtractOperation,\n  duration: Temporal.Duration,\n  otherParam: DurationParams['add'][0]\n) {\n  let other = ToTemporalDuration(otherParam);\n  if (operation === 'subtract') other = CreateNegatedTemporalDuration(other);\n\n  const largestUnit1 = DefaultTemporalLargestUnit(duration);\n  const largestUnit2 = DefaultTemporalLargestUnit(other);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n  if (IsCalendarUnit(largestUnit)) {\n    throw new RangeError('For years, months, or weeks arithmetic, use date arithmetic relative to a starting point');\n  }\n\n  const d1 = ToInternalDurationRecordWith24HourDays(duration);\n  const d2 = ToInternalDurationRecordWith24HourDays(other);\n  const result = CombineDateAndTimeDuration(ZeroDateDuration(), d1.time.add(d2.time));\n  return TemporalDurationFromInternal(result, largestUnit);\n}\n\nexport function AddDurationToInstant(\n  operation: AddSubtractOperation,\n  instant: Temporal.Instant,\n  durationLike: InstantParams['add'][0]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const largestUnit = DefaultTemporalLargestUnit(duration);\n  if (TemporalUnitCategory(largestUnit) === 'date') {\n    throw new RangeError(\n      `Duration field ${largestUnit} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\n    );\n  }\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), internalDuration.time);\n  return CreateTemporalInstant(ns);\n}\n\nexport function AddDurationToDate(\n  operation: AddSubtractOperation,\n  plainDate: Temporal.PlainDate,\n  durationLike: PlainDateParams['add'][0],\n  options: PlainDateParams['add'][1]\n) {\n  const calendar = GetSlot(plainDate, CALENDAR);\n\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const dateDuration = ToDateDurationRecordWithoutTime(duration);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n\n  const addedDate = CalendarDateAdd(calendar, GetSlot(plainDate, ISO_DATE), dateDuration, overflow);\n  return CreateTemporalDate(addedDate, calendar);\n}\n\nexport function AddDurationToDateTime(\n  operation: AddSubtractOperation,\n  dateTime: Temporal.PlainDateTime,\n  durationLike: PlainDateTimeParams['add'][0],\n  options: PlainDateTimeParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n\n  const calendar = GetSlot(dateTime, CALENDAR);\n\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n\n  // Add the time part\n  const isoDateTime = GetSlot(dateTime, ISO_DATE_TIME);\n  const timeResult = AddTime(isoDateTime.time, internalDuration.time);\n  const dateDuration = AdjustDateDurationRecord(internalDuration.date, timeResult.deltaDays);\n\n  // Delegate the date part addition to the calendar\n  RejectDuration(dateDuration.years, dateDuration.months, dateDuration.weeks, dateDuration.days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, isoDateTime.isoDate, dateDuration, overflow);\n\n  const result = CombineISODateAndTimeRecord(addedDate, timeResult);\n  return CreateTemporalDateTime(result, calendar);\n}\n\nexport function AddDurationToTime(\n  operation: AddSubtractOperation,\n  temporalTime: Temporal.PlainTime,\n  durationLike: PlainTimeParams['add'][0]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    GetSlot(temporalTime, TIME),\n    internalDuration.time\n  );\n  const time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject');\n  return CreateTemporalTime(time);\n}\n\nexport function AddDurationToYearMonth(\n  operation: AddSubtractOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  durationLike: PlainYearMonthParams['add'][0],\n  options: PlainYearMonthParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n  const sign = DurationSign(duration);\n\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const fields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\n  fields.day = 1;\n  let startDate = CalendarDateFromFields(calendar, fields, 'constrain');\n  if (sign < 0) {\n    const nextMonth = CalendarDateAdd(calendar, startDate, { months: 1 }, 'constrain');\n    startDate = BalanceISODate(nextMonth.year, nextMonth.month, nextMonth.day - 1);\n  }\n  const durationToAdd = ToDateDurationRecordWithoutTime(duration);\n  RejectDateRange(startDate);\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, overflow);\n  const addedDateFields = ISODateToFields(calendar, addedDate, 'year-month');\n\n  const isoDate = CalendarYearMonthFromFields(calendar, addedDateFields, overflow);\n  return CreateTemporalYearMonth(isoDate, calendar);\n}\n\nexport function AddDurationToZonedDateTime(\n  operation: AddSubtractOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  durationLike: ZonedDateTimeParams['add'][0],\n  options: ZonedDateTimeParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const internalDuration = ToInternalDurationRecord(duration);\n  const epochNanoseconds = AddZonedDateTime(\n    GetSlot(zonedDateTime, EPOCHNANOSECONDS),\n    timeZone,\n    calendar,\n    internalDuration,\n    overflow\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function RoundNumberToIncrement(quantity: number, increment: number, mode: Temporal.RoundingMode) {\n  const quotient = Math.trunc(quantity / increment);\n  const remainder = quantity % increment;\n  const sign = quantity < 0 ? 'negative' : 'positive';\n  const r1 = Math.abs(quotient);\n  const r2 = r1 + 1;\n  const cmp = ComparisonResult(Math.abs(remainder * 2) - increment);\n  const even = r1 % 2 === 0;\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\n  const rounded = remainder === 0 ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, even, unsignedRoundingMode);\n  return increment * (sign === 'positive' ? rounded : -rounded);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function RoundNumberToIncrementAsIfPositive(\n  quantityParam: JSBI | bigint,\n  incrementParam: JSBI | bigint,\n  mode: Temporal.RoundingMode\n) {\n  const quantity = ensureJSBI(quantityParam);\n  const increment = ensureJSBI(incrementParam);\n  const quotient = JSBI.divide(quantity, increment);\n  const remainder = JSBI.remainder(quantity, increment);\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, 'positive');\n  let r1: JSBI, r2: JSBI;\n  if (JSBI.lessThan(quantity, ZERO)) {\n    r1 = JSBI.subtract(quotient, ONE);\n    r2 = quotient;\n  } else {\n    r1 = quotient;\n    r2 = JSBI.add(quotient, ONE);\n  }\n  // Similar to the comparison in RoundNumberToIncrement, but multiplied by an\n  // extra sign to make sure we treat it as positive\n  const cmp = (compare(abs(JSBI.multiply(remainder, TWO)), increment) * (JSBI.lessThan(quantity, ZERO) ? -1 : 1) +\n    0) as -1 | 0 | 1;\n  const rounded = JSBI.equal(remainder, ZERO)\n    ? quotient\n    : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(r1), unsignedRoundingMode);\n  return JSBI.multiply(rounded, increment);\n}\n\nexport function RoundTemporalInstant(\n  epochNs: JSBI,\n  increment: number,\n  unit: TimeUnitOrDay,\n  roundingMode: Temporal.RoundingMode\n) {\n  const incrementNs = NS_PER_TIME_UNIT[unit] * increment;\n  return RoundNumberToIncrementAsIfPositive(epochNs, JSBI.BigInt(incrementNs), roundingMode);\n}\n\nexport function RoundISODateTime(\n  isoDateTime: ISODateTime,\n  increment: number,\n  unit: UnitSmallerThanOrEqualTo<'day'>,\n  roundingMode: Temporal.RoundingMode\n) {\n  AssertISODateTimeWithinLimits(isoDateTime);\n  const { year, month, day } = isoDateTime.isoDate;\n  const time = RoundTime(isoDateTime.time, increment, unit, roundingMode);\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nexport function RoundTime(\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\n  increment: number,\n  unit: TimeUnitOrDay,\n  roundingMode: Temporal.RoundingMode\n) {\n  let quantity;\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = ((((hour * 60 + minute) * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'minute':\n      quantity = (((minute * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'second':\n      quantity = ((second * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'millisecond':\n      quantity = (millisecond * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'microsecond':\n      quantity = microsecond * 1000 + nanosecond;\n      break;\n    case 'nanosecond':\n      quantity = nanosecond;\n  }\n  const nsPerUnit = NS_PER_TIME_UNIT[unit];\n  const result = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode) / nsPerUnit;\n  switch (unit) {\n    case 'day':\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nexport function RoundTimeDuration(\n  timeDuration: TimeDuration,\n  increment: number,\n  unit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be a time unit\n  const divisor = NS_PER_TIME_UNIT[unit];\n  return timeDuration.round(JSBI.BigInt(divisor * increment), roundingMode);\n}\n\nexport function TotalTimeDuration(timeDuration: TimeDuration, unit: TimeUnitOrDay) {\n  const divisor = NS_PER_TIME_UNIT[unit];\n  return timeDuration.fdiv(JSBI.BigInt(divisor));\n}\n\nexport function CompareISODate(isoDate1: ISODate, isoDate2: ISODate) {\n  if (isoDate1.year !== isoDate2.year) return ComparisonResult(isoDate1.year - isoDate2.year);\n  if (isoDate1.month !== isoDate2.month) return ComparisonResult(isoDate1.month - isoDate2.month);\n  if (isoDate1.day !== isoDate2.day) return ComparisonResult(isoDate1.day - isoDate2.day);\n  return 0;\n}\n\nexport function CompareTimeRecord(time1: TimeRecord, time2: TimeRecord) {\n  if (time1.hour !== time2.hour) return ComparisonResult(time1.hour - time2.hour);\n  if (time1.minute !== time2.minute) return ComparisonResult(time1.minute - time2.minute);\n  if (time1.second !== time2.second) return ComparisonResult(time1.second - time2.second);\n  if (time1.millisecond !== time2.millisecond) return ComparisonResult(time1.millisecond - time2.millisecond);\n  if (time1.microsecond !== time2.microsecond) return ComparisonResult(time1.microsecond - time2.microsecond);\n  if (time1.nanosecond !== time2.nanosecond) return ComparisonResult(time1.nanosecond - time2.nanosecond);\n  return 0;\n}\n\nexport function CompareISODateTime(isoDateTime1: ISODateTime, isoDateTime2: ISODateTime) {\n  const dateResult = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\n  if (dateResult !== 0) return dateResult;\n  return CompareTimeRecord(isoDateTime1.time, isoDateTime2.time);\n}\n\n// Defaults to native bigint, or something \"native bigint-like\".\n// For users of Temporal that are running in environments without native BigInt,\n// the only guarantee we should give is that the returned object's toString will\n// return a string containing an accurate base 10 value of this bigint. This\n// form factor should correctly interop with other bigint compat libraries\n// easily.\ntype ExternalBigInt = bigint;\n\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\n  return jsbiBI as unknown as ExternalBigInt;\n}\n\n// rounding modes supported: floor, ceil, trunc\nexport function epochNsToMs(epochNanosecondsParam: JSBI | bigint, mode: 'floor' | 'ceil' | 'trunc') {\n  const epochNanoseconds = ensureJSBI(epochNanosecondsParam);\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  if (mode === 'floor' && JSBI.toNumber(remainder) < 0) epochMilliseconds -= 1;\n  if (mode === 'ceil' && JSBI.toNumber(remainder) > 0) epochMilliseconds += 1;\n  return epochMilliseconds;\n}\n\nexport function epochMsToNs(epochMilliseconds: number) {\n  if (!Number.isInteger(epochMilliseconds)) throw new RangeError('epoch milliseconds must be an integer');\n  return JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n}\n\nexport function ToBigInt(arg: unknown): JSBI {\n  let prim = arg;\n  if (typeof arg === 'object') {\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = toPrimFn.call(arg, 'number');\n    }\n  }\n\n  // The AO ToBigInt throws on numbers because it does not allow implicit\n  // conversion between number and bigint (unlike the bigint constructor).\n  if (typeof prim === 'number') {\n    throw new TypeError('cannot convert number to bigint');\n  }\n  if (typeof prim === 'bigint') {\n    // JSBI doesn't know anything about the bigint type, and intentionally\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\n    // an error.\n    return JSBI.BigInt(prim.toString(10));\n  }\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\n  // constructor will, with the exception of native bigint which is handled\n  // above.\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\n  // error if they are given a Symbol.\n  return JSBI.BigInt(prim as string | boolean | object);\n}\n\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const now = Date.now();\n    const ms = JSBI.BigInt(now);\n    const result = JSBI.add(epochMsToNs(now), ns);\n    ns = JSBI.remainder(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nexport function DefaultTimeZone() {\n  return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function ComparisonResult(value: number) {\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\n}\n\nexport function GetOptionsObject<T>(options: T) {\n  if (options === undefined) return Object.create(null) as NonNullable<T>;\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\n  const o = Object.create(null);\n  o[propName] = propValue;\n  return o;\n}\n\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: undefined\n): O[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | typeof REQUIRED | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: Fallback\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: O[P]\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\n  let value = options[property];\n  if (value !== undefined) {\n    value = ToString(value) as O[P];\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n    return value;\n  }\n  if (fallback === REQUIRED) throw new RangeError(`${property} option is required`);\n  return fallback;\n}\n\n// This is a temporary implementation. Ideally we'd rely on Intl.DateTimeFormat\n// here, to provide the latest CLDR alias data, when implementations catch up to\n// the ECMA-402 change. The aliases below are taken from\n// https://github.com/unicode-org/cldr/blob/main/common/bcp47/calendar.xml\nexport function CanonicalizeCalendar(idParam: string): BuiltinCalendarId {\n  const id = ASCIILowercase(idParam);\n\n  if (!BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id))) {\n    throw new RangeError(`invalid calendar identifier ${id}`);\n  }\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(id, 'above code throws out any non-calendar IDs');\n\n  switch (id) {\n    case 'ethiopic-amete-alem':\n      // May need to be removed in the future.\n      // See https://github.com/tc39/ecma402/issues/285\n      return 'ethioaa';\n    // case 'gregorian':\n    // (Skip 'gregorian'. It isn't a valid identifier as it's a single\n    // subcomponent longer than 8 letters. It can only be used with the old\n    // @key=value syntax.)\n    case 'islamicc':\n      return 'islamic-civil';\n  }\n  return id;\n}\n\nfunction ASCIILowercase<T extends string>(str: T): T {\n  // The spec defines this operation distinct from String.prototype.lowercase,\n  // so we'll follow the spec here. Note that nasty security issues that can\n  // happen for some use cases if you're comparing case-modified non-ASCII\n  // values. For example, Turkish's \"I\" character was the source of a security\n  // issue involving \"file://\" URLs. See\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\n  let lowercase = '';\n  for (let ix = 0; ix < str.length; ix++) {\n    const code = str.charCodeAt(ix);\n    if (code >= 0x41 && code <= 0x5a) {\n      lowercase += String.fromCharCode(code + 0x20);\n    } else {\n      lowercase += String.fromCharCode(code);\n    }\n  }\n  return lowercase as T;\n}\n\n// This function isn't in the spec, but we put it in the polyfill to avoid\n// repeating the same (long) error message in many files.\nexport function ValueOfThrows(constructorName: string): never {\n  const compareCode =\n    constructorName === 'PlainMonthDay'\n      ? 'Temporal.PlainDate.compare(obj1.toPlainDate(year), obj2.toPlainDate(year))'\n      : `Temporal.${constructorName}.compare(obj1, obj2)`;\n\n  throw new TypeError(\n    'Do not use built-in arithmetic operators with Temporal objects. ' +\n      `When comparing, use ${compareCode}, not obj1 > obj2. ` +\n      \"When coercing to strings, use `${obj}` or String(obj), not '' + obj. \" +\n      'When coercing to numbers, use properties or methods of the object, not `+obj`. ' +\n      'When concatenating with strings, use `${str}${obj}` or str.concat(obj), not str + obj. ' +\n      'In React, coerce to a string before rendering a Temporal object.'\n  );\n}\n\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\nconst OFFSET_WITH_PARTS = new RegExp(`^${PARSE.offsetWithParts.source}$`);\n\nfunction bisect(\n  getState: (epochMs: number) => number,\n  leftParam: number,\n  rightParam: number,\n  lstateParam = getState(leftParam),\n  rstateParam = getState(rightParam)\n) {\n  let left = leftParam;\n  let right = rightParam;\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n  while (right - left > 1) {\n    let middle = Math.trunc((left + right) / 2);\n    const mstate = getState(middle);\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      /* c8 ignore next */ assertNotReached(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n  return right;\n}\n","import * as ES from './ecmascript';\nimport { DefineIntrinsic } from './intrinsicclass';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  CalendarDateRecord,\n  CalendarFieldsRecord,\n  CalendarYMD,\n  DateDuration,\n  FieldKey,\n  ISODate,\n  ISODateToFieldsType,\n  MonthDayFromFieldsObject,\n  Overflow,\n  Resolve\n} from './internaltypes';\n\nfunction arrayFromSet<T>(src: Set<T>): T[] {\n  return [...src];\n}\n\nfunction calendarDateWeekOfYear(id: BuiltinCalendarId, isoDate: ISODate): { week: number; year: number } | undefined {\n  // Supports only Gregorian and ISO8601 calendar; can be updated to add support for other calendars.\n  // Returns undefined for calendars without a well-defined week calendar system.\n  // eslint-disable-next-line max-len\n  // Also see: https://github.com/unicode-org/icu/blob/ab72ab1d4a3c3f9beeb7d92b0c7817ca93dfdb04/icu4c/source/i18n/calendar.cpp#L1606\n  if (id !== 'gregory' && id !== 'iso8601') return undefined;\n  const calendar = impl[id];\n  let yow = isoDate.year;\n  const { dayOfWeek, dayOfYear, daysInYear } = calendar.isoToDate(isoDate, {\n    dayOfWeek: true,\n    dayOfYear: true,\n    daysInYear: true\n  });\n  const fdow = calendar.getFirstDayOfWeek();\n  const mdow = calendar.getMinimalDaysInFirstWeek();\n  ES.uncheckedAssertNarrowedType<number>(fdow, 'guaranteed to exist for iso8601/gregory');\n  ES.uncheckedAssertNarrowedType<number>(mdow, 'guaranteed to exist for iso8601/gregory');\n\n  // For both the input date and the first day of its calendar year, calculate the day of week\n  // relative to first day of week in the relevant calendar (e.g., in iso8601, relative to Monday).\n  let relDow = (dayOfWeek + 7 - fdow) % 7;\n  // Assuming the year length is less than 7000 days.\n  let relDowJan1 = (dayOfWeek - dayOfYear + 7001 - fdow) % 7;\n\n  let woy = Math.floor((dayOfYear - 1 + relDowJan1) / 7);\n  if (7 - relDowJan1 >= mdow) {\n    ++woy;\n  }\n\n  // Adjust for weeks at the year end that overlap into the previous or next calendar year.\n  if (woy == 0) {\n    // Check for last week of previous year; if true, handle the case for\n    // first week of next year\n    const prevYearCalendar = calendar.isoToDate(calendar.dateAdd(isoDate, { years: -1 }, 'constrain'), {\n      daysInYear: true\n    });\n    let prevDoy = dayOfYear + prevYearCalendar.daysInYear;\n    woy = weekNumber(fdow, mdow, prevDoy, dayOfWeek);\n    yow--;\n  } else {\n    // For it to be week 1 of the next year, dayOfYear must be >= lastDoy - 5\n    //          L-5                  L\n    // doy: 359 360 361 362 363 364 365 001\n    // dow:      1   2   3   4   5   6   7\n    let lastDoy = daysInYear;\n    if (dayOfYear >= lastDoy - 5) {\n      let lastRelDow = (relDow + lastDoy - dayOfYear) % 7;\n      if (lastRelDow < 0) {\n        lastRelDow += 7;\n      }\n      if (6 - lastRelDow >= mdow && dayOfYear + 7 - relDow > lastDoy) {\n        woy = 1;\n        yow++;\n      }\n    }\n  }\n  return { week: woy, year: yow };\n}\n\nfunction ISODateSurpasses(sign: -1 | 0 | 1, y1: number, m1: number, d1: number, isoDate2: ISODate) {\n  if (y1 !== isoDate2.year) {\n    if (sign * (y1 - isoDate2.year) > 0) return true;\n  } else if (m1 !== isoDate2.month) {\n    if (sign * (m1 - isoDate2.month) > 0) return true;\n  } else if (d1 !== isoDate2.day) {\n    if (sign * (d1 - isoDate2.day) > 0) return true;\n  }\n  return false;\n}\n\ntype ResolveFieldsReturn<Type extends ISODateToFieldsType> = Resolve<\n  CalendarFieldsRecord & {\n    year: Type extends 'date' ? number : never;\n    month: number;\n    monthCode: string;\n    day: number;\n  }\n>;\n\n/**\n * Shape of internal implementation of each built-in calendar. Note that\n * parameter types are simpler than CalendarProtocol because the `Calendar`\n * class performs validation and parameter normalization before handing control\n * over to CalendarImpl.\n *\n * There are two instances of this interface: one for the ISO calendar and\n * another that handles logic that's the same across all non-ISO calendars. The\n * latter is cloned for each non-ISO calendar at the end of this file.\n */\nexport interface CalendarImpl {\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >(\n    isoDate: ISODate,\n    requestedFields: Request\n  ): T;\n  getFirstDayOfWeek(): number | undefined;\n  getMinimalDaysInFirstWeek(): number | undefined;\n  resolveFields<Type extends ISODateToFieldsType>(\n    fields: CalendarFieldsRecord,\n    type: Type\n  ): asserts fields is ResolveFieldsReturn<Type>;\n  dateToISO(fields: ResolveFieldsReturn<'date'>, overflow: Overflow): ISODate;\n  monthDayToISOReferenceDate(fields: ResolveFieldsReturn<'month-day'>, overflow: Overflow): ISODate;\n  dateAdd(date: ISODate, duration: Partial<DateDuration>, overflow: Overflow): ISODate;\n  dateUntil(one: ISODate, two: ISODate, largestUnit: 'year' | 'month' | 'week' | 'day'): DateDuration;\n  extraFields(fields: FieldKey[]): FieldKey[];\n  fieldKeysToIgnore(keys: FieldKey[]): FieldKey[];\n}\n\ntype CalendarImplementations = {\n  [k in BuiltinCalendarId]: CalendarImpl;\n};\n\n/**\n * Implementations for each calendar.\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\n * at the bottom of the file.\n */\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\n\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n  resolveFields(fields, type) {\n    if ((type === 'date' || type === 'year-month') && fields.year === undefined) {\n      throw new TypeError('year is required');\n    }\n    if ((type === 'date' || type === 'month-day') && fields.day === undefined) {\n      throw new TypeError('day is required');\n    }\n    Object.assign(fields, resolveNonLunisolarMonth(fields));\n  },\n  dateToISO(fields, overflow) {\n    return ES.RegulateISODate(fields.year, fields.month, fields.day, overflow);\n  },\n  monthDayToISOReferenceDate(fields, overflow) {\n    const referenceISOYear = 1972;\n    const { month, day } = ES.RegulateISODate(fields.year ?? referenceISOYear, fields.month, fields.day, overflow);\n    return { month, day, year: referenceISOYear };\n  },\n  extraFields() {\n    return [];\n  },\n  fieldKeysToIgnore(keys) {\n    const result = new Set<FieldKey>();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      result.add(key);\n      if (key === 'month') {\n        result.add('monthCode');\n      } else if (key === 'monthCode') {\n        result.add('month');\n      }\n    }\n    return arrayFromSet(result);\n  },\n  dateAdd(isoDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow) {\n    let { year, month, day } = isoDate;\n    year += years;\n    month += months;\n    ({ year, month } = ES.BalanceISOYearMonth(year, month));\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n    day += days + 7 * weeks;\n    return ES.BalanceISODate(year, month, day);\n  },\n  dateUntil(one, two, largestUnit) {\n    const sign = -ES.CompareISODate(one, two);\n    if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\n    ES.uncheckedAssertNarrowedType<-1 | 1>(sign, \"the - operator's return type is number\");\n\n    let years = 0;\n    let months = 0;\n    let intermediate;\n    if (largestUnit === 'year' || largestUnit === 'month') {\n      // We can skip right to the neighbourhood of the correct number of years,\n      // it'll be at least one less than two.year - one.year (unless it's zero)\n      let candidateYears = two.year - one.year;\n      if (candidateYears !== 0) candidateYears -= sign;\n      // loops at most twice\n      while (!ISODateSurpasses(sign, one.year + candidateYears, one.month, one.day, two)) {\n        years = candidateYears;\n        candidateYears += sign;\n      }\n\n      let candidateMonths = sign;\n      intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + candidateMonths);\n      // loops at most 12 times\n      while (!ISODateSurpasses(sign, intermediate.year, intermediate.month, one.day, two)) {\n        months = candidateMonths;\n        candidateMonths += sign;\n        intermediate = ES.BalanceISOYearMonth(intermediate.year, intermediate.month + sign);\n      }\n\n      if (largestUnit === 'month') {\n        months += years * 12;\n        years = 0;\n      }\n    }\n\n    intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + months);\n    const constrained = ES.ConstrainISODate(intermediate.year, intermediate.month, one.day);\n\n    let weeks = 0;\n    let days =\n      ES.ISODateToEpochDays(two.year, two.month - 1, two.day) -\n      ES.ISODateToEpochDays(constrained.year, constrained.month - 1, constrained.day);\n\n    if (largestUnit === 'week') {\n      weeks = Math.trunc(days / 7);\n      days %= 7;\n    }\n\n    return { years, months, weeks, days };\n  },\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >({ year, month, day }: ISODate, requestedFields: Request): T {\n    // requestedFields parameter is not part of the spec text. It's an\n    // illustration of one way implementations may choose to optimize this\n    // operation.\n    const date: Partial<CalendarDateRecord> = {\n      era: undefined,\n      eraYear: undefined,\n      year,\n      month,\n      day,\n      daysInWeek: 7,\n      monthsInYear: 12\n    };\n    if (requestedFields.monthCode) date.monthCode = buildMonthCode(month);\n    if (requestedFields.dayOfWeek) {\n      // https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Disparate_variation\n      const shiftedMonth = month + (month < 3 ? 10 : -2);\n      const shiftedYear = year - (month < 3 ? 1 : 0);\n\n      const century = Math.floor(shiftedYear / 100);\n      const yearInCentury = shiftedYear - century * 100;\n\n      const monthTerm = Math.floor(2.6 * shiftedMonth - 0.2);\n      const yearTerm = yearInCentury + Math.floor(yearInCentury / 4);\n      const centuryTerm = Math.floor(century / 4) - 2 * century;\n\n      const dow = (day + monthTerm + yearTerm + centuryTerm) % 7;\n\n      date.dayOfWeek = dow + (dow <= 0 ? 7 : 0);\n    }\n    if (requestedFields.dayOfYear) {\n      let days = day;\n      for (let m = month - 1; m > 0; m--) {\n        days += ES.ISODaysInMonth(year, m);\n      }\n      date.dayOfYear = days;\n    }\n    if (requestedFields.weekOfYear) date.weekOfYear = calendarDateWeekOfYear('iso8601', { year, month, day });\n    if (requestedFields.daysInMonth) date.daysInMonth = ES.ISODaysInMonth(year, month);\n    if (requestedFields.daysInYear || requestedFields.inLeapYear) {\n      date.inLeapYear = ES.LeapYear(year);\n      date.daysInYear = date.inLeapYear ? 366 : 365;\n    }\n    return date as T;\n  },\n  getFirstDayOfWeek() {\n    return 1;\n  },\n  getMinimalDaysInFirstWeek() {\n    return 4;\n  }\n};\n\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\n// proposal for ECMA-262. These calendars will be standardized as part of\n// ECMA-402. Code below here includes an implementation of these calendars to\n// validate the Temporal API and to get feedback. However, native non-ISO\n// calendar behavior is at least somewhat implementation-defined, so may not\n// match this polyfill's output exactly.\n//\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\n// to ensure a clean separation between the ISO calendar implementation which is\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\n// ECMA-402.\n//\n// To ensure this separation, the implementation is split. A `CalendarImpl`\n// interface defines the common operations between both ISO and non-ISO\n// calendars.\n\n/**\n * This type is passed through from CalendarImpl#dateFromFields().\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\n */\ntype CalendarDateFields = CalendarFieldsRecord & { monthExtra?: string };\n\n/**\n * This is a \"fully populated\" calendar date record. It's only lacking\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\n * which is only used in some cases.\n */\ntype FullCalendarDate = {\n  era?: string;\n  eraYear?: number;\n  year: number;\n  month: number;\n  monthCode: string;\n  day: number;\n  monthExtra?: string;\n};\n\n// The types below are various subsets of calendar dates\ntype CalendarYM = { year: number; month: number };\ntype CalendarYearOnly = { year: number };\ntype EraAndEraYear = { era: string; eraYear: number };\n\nfunction nonLeapMonthCodeNumberPart(monthCode: string) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n  const month = +monthCode.slice(1);\n  if (Number.isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month: number, leap = false) {\n  const digitPart = `${month}`.padStart(2, '0');\n  const leapMarker = leap ? 'L' : '';\n  return `M${digitPart}${leapMarker}`;\n}\n\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\n  calendarDate: T,\n  overflow: Overflow | undefined = undefined,\n  monthsPerYear = 12\n) {\n  let { month, monthCode } = calendarDate;\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\n    // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = nonLeapMonthCodeNumberPart(monthCode);\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n  return { ...calendarDate, month, monthCode };\n}\n\nfunction weekNumber(firstDayOfWeek: number, minimalDaysInFirstWeek: number, desiredDay: number, dayOfWeek: number) {\n  let periodStartDayOfWeek = (dayOfWeek - firstDayOfWeek - desiredDay + 1) % 7;\n  if (periodStartDayOfWeek < 0) periodStartDayOfWeek += 7;\n  let weekNo = Math.floor((desiredDay + periodStartDayOfWeek - 1) / 7);\n  if (7 - periodStartDayOfWeek >= minimalDaysInFirstWeek) {\n    ++weekNo;\n  }\n  return weekNo;\n}\n\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n  map = new Map();\n  calls = 0;\n  // now = OneObjectCache.monotonicTimestamp();\n  hits = 0;\n  misses = 0;\n\n  // static monotonicTimestamp() {\n  //   return performance?.now() ?? Date.now();\n  // }\n\n  constructor(cacheToClone?: OneObjectCache) {\n    if (cacheToClone !== undefined) {\n      let i = 0;\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n  get(key: string) {\n    const result = this.map.get(key);\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n    this.calls++;\n    return result;\n  }\n  set(key: string, value: unknown) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n  report() {\n    // if (this.calls === 0) return;\n    // const ms = OneObjectCache.monotonicTimestamp() - this.now;\n    // const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    // const t = `${ms.toFixed(2)}ms`;\n    // // eslint-disable-next-line no-console\n    // console.log(`${this.calls} calls in ${t}. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n  }\n  setObject(obj: ISODate) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n\n  static objectMap = new WeakMap();\n  static MAX_CACHE_ENTRIES = 1000;\n\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n  static getCacheForObject(obj: ISODate) {\n    let cache = OneObjectCache.objectMap.get(obj);\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n    return cache;\n  }\n}\n\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\n  const yearString = ES.ISOYearString(isoYear);\n  const monthString = ES.ISODateTimePartString(isoMonth);\n  const dayString = ES.ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nabstract class HelperBase {\n  abstract id: BuiltinCalendarId;\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\n  abstract maxLengthOfMonthCodeInAnyYear(monthCode: string): number;\n  abstract estimateIsoDate(calendarDate: CalendarYMD): ISODate;\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T;\n  eras: Era[] = [];\n  checkIcuBugs?(isoDate: ISODate): void;\n  private formatter?: globalThis.Intl.DateTimeFormat;\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the HelperBase class is extended to\n    // create each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new Intl.DateTimeFormat(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: 'short',\n        timeZone: 'UTC'\n      });\n    }\n    return this.formatter;\n  }\n  getCalendarParts(isoString: string) {\n    let dateTimeFormat = this.getFormatter();\n    let legacyDate = new Date(isoString);\n\n    // PlainDate's minimum date -271821-04-19 is one day beyond legacy Date's\n    // minimum -271821-04-20, because of accommodating all Instants in all time\n    // zones. If we have -271821-04-19, instead format -271821-04-20 in a time\n    // zone that pushes the result into the previous day. This is a slow path\n    // because we create a new Intl.DateTimeFormat.\n    if (isoString === '-271821-04-19T00:00Z') {\n      const options = dateTimeFormat.resolvedOptions();\n      dateTimeFormat = new Intl.DateTimeFormat(options.locale, {\n        ...(options as Intl.DateTimeFormatOptions),\n        timeZone: 'Etc/GMT+1'\n      });\n      legacyDate = new Date('-271821-04-20T00:00Z');\n    }\n\n    try {\n      return dateTimeFormat.formatToParts(legacyDate);\n    } catch (e) {\n      throw new RangeError(`Invalid ISO date: ${isoString}`);\n    }\n  }\n  isoToCalendarDate(isoDate: ISODate, cache: OneObjectCache): FullCalendarDate {\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n\n    const isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n    const parts = this.getCalendarParts(isoString);\n    const result: Partial<FullCalendarDate> = {};\n    for (let i = 0; i < parts.length; i++) {\n      const { type, value } = parts[i];\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n      if (type === 'year' || type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) {\n        if (this.hasEra) {\n          result.eraYear = +value;\n        } else {\n          result.year = +value;\n        }\n      }\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        }\n        // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n        result.month = matches[1] ? +matches[1] : 1;\n        if (result.month < 1) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\n          );\n        }\n        if (result.month > 13) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n          );\n        }\n\n        // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n      if (type === 'day') result.day = +value;\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        result.era = value\n          .split(' (')[0]\n          .normalize('NFD')\n          .replace(/[^-0-9 \\p{L}]/gu, '')\n          .replace(/ /g, '-')\n          .toLowerCase();\n      }\n    }\n    if (this.hasEra && result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n      );\n    }\n    // Translate old ICU era codes \"ERA0\" etc. into canonical era names.\n    if (this.hasEra) {\n      const replacement = this.eras.find((e) => result.era === e.genericName);\n      if (replacement) result.era = replacement.code;\n    }\n    // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n    if (this.reviseIntlEra) {\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) {\n      throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    }\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate);\n    // Also cache the reverse mapping\n    const cacheReverse = (overflow: Overflow) => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    };\n    (['constrain', 'reject'] as const).forEach(cacheReverse);\n    return calendarDate;\n  }\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\n    const { month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) {\n        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n      }\n    }\n    if (this.hasEra) {\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\n        throw new TypeError('properties era and eraYear must be provided together');\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras\n   * - non-lunisolar calendar (no leap months)\n   * */\n  adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache: OneObjectCache | undefined = undefined,\n    overflow: Overflow = 'constrain',\n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate);\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, monthCode } = calendarDate;\n\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\n  }\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, day } = calendarDate;\n    if (overflow === 'reject') {\n      ES.RejectToRange(month, 1, largestMonth);\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ES.ConstrainToRange(month, 1, largestMonth);\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n    }\n    return { ...calendarDate, month, day };\n  }\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): ISODate {\n    const originalDate = dateParam as Partial<FullCalendarDate>;\n    // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n\n    const { year, month, day } = date;\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n    let cached = cache.get(key);\n    if (cached) return cached;\n    // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n    let keyOriginal;\n    if (\n      originalDate.year !== undefined &&\n      originalDate.month !== undefined &&\n      originalDate.day !== undefined &&\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\n    ) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    }\n\n    // First, try to roughly guess the result\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\n    const calculateSameMonthResult = (diffDays: number) => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But\n      // current ICU calendars only skip days (japanese/roc/buddhist) because of\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently worked around by a custom calendarToIsoDate\n      // implementation in those calendars. So this optimization should be safe\n      // for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          }\n          // Back up a day at a time until we're not hanging over the month end\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n      return testIsoEstimate;\n    };\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    }\n    // If the initial guess is not in the same month, then bisect the\n    // distance to the target, starting with 8 days per step.\n    let increment = 8;\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days);\n          // Signal the loop condition that there's a match.\n          sign = 0;\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n              // If current value is larger, then back up to the previous value.\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n    if (\n      date.year === undefined ||\n      date.month === undefined ||\n      date.day === undefined ||\n      date.monthCode === undefined ||\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\n    ) {\n      throw new RangeError('Unexpected missing property');\n    }\n    return isoEstimate;\n  }\n  compareCalendarDates(date1: CalendarYMD, date2: CalendarYMD) {\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n  addDaysIso(isoDate: ISODate, days: number): ISODate {\n    const added = ES.BalanceISODate(isoDate.year, isoDate.month, isoDate.day + days);\n    return added;\n  }\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n  addMonthsCalendar(\n    calendarDateParam: CalendarYMD,\n    months: number,\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): CalendarYMD {\n    let calendarDate = calendarDateParam;\n    const { day } = calendarDate;\n    for (let i = 0, absMonths = Math.abs(months); i < absMonths; i++) {\n      const { month } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days =\n        months < 0\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n          : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\n\n      // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n      }\n    }\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n    return calendarDate;\n  }\n  addCalendar(\n    calendarDate: CalendarYMD & { monthCode: string },\n    { years = 0, months = 0, weeks = 0, days = 0 },\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const { year, day, monthCode } = calendarDate;\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n  untilCalendar(\n    calendarOne: FullCalendarDate,\n    calendarTwo: FullCalendarDate,\n    largestUnit: Temporal.DateUnit,\n    cache: OneObjectCache\n  ): { years: number; months: number; weeks: number; days: number } {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n      case 'week': {\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        days = totalDays % 7;\n        weeks = (totalDays - days) / 7;\n        break;\n      }\n      case 'month':\n      case 'year': {\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n        if (!sign) {\n          return { years: 0, months: 0, weeks: 0, days: 0 };\n        }\n        const diffYears = calendarTwo.year - calendarOne.year;\n        const diffDays = calendarTwo.day - calendarOne.day;\n        if (largestUnit === 'year' && diffYears) {\n          let diffInYearSign = 0;\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\n        }\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n        // Now we have less than one year remaining. Add one month at a time\n        // until we go over the target, then back up one month and calculate\n        // remaining days and weeks.\n        let current;\n        let next: CalendarYMD = yearsAdded;\n        do {\n          months += sign;\n          current = next;\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n          if (next.day !== calendarOne.day) {\n            // In case the day was constrained down, try to un-constrain it\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n          }\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n        months -= sign; // correct for loop above which overshoots by 1\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n        days = remainingDays;\n        break;\n      }\n    }\n    return { years, months, weeks, days };\n  }\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But current\n    // ICU calendars only skip days (japanese/roc/buddhist) because of a bug\n    // (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158) that's\n    // currently worked around by a custom calendarToIsoDate implementation in\n    // those calendars. So this code should be safe for all ICU calendars.\n    const { day } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate);\n    // easiest case: we already know the month length if min and max are the same.\n    if (min === max) return min;\n\n    // Add enough days to get into the next month, without skipping it\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n\n    // Now back up to the last day of the original month\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    const { day, month, year } = calendarDate;\n\n    // Check to see if we already know the month length, and return it if so\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n  }\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n  }\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return (\n      ES.ISODateToEpochDays(twoIso.year, twoIso.month - 1, twoIso.day) -\n      ES.ISODateToEpochDays(oneIso.year, oneIso.month - 1, oneIso.day)\n    );\n  }\n  // Override if calendar uses eras\n  hasEra = false;\n  // See https://github.com/tc39/proposal-temporal/issues/1784\n  erasBeginMidYear = false;\n  // Override this to shortcut the search space if certain month codes only\n  // occur long in the past\n  monthDaySearchStartYear(monthCode: string, day: number) {\n    void monthCode, day;\n    return 1972;\n  }\n  monthDayFromFields(fields: MonthDayFromFieldsObject, overflow: Overflow, cache: OneObjectCache): ISODate {\n    let { era, eraYear, year, month, monthCode, day } = fields;\n    if (month !== undefined && year === undefined && (!this.hasEra || era === undefined || eraYear === undefined)) {\n      throw new TypeError('when month is present, year (or era and eraYear) are required');\n    }\n    if (monthCode === undefined || year !== undefined || (this.hasEra && eraYear !== undefined)) {\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso;\n    // Look backwards starting from one of the calendar years spanning ISO year\n    // 1972, up to 20 calendar years prior, to find a year that has this month\n    // and day. Normal months and days will match immediately, but for leap days\n    // and leap months we may have to look for a while. For searches longer than\n    // 20 years, override the start date in monthDaySearchStartYear.\n    const startDateIso = {\n      year: this.monthDaySearchStartYear(monthCode, day),\n      month: 12,\n      day: 31\n    };\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\n    // Note: relies on lexicographical ordering of monthCodes\n    const calendarYear =\n      calendarOfStartDateIso.monthCode > monthCode ||\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\n        ? calendarOfStartDateIso.year\n        : calendarOfStartDateIso.year - 1;\n    for (let i = 0; i < 20; i++) {\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\n        { day, monthCode, year: calendarYear - i },\n        cache\n      );\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return { month: isoMonth, day: isoDay, year: isoYear };\n      } else if (overflow === 'constrain') {\n        // If the requested day is never present in any instance of this month\n        // code, and the round trip date is an instance of this month code with\n        // the most possible days, we are as close as we can get.\n        const maxDayForMonthCode = this.maxLengthOfMonthCodeInAnyYear(roundTripCalendarDate.monthCode);\n        if (\n          roundTripCalendarDate.monthCode === monthCode &&\n          roundTripCalendarDate.day === maxDayForMonthCode &&\n          day > maxDayForMonthCode\n        ) {\n          return { month: isoMonth, day: isoDay, year: isoYear };\n        }\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (\n          closestCalendar === undefined ||\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n            roundTripCalendarDate.day > closestCalendar.day)\n        ) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n  getFirstDayOfWeek(): number | undefined {\n    return undefined;\n  }\n  getMinimalDaysInFirstWeek(): number | undefined {\n    return undefined;\n  }\n}\n\ninterface HebrewMonthInfo {\n  [m: string]: (\n    | {\n        leap: undefined;\n        regular: number;\n      }\n    | {\n        leap: number;\n        regular: undefined;\n      }\n    | {\n        leap: number;\n        regular: number;\n      }\n  ) & {\n    monthCode: string;\n    days:\n      | number\n      | {\n          min: number;\n          max: number;\n        };\n  };\n}\n\nclass HebrewHelper extends HelperBase {\n  id = 'hebrew' as const;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = calendarDate;\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n    return (7 * year + 1) % 19 < 7;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\n    const { month, year } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = Object.entries(this.months).find((m) => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    return ['M04', 'M06', 'M08', 'M10', 'M12'].includes(monthCode) ? 29 : 30;\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = calendarDate;\n    return { year: year - 3760, month: 1, day: 1 };\n  }\n  months: HebrewMonthInfo = {\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n  };\n  getMonthCode(year: number, month: number) {\n    if (this.inLeapYear({ year })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthCode, day, monthExtra } = calendarDate as Omit<typeof calendarDate, 'day'> & {\n      day: number;\n    };\n    if (year === undefined) throw new TypeError('Missing property: year');\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n      }\n      // Because we're getting data from legacy Date, then `month` will always be present\n      monthCode = this.getMonthCode(year, month as number);\n      return { year, month: month as number, day, monthCode };\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        if (monthCode.endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n          month = 6;\n          if (!this.inLeapYear({ year })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to same day of next month (Adar)\n              month = 6;\n              monthCode = 'M06';\n            }\n          }\n        } else {\n          month = nonLeapMonthCodeNumberPart(monthCode);\n          // if leap month is before this one, the month index is one more than the month code\n          if (this.inLeapYear({ year }) && month >= 6) month++;\n          const largestMonth = this.monthsInYear({ year });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n        } else {\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n        }\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n      return { ...calendarDate, day, month, monthCode, year };\n    }\n  }\n}\n\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nabstract class IslamicBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const startOfYearCalendar = { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n    const startOfNextYearCalendar = { year: calendarDate.year + 1, month: 1, monthCode: 'M01', day: 1 };\n    const result = this.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result === 355;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(/* monthCode */) {\n    return 30;\n  }\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n  DAYS_PER_ISO_YEAR = 365.2425;\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: Math.floor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n  }\n}\n\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n  id = 'islamic' as const;\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  id = 'islamic-umalqura' as const;\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  id = 'islamic-tbla' as const;\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  id = 'islamic-civil' as const;\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  id = 'islamic-rgsa' as const;\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n  id = 'islamicc' as const;\n}\n\nclass PersianHelper extends HelperBase {\n  id = 'persian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // If the last month has 30 days, it's a leap year.\n    return this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache) === 30;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return month <= 6 ? 31 : 30;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: year + 621, month: 1, day: 1 };\n  }\n}\n\ninterface IndianMonthInfo {\n  [month: number]: {\n    length: number;\n    month: number;\n    day: number;\n    leap?: {\n      length: number;\n      month: number;\n      day: number;\n    };\n    nextYear?: true | undefined;\n  };\n}\n\nclass IndianHelper extends HelperBase {\n  id = 'indian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    let monthInfo = this.months[month];\n    monthInfo = monthInfo.leap ?? monthInfo;\n    return monthInfo.length;\n  }\n  // Indian months always start at the same well-known Gregorian month and\n  // day. So this conversion is easy and fast. See\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\n  months: IndianMonthInfo = {\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n    2: { length: 31, month: 4, day: 21 },\n    3: { length: 31, month: 5, day: 22 },\n    4: { length: 31, month: 6, day: 22 },\n    5: { length: 31, month: 7, day: 23 },\n    6: { length: 31, month: 8, day: 23 },\n    7: { length: 30, month: 9, day: 23 },\n    8: { length: 30, month: 10, day: 23 },\n    9: { length: 30, month: 11, day: 22 },\n    10: { length: 30, month: 12, day: 22 },\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\n  };\n  getMonthInfo(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = ES.BalanceISODate(isoYear, isoMonth, isoDay + calendarDate.day - 1);\n    return isoDate;\n  }\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n  // expected.\n  vulnerableToBceBug =\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n  override checkIcuBugs(isoDate: ISODate) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n      );\n    }\n  }\n}\n\n/**\n * Era metadata defined for each calendar.\n * TODO: instead of optional properties, this should really have rules\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\n *  */\ninterface InputEra {\n  /**\n   * Era code, used to populate the 'era' field of Temporal instances.\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   */\n  code: string;\n\n  /**\n   * Names are additionally accepted as alternate era codes on input, and the\n   * first name is also output in error messages (and may be the era code if\n   * desired.)\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   * If absent, this field defaults to a single element matching the code.\n   */\n  names?: string[];\n\n  /**\n   * Signed calendar year where this era begins.Will be\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\n   * numbering starts at the beginning of the anchor era, which is true\n   * for all ICU calendars except Japanese. If an era starts mid-year\n   * then a calendar month and day are included. Otherwise\n   * `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch?: { year: number; month: number; day: number };\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: string;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n/**\n * Transformation of the `InputEra` type with all fields filled in by\n * `adjustEras()`\n * */\ninterface Era {\n  /**\n   * Era code, used to populate the 'era' field of Temporal instances.\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   */\n  code: string;\n\n  /**\n   * Names are additionally accepted as alternate era codes on input, and the\n   * first name is also output in error messages (and may be the era code if\n   * desired.)\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   * If absent, this field defaults to a single element matching the code.\n   */\n  names: string[];\n\n  /**\n   * alternate name of the era used in old versions of ICU data\n   * format is `era{n}` where n is the zero-based index of the era\n   * with the oldest era being 0.\n   * */\n  genericName: string;\n\n  /**\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\n   * eras) for the anchor era assuming that `year` numbering starts at the\n   * beginning of the anchor era, which is true for all ICU calendars except\n   * Japanese. For input, the month and day are optional. If an era starts\n   * mid-year then a calendar month and day are included.\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch: CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch: ISODate;\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: Era;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\n  let eras: (InputEra | Era)[] = erasParam;\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n  if (eras.length === 1 && !eras[0].code) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  }\n\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n  let anchorEra: Era | InputEra | undefined;\n  eras.forEach((e) => {\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n    } else if (!e.code) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  });\n\n  // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n  eras = eras.filter((e) => e.code);\n\n  eras.forEach((e) => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const { reverseOf } = e;\n    if (reverseOf) {\n      const reversedEra = eras.find((era) => era.code === reverseOf);\n      if (reversedEra === undefined) {\n        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      }\n      e.reverseOf = reversedEra as Era; // genericName property added later\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n    type YMD = {\n      year: number;\n      month: number;\n      day: number;\n    };\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\n  });\n\n  // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n  eras.sort((e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  });\n\n  // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) {\n      throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n  }\n\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n  eras.forEach((e, i) => {\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\n  });\n\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\n}\n\nfunction isGregorianLeapYear(year: number) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n/** Base for all Gregorian-like calendars. */\nabstract class GregorianBaseHelperFixedEpoch extends HelperBase {\n  id: BuiltinCalendarId;\n  isoEpoch: ISODate;\n\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\n    super();\n    this.id = id;\n    this.isoEpoch = isoEpoch;\n  }\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    return ES.RegulateISODate(\n      calendarDate.year + this.isoEpoch.year,\n      calendarDate.month + this.isoEpoch.month,\n      calendarDate.day + this.isoEpoch.day,\n      'constrain'\n    );\n  }\n}\n\n/** Base for Gregorian-like calendars with eras. */\nabstract class GregorianBaseHelper extends HelperBase {\n  id: BuiltinCalendarId;\n  anchorEra: Era;\n\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super();\n    this.id = id;\n    const { eras, anchorEra } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n  override hasEra = true;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n  completeEraYear(\n    calendarDate: FullCalendarDate\n  ): FullCalendarDate & Required<Pick<FullCalendarDate, 'era' | 'eraYear'>> {\n    const checkField = (property: keyof FullCalendarDate, value: string | number | undefined, names?: string[]) => {\n      const currentValue = calendarDate[property];\n      if (currentValue != null && currentValue != value && !((names || []) as unknown[]).includes(currentValue)) {\n        // Prefer displaying an era alias, instead of \"gregory-inverse\"\n        const preferredName = names?.[0];\n        const expected = preferredName ? `${value} (also called ${preferredName})` : value;\n        throw new RangeError(`Input ${property} ${currentValue} doesn't match calculated value ${expected}`);\n      }\n    };\n    const eraFromYear = (year: number) => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate, year };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.code}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          }\n          // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return { eraYear: eraYear as unknown as number, era: matchingEra.code, eraNames: matchingEra.names };\n    };\n\n    let { year, eraYear, era } = calendarDate;\n    if (year != null) {\n      const matchData = eraFromYear(year);\n      ({ eraYear, era } = matchData);\n      checkField('era', era, matchData?.eraNames);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      if (era === undefined) throw new RangeError('era and eraYear must be provided together');\n      // TS limitation: https://github.com/microsoft/TypeScript/issues/11498\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const matchingEra = this.eras.find(({ code, names = [] }) => code === era || names.includes(era!));\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n      checkField('year', year);\n      // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n      ({ eraYear, era } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either year or eraYear and era are required');\n    }\n    return { ...calendarDate, year, eraYear, era };\n  }\n  override adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain'\n  ): FullCalendarDate {\n    let calendarDate = calendarDateParam;\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n    const { month, monthCode } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate, month: nonLeapMonthCodeNumberPart(monthCode as string) };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const { year, month, day } = calendarDate;\n    const { anchorEra } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n}\n\n/**\n * Some calendars are identical to Gregorian except era and year. For these\n * calendars, we can avoid using Intl.DateTimeFormat and just calculate the\n * year, era, and eraYear. This is faster (because Intl.DateTimeFormat is slow\n * and uses a huge amount of RAM), and it avoids ICU bugs like\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n */\nabstract class SameMonthDayAsGregorianBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override isoToCalendarDate(isoDate: ISODate): FullCalendarDate {\n    // Month and day are same as ISO, so bypass Intl.DateTimeFormat and\n    // calculate the year, era, and eraYear here.\n    const { year: isoYear, month, day } = isoDate;\n    const monthCode = buildMonthCode(month);\n    const year = isoYear - this.anchorEra.isoEpoch.year + 1;\n    return this.completeEraYear({ year, month, monthCode, day });\n  }\n}\nconst OrthodoxOps = {\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const { year } = calendarDate;\n    return (year + 1) % 4 === 0;\n  },\n  monthsInYear(/* calendarDate */) {\n    return 13;\n  },\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  },\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minimumMonthLength(calendarDate);\n  },\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    return monthCode === 'M13' ? 6 : 30;\n  }\n};\nabstract class OrthodoxBaseHelperFixedEpoch extends GregorianBaseHelperFixedEpoch {\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\n    super(id, isoEpoch);\n  }\n  override inLeapYear = OrthodoxOps.inLeapYear;\n  override monthsInYear = OrthodoxOps.monthsInYear;\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\n}\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override inLeapYear = OrthodoxOps.inLeapYear;\n  override monthsInYear = OrthodoxOps.monthsInYear;\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\n}\n\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelperFixedEpoch {\n  constructor() {\n    super('ethioaa', { year: -5492, month: 7, day: 17 });\n  }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [\n      { code: 'coptic', isoEpoch: { year: 284, month: 8, day: 29 } },\n      { code: 'coptic-inverse', reverseOf: 'coptic' }\n    ]);\n  }\n}\n\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [\n      { code: 'ethioaa', names: ['ethiopic-amete-alem', 'mundi'], isoEpoch: { year: -5492, month: 7, day: 17 } },\n      { code: 'ethiopic', names: ['incar'], isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n    ]);\n  }\n}\n\nclass RocHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('roc', [\n      { code: 'roc', names: ['minguo'], isoEpoch: { year: 1912, month: 1, day: 1 } },\n      { code: 'roc-inverse', names: ['before-roc'], reverseOf: 'roc' }\n    ]);\n  }\n}\n\nclass BuddhistHelper extends GregorianBaseHelperFixedEpoch {\n  constructor() {\n    super('buddhist', { year: -543, month: 1, day: 1 });\n  }\n}\n\nclass GregoryHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('gregory', [\n      { code: 'gregory', names: ['ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\n      { code: 'gregory-inverse', names: ['be', 'bce'], reverseOf: 'gregory' }\n    ]);\n  }\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\n    let { era, eraYear } = calendarDate;\n    // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n    if (era === 'b') era = 'gregory-inverse';\n    if (era === 'a') era = 'gregory';\n    return { era, eraYear } as T;\n  }\n  override getFirstDayOfWeek() {\n    return 1;\n  }\n  override getMinimalDaysInFirstWeek() {\n    return 1;\n  }\n}\n\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('japanese', [\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n      { code: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n      { code: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n      { code: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n      { code: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n      { code: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n      { code: 'japanese', names: ['japanese', 'gregory', 'ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\n      { code: 'japanese-inverse', names: ['japanese-inverse', 'gregory-inverse', 'bc', 'bce'], reverseOf: 'japanese' }\n    ]);\n  }\n\n  override erasBeginMidYear = true;\n\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T {\n    const { era, eraYear } = calendarDate;\n    const { year: isoYear } = isoDate;\n    if (this.eras.find((e) => e.code === era)) return { era, eraYear } as T;\n    return (\n      isoYear < 1 ? { era: 'japanese-inverse', eraYear: 1 - isoYear } : { era: 'japanese', eraYear: isoYear }\n    ) as T;\n  }\n}\n\ninterface ChineseMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth: number };\n}\ninterface ChineseDraftMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth?: number };\n}\n\nabstract class ChineseBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return Object.entries(months).length === 13;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    // See note below about ICU4C vs ICU4X. It is possible this override should\n    // always return 30.\n    return ['M01L', 'M09L', 'M10L', 'M11L', 'M12L'].includes(monthCode) ? 29 : 30;\n  }\n  override monthDaySearchStartYear(monthCode: string, day: number) {\n    // Note that ICU4C actually has _no_ years in which leap months M01L and\n    // M09L through M12L have 30 days. The values marked with (*) here are years\n    // in which the leap month occurs with 29 days. ICU4C disagrees with ICU4X\n    // here and it is not clear which is correct.\n    const monthMap: Record<string, [number, number]> = {\n      M01L: [1651, 1651], // *\n      M02L: [1947, 1765],\n      M03L: [1966, 1955],\n      M04L: [1963, 1944],\n      M05L: [1971, 1952],\n      M06L: [1960, 1941],\n      M07L: [1968, 1938],\n      M08L: [1957, 1718],\n      M09L: [1832, 1832], // *\n      M10L: [1870, 1870], // *\n      M11L: [1814, 1814], // *\n      M12L: [1890, 1890] // *\n    };\n    const years = monthMap[monthCode] ?? [1972, 1972];\n    return day < 30 ? years[0] : years[1];\n  }\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n      const legacyDate = new Date(isoStringFeb1);\n      // Now add the requested number of days, which may wrap to the next month.\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      // The 'month' and 'day' parts are guaranteed to be present because the\n      // formatter was created with month and day options.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month')!.value;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const calendarDay = +newYearGuess.find((tv) => tv.type === 'day')!.value;\n      const calendarYearPartToVerify = newYearGuess.find((tv) => (tv.type as string) === 'relatedYear');\n      let calendarYearToVerify: number | undefined;\n      if (calendarYearPartToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearPartToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n        );\n      }\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\n    };\n\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n    let isoDaysDelta = 17;\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n\n    // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n    }\n\n    // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n    isoDaysDelta -= calendarDay - 5;\n    const result = {} as ChineseDraftMonthInfo;\n    let monthIndex = 1;\n    let oldCalendarDay: number | undefined;\n    let oldMonthString: string | undefined;\n    let done = false;\n    do {\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n      if (oldCalendarDay) {\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\n        // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n        isoDaysDelta += 30;\n      }\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n\n    cache.set(key, result);\n    return result as ChineseMonthInfo;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year, month } = calendarDate;\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthExtra, day, monthCode } = calendarDate;\n    if (year === undefined) throw new TypeError('Missing property: year');\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return { year, month, day: day as number, monthCode };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex;\n\n        // If this leap month isn't present in this year, constrain to the same\n        // day of the previous month.\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\n          const withoutML = +monthCode.replace(/^M0?|L$/g, '');\n          monthInfo = months[withoutML];\n          if (monthInfo) {\n            month = monthInfo.monthIndex;\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year, cache);\n        const monthEntries = Object.entries(months);\n        const largestMonth = monthEntries.length;\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, largestMonth);\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\n        } else {\n          month = ES.ConstrainToRange(month, 1, largestMonth);\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n        const matchingMonthEntry = monthEntries.find((entry) => entry[1].monthIndex === month);\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n        monthCode = buildMonthCode(\n          +matchingMonthEntry[0].replace('bis', ''),\n          matchingMonthEntry[0].indexOf('bis') !== -1\n        );\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n      return { ...calendarDate, year, month, monthCode, day: day as number };\n    }\n  }\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  id = 'chinese' as const;\n}\n\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n  id = 'dangi' as const;\n}\n\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nclass NonIsoCalendar implements CalendarImpl {\n  constructor(private readonly helper: HelperBase) {}\n  extraFields(fields: FieldKey[]): FieldKey[] {\n    if (this.helper.hasEra && fields.includes('year')) {\n      return ['era', 'eraYear'];\n    }\n    return [];\n  }\n  resolveFields(fields: CalendarFieldsRecord /* , type */) {\n    if (this.helper.calendarType !== 'lunisolar') {\n      const cache = new OneObjectCache();\n      const largestMonth = this.helper.monthsInYear({ year: fields.year ?? 1972 }, cache);\n      resolveNonLunisolarMonth(fields, undefined, largestMonth);\n    }\n  }\n  dateToISO(fields: CalendarDateFields, overflow: Overflow) {\n    const cache = new OneObjectCache();\n    const result = this.helper.calendarToIsoDate(fields, overflow, cache);\n    cache.setObject(result);\n    return result;\n  }\n  monthDayToISOReferenceDate(fields: MonthDayFromFieldsObject, overflow: Overflow) {\n    const cache = new OneObjectCache();\n    const result = this.helper.monthDayFromFields(fields, overflow, cache);\n    // result.year is a reference year where this month/day exists in this calendar\n    cache.setObject(result);\n    return result;\n  }\n  fieldKeysToIgnore(\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\n    const result = new Set<(typeof keys)[number]>();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      result.add(key);\n      switch (key) {\n        case 'era':\n          result.add('eraYear');\n          result.add('year');\n          break;\n        case 'eraYear':\n          result.add('era');\n          result.add('year');\n          break;\n        case 'year':\n          result.add('era');\n          result.add('eraYear');\n          break;\n        case 'month':\n          result.add('monthCode');\n          // See https://github.com/tc39/proposal-temporal/issues/1784\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n        case 'monthCode':\n          result.add('month');\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n        case 'day':\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n      }\n    }\n    return arrayFromSet(result);\n  }\n  dateAdd(isoDate: ISODate, { years, months, weeks, days }: DateDuration, overflow: Overflow) {\n    const cache = OneObjectCache.getCacheForObject(isoDate);\n    const calendarDate = this.helper.isoToCalendarDate(isoDate, cache);\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    // The new object's cache starts with the cache of the old object\n    if (!OneObjectCache.getCacheForObject(isoAdded)) {\n      const newCache = new OneObjectCache(cache);\n      newCache.setObject(isoAdded);\n    }\n    return isoAdded;\n  }\n  dateUntil(one: ISODate, two: ISODate, largestUnit: Temporal.DateUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.isoToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.isoToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  }\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >(isoDate: ISODate, requestedFields: Request): T {\n    const cache = OneObjectCache.getCacheForObject(isoDate);\n    const calendarDate: Partial<CalendarDateRecord> & FullCalendarDate = this.helper.isoToCalendarDate(isoDate, cache);\n    if (requestedFields.dayOfWeek) {\n      calendarDate.dayOfWeek = impl['iso8601'].isoToDate(isoDate, { dayOfWeek: true }).dayOfWeek;\n    }\n    if (requestedFields.dayOfYear) {\n      const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n      const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n      calendarDate.dayOfYear = diffDays + 1;\n    }\n    if (requestedFields.weekOfYear) calendarDate.weekOfYear = calendarDateWeekOfYear(this.helper.id, isoDate);\n    calendarDate.daysInWeek = 7;\n    if (requestedFields.daysInMonth) calendarDate.daysInMonth = this.helper.daysInMonth(calendarDate, cache);\n    if (requestedFields.daysInYear) {\n      const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n      const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n      calendarDate.daysInYear = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    }\n    if (requestedFields.monthsInYear) calendarDate.monthsInYear = this.helper.monthsInYear(calendarDate, cache);\n    if (requestedFields.inLeapYear) calendarDate.inLeapYear = this.helper.inLeapYear(calendarDate, cache);\n    return calendarDate as T;\n  }\n  getFirstDayOfWeek(): number | undefined {\n    return this.helper.getFirstDayOfWeek();\n  }\n  getMinimalDaysInFirstWeek(): number | undefined {\n    return this.helper.getMinimalDaysInFirstWeek();\n  }\n}\n\nfor (const Helper of [\n  HebrewHelper,\n  PersianHelper,\n  EthiopicHelper,\n  EthioaaHelper,\n  CopticHelper,\n  ChineseHelper,\n  DangiHelper,\n  RocHelper,\n  IndianHelper,\n  BuddhistHelper,\n  GregoryHelper,\n  JapaneseHelper,\n  IslamicHelper,\n  IslamicUmalquraHelper,\n  IslamicTblaHelper,\n  IslamicCivilHelper,\n  IslamicRgsaHelper,\n  IslamicCcHelper\n]) {\n  const helper = new Helper();\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\n  // per-calendar logic.\n  impl[helper.id] = new NonIsoCalendar(helper);\n}\n\nfunction calendarImpl(calendar: BuiltinCalendarId) {\n  return impl[calendar];\n}\n// Probably not what the intrinsics mechanism was intended for, but view this as\n// an export of calendarImpl while avoiding circular dependencies\nDefineIntrinsic('calendarImpl', calendarImpl);\n","import { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  CAL_ID,\n  CALENDAR,\n  CreateSlots,\n  DATE,\n  DATETIME,\n  DAYS,\n  EPOCHNANOSECONDS,\n  GetSlot,\n  HasSlot,\n  HOURS,\n  INST,\n  ISO_DATE,\n  ISO_DATE_TIME,\n  LOCALE,\n  MD,\n  MICROSECONDS,\n  MILLISECONDS,\n  MINUTES,\n  MONTHS,\n  NANOSECONDS,\n  OPTIONS,\n  ORIGINAL,\n  ResetSlot,\n  SECONDS,\n  SetSlot,\n  TIME,\n  TIME_FMT,\n  TZ_CANONICAL,\n  TZ_ORIGINAL,\n  WEEKS,\n  YEARS,\n  YM\n} from './slots';\nimport type { Temporal } from '..';\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\n\n// Save the original Intl.DateTimeFormat, it will likely be overwritten\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\n\ntype LazySlot = typeof DATE | typeof YM | typeof MD | typeof TIME_FMT | typeof DATETIME | typeof INST;\n\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getSlotLazy(obj: DateTimeFormatImpl, slot: LazySlot) {\n  let val = GetSlot(obj, slot);\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new OriginalIntlDateTimeFormat(GetSlot(obj, LOCALE), val(GetSlot(obj, OPTIONS)));\n    ResetSlot(obj, slot, val);\n  }\n  return val;\n}\n\nfunction createDateTimeFormat(\n  dtf: DateTimeFormatImpl,\n  locale: Params['constructor'][0],\n  optionsParam: Params['constructor'][1]\n) {\n  const hasOptions = typeof optionsParam !== 'undefined';\n  let options: Intl.DateTimeFormatOptions;\n  if (hasOptions) {\n    // Read all the options in the expected order and copy them to a\n    // null-prototype object with which we can do further operations\n    // unobservably\n    const props: (keyof Intl.DateTimeFormatOptions)[] = [\n      'localeMatcher',\n      'calendar',\n      'numberingSystem',\n      'hour12',\n      'hourCycle',\n      'timeZone',\n      'weekday',\n      'era',\n      'year',\n      'month',\n      'day',\n      'dayPeriod',\n      'hour',\n      'minute',\n      'second',\n      'fractionalSecondDigits',\n      'timeZoneName',\n      'formatMatcher',\n      'dateStyle',\n      'timeStyle'\n    ];\n    options = ES.ToObject(optionsParam);\n    const newOptions = Object.create(null);\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (Object.prototype.hasOwnProperty.call(options, prop)) {\n        newOptions[prop] = options[prop];\n      }\n    }\n    options = newOptions;\n  } else {\n    options = Object.create(null);\n  }\n  const original = new OriginalIntlDateTimeFormat(locale, options);\n  const ro = original.resolvedOptions();\n\n  CreateSlots(dtf);\n\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n  if (hasOptions) {\n    const clonedResolved = Object.assign(Object.create(null), ro);\n    for (const prop in clonedResolved) {\n      if (!Object.prototype.hasOwnProperty.call(options, prop)) {\n        delete clonedResolved[prop as keyof typeof clonedResolved];\n      }\n    }\n    // hour12/hourCycle don't show up in resolvedOptions() unless the chosen\n    // format includes an hour component, so copy them explicitly in case they\n    // would otherwise be lost\n    clonedResolved.hour12 = options.hour12;\n    clonedResolved.hourCycle = options.hourCycle;\n    SetSlot(dtf, OPTIONS, clonedResolved);\n  } else {\n    SetSlot(dtf, OPTIONS, options);\n  }\n\n  SetSlot(dtf, LOCALE, ro.locale);\n  SetSlot(dtf, ORIGINAL, original);\n  SetSlot(dtf, TZ_CANONICAL, ro.timeZone);\n  SetSlot(dtf, CAL_ID, ro.calendar);\n  SetSlot(dtf, DATE, dateAmend);\n  SetSlot(dtf, YM, yearMonthAmend);\n  SetSlot(dtf, MD, monthDayAmend);\n  SetSlot(dtf, TIME_FMT, timeAmend);\n  SetSlot(dtf, DATETIME, datetimeAmend);\n  SetSlot(dtf, INST, instantAmend);\n\n  // Save the original time zone, for a few reasons:\n  // - Clearer error messages\n  // - More clearly follows the spec for InitializeDateTimeFormat\n  // - Because it follows the spec more closely, will make it easier to integrate\n  //   support of offset strings and other potential changes like proposal-canonical-tz.\n  const timeZoneOption = hasOptions ? options.timeZone : undefined;\n  if (timeZoneOption === undefined) {\n    SetSlot(dtf, TZ_ORIGINAL, ro.timeZone);\n  } else {\n    const id = ES.ToString(timeZoneOption);\n    if (id.startsWith('−')) {\n      // The initial (Node 23) implementation of offset time zones allowed use\n      // of the Unicode minus sign, which was disallowed by a later spec change.\n      throw new RangeError('Unicode minus (U+2212) is not supported in time zone offsets');\n    }\n    // store a normalized identifier\n    SetSlot(dtf, TZ_ORIGINAL, ES.ToTemporalTimeZoneIdentifier(id));\n  }\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nfunction IsPatchedDateTimeFormat(item: unknown): item is DateTimeFormatImpl {\n  return HasSlot(item, ORIGINAL);\n}\n\nclass DateTimeFormatImpl {\n  constructor(locales: Params['constructor'][0] = undefined, options: Params['constructor'][1] = undefined) {\n    createDateTimeFormat(this, locales, options);\n  }\n\n  get format() {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    const boundFormat = format.bind(this);\n    Object.defineProperties(boundFormat, {\n      length: { value: 1, enumerable: false, writable: false, configurable: true },\n      name: { value: '', enumerable: false, writable: false, configurable: true }\n    });\n    return boundFormat;\n  }\n\n  formatRange(a: Params['formatRange'][0], b: Params['formatRange'][1]): Return['formatRange'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatRange.call(this, a, b);\n  }\n\n  formatToParts?<P extends readonly unknown[]>(\n    datetime: Params['formatToParts'][0],\n    ...rest: P\n  ): Return['formatToParts'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatToParts.call(this, datetime, ...rest);\n  }\n\n  formatRangeToParts?(\n    a: Params['formatRangeToParts'][0],\n    b: Params['formatRangeToParts'][1]\n  ): Return['formatRangeToParts'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatRangeToParts.call(this, a, b);\n  }\n\n  resolvedOptions(): Return['resolvedOptions'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return resolvedOptions.call(this);\n  }\n}\n\nif (!('formatToParts' in OriginalIntlDateTimeFormat.prototype)) {\n  delete DateTimeFormatImpl.prototype.formatToParts;\n}\n\nif (!('formatRangeToParts' in OriginalIntlDateTimeFormat.prototype)) {\n  delete DateTimeFormatImpl.prototype.formatRangeToParts;\n}\nexport type { DateTimeFormatImpl };\n\ninterface DateTimeFormatInterface {\n  (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\n  new (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\n  supportedLocalesOf: typeof Intl.DateTimeFormat.supportedLocalesOf;\n}\n\n// A non-class constructor is needed because Intl.DateTimeFormat must be able to\n// be called without 'new'\nexport const DateTimeFormat = function (\n  locales: Params['constructor'][0] = undefined,\n  options: Params['constructor'][1] = undefined\n): DateTimeFormatImpl {\n  return new DateTimeFormatImpl(locales, options);\n} as unknown as DateTimeFormatInterface;\nDateTimeFormatImpl.prototype.constructor = DateTimeFormat;\n\nObject.defineProperty(DateTimeFormat, 'prototype', {\n  value: DateTimeFormatImpl.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nDateTimeFormat.supportedLocalesOf = OriginalIntlDateTimeFormat.supportedLocalesOf;\nMakeIntrinsicClass(DateTimeFormat as unknown as typeof Intl.DateTimeFormat, 'Intl.DateTimeFormat');\n\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\n  const resolved = GetSlot(this, ORIGINAL).resolvedOptions();\n  resolved.timeZone = GetSlot(this, TZ_ORIGINAL);\n  return resolved;\n}\n\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['format'][0],\n  ...rest: P\n): Return['format'] {\n  let overrides = extractOverrides(datetime, this);\n  let formatter, formatArgs: [Params['format'][0], ...unknown[]];\n  if (overrides.formatter) {\n    formatter = overrides.formatter;\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\n  } else {\n    formatter = GetSlot(this, ORIGINAL);\n    formatArgs = [datetime, ...rest];\n  }\n  return formatter.format(...(formatArgs as [number | Date | undefined]));\n}\n\nfunction formatToParts<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['formatToParts'][0],\n  ...rest: P\n): Return['formatToParts'] {\n  let overrides = extractOverrides(datetime, this);\n  let formatter, formatArgs;\n  if (overrides.formatter) {\n    formatter = overrides.formatter;\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\n  } else {\n    formatter = GetSlot(this, ORIGINAL);\n    formatArgs = [datetime, ...rest];\n  }\n  return formatter.formatToParts(...(formatArgs as [number | Date | undefined]));\n}\n\nfunction formatRange(this: DateTimeFormatImpl, aParam: Params['formatRange'][0], bParam: Params['formatRange'][1]) {\n  if (aParam === undefined || bParam === undefined) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\n  }\n  const a = toDateTimeFormattable(aParam);\n  const b = toDateTimeFormattable(bParam);\n  let formatArgs = [a, b] as const;\n  let formatter;\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n  }\n  if (isTemporalObject(a)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aformatter) {\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\n      formatter = aformatter;\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\n    }\n  }\n  if (!formatter) {\n    formatter = GetSlot(this, ORIGINAL);\n  }\n  return formatter.formatRange(...(formatArgs as [number, number]));\n}\n\nfunction formatRangeToParts(\n  this: DateTimeFormatImpl,\n  aParam: Params['formatRangeToParts'][0],\n  bParam: Params['formatRangeToParts'][1]\n) {\n  if (aParam === undefined || bParam === undefined) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\n  }\n  const a = toDateTimeFormattable(aParam);\n  const b = toDateTimeFormattable(bParam);\n  let formatArgs = [a, b] as const;\n  let formatter;\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\n    throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n  }\n  if (isTemporalObject(a)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aformatter) {\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\n      formatter = aformatter;\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\n    }\n  }\n  if (!formatter) {\n    formatter = GetSlot(this, ORIGINAL);\n  }\n  return formatter.formatRangeToParts(...(formatArgs as [number, number]));\n}\n\n// \"false\" is a signal to delete this option\ntype MaybeFalseOptions = {\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\n};\n\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\n  const options = Object.assign({}, optionsParam);\n  const props = [\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'weekday',\n    'dayPeriod',\n    'timeZoneName',\n    'dateStyle',\n    'timeStyle'\n  ] as const;\n  for (let i = 0; i < props.length; i++) {\n    const opt = props[i];\n    // TODO: can this be typed more cleanly?\n    type OptionMaybeFalse = (typeof options)[typeof opt] | false;\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\n  }\n  return options;\n}\n\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\n\nfunction timeAmend(originalOptions: OptionsType<Temporal.PlainTime>) {\n  const options = amend(originalOptions, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\n    // Try to fake what timeStyle should do if not printing the time zone name\n    delete options.timeStyle;\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\n  }\n  if (!hasTimeOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format Temporal.PlainTime with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction yearMonthAmend(originalOptions: OptionsType<Temporal.PlainYearMonth>) {\n  // Try to fake what dateStyle should do for dates without a day. This is not\n  // accurate for locales that always print the era\n  const dateStyleHacks = {\n    short: { year: '2-digit', month: 'numeric' },\n    medium: { year: 'numeric', month: 'short' },\n    long: { year: 'numeric', month: 'long' },\n    full: { year: 'numeric', month: 'long' }\n  };\n  const options = amend(originalOptions, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if ('dateStyle' in options && options.dateStyle) {\n    const style = options.dateStyle;\n    delete options.dateStyle;\n    Object.assign(options, dateStyleHacks[style]);\n  }\n  if (!('year' in options || 'month' in options || 'era' in options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainYearMonth with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, { year: 'numeric', month: 'numeric' });\n  }\n  return options;\n}\n\nfunction monthDayAmend(originalOptions: OptionsType<Temporal.PlainMonthDay>) {\n  // Try to fake what dateStyle should do for dates without a day\n  const dateStyleHacks = {\n    short: { month: 'numeric', day: 'numeric' },\n    medium: { month: 'short', day: 'numeric' },\n    long: { month: 'long', day: 'numeric' },\n    full: { month: 'long', day: 'numeric' }\n  };\n  const options = amend(originalOptions, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if ('dateStyle' in options && options.dateStyle) {\n    const style = options.dateStyle;\n    delete options.dateStyle;\n    Object.assign(options, dateStyleHacks[style]);\n  }\n  if (!('month' in options || 'day' in options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainMonthDay with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, { month: 'numeric', day: 'numeric' });\n  }\n  return options;\n}\n\nfunction dateAmend(originalOptions: OptionsType<Temporal.PlainDate>) {\n  const options = amend(originalOptions, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if (!hasDateOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainDate with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction datetimeAmend(originalOptions: OptionsType<Temporal.PlainDateTime>) {\n  const options = amend(originalOptions, { timeZoneName: false });\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\n    // Try to fake what timeStyle should do if not printing the time zone name\n    delete options.timeStyle;\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\n\n    // If moving to a fake timeStyle while dateStyle is present, we also have to\n    // move to a fake dateStyle. dateStyle is mutually exclusive with hour etc.\n    if (options.dateStyle) {\n      const dateStyleHacks = {\n        short: { year: 'numeric', month: 'numeric', day: 'numeric' },\n        medium: { year: 'numeric', month: 'short', day: 'numeric' },\n        long: { year: 'numeric', month: 'long', day: 'numeric' },\n        full: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }\n      };\n      Object.assign(options, dateStyleHacks[options.dateStyle]);\n      delete options.dateStyle;\n    }\n  }\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainDateTime with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\n  let options = optionsParam;\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = Object.assign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'year' in options ||\n    'month' in options ||\n    'day' in options ||\n    'weekday' in options ||\n    'dateStyle' in options ||\n    'era' in options\n  );\n}\n\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'hour' in options ||\n    'minute' in options ||\n    'second' in options ||\n    'timeStyle' in options ||\n    'dayPeriod' in options ||\n    'fractionalSecondDigits' in options\n  );\n}\n\nfunction hasAnyDateTimeOptions(originalOptions: OptionsType<TypesWithToLocaleString>) {\n  return (\n    hasDateOptions(originalOptions) ||\n    hasTimeOptions(originalOptions) ||\n    'dateStyle' in originalOptions ||\n    'timeStyle' in originalOptions ||\n    'timeZoneName' in originalOptions\n  );\n}\n\nfunction isTemporalObject(\n  obj: unknown\n): obj is\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainDateTime\n  | Temporal.ZonedDateTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.Instant {\n  return (\n    ES.IsTemporalDate(obj) ||\n    ES.IsTemporalTime(obj) ||\n    ES.IsTemporalDateTime(obj) ||\n    ES.IsTemporalZonedDateTime(obj) ||\n    ES.IsTemporalYearMonth(obj) ||\n    ES.IsTemporalMonthDay(obj) ||\n    ES.IsTemporalInstant(obj)\n  );\n}\n\nfunction toDateTimeFormattable(value: unknown) {\n  if (isTemporalObject(value)) return value;\n  return ES.ToNumber(value);\n}\n\nfunction sameTemporalType(x: unknown, y: unknown) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\n  return true;\n}\n\ntype TypesWithToLocaleString =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime\n  | Temporal.Instant;\n\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\n  if (ES.IsTemporalTime(temporalObj)) {\n    const isoDateTime = {\n      isoDate: { year: 1970, month: 1, day: 1 },\n      time: GetSlot(temporalObj, TIME)\n    };\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, TIME_FMT)\n    };\n  }\n\n  if (ES.IsTemporalYearMonth(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, YM)\n    };\n  }\n\n  if (ES.IsTemporalMonthDay(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, MD)\n    };\n  }\n\n  if (ES.IsTemporalDate(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${mainCalendar}`);\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, DATE)\n    };\n  }\n\n  if (ES.IsTemporalDateTime(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = GetSlot(temporalObj, ISO_DATE_TIME);\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, DATETIME)\n    };\n  }\n\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\n    throw new TypeError(\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\n    );\n  }\n\n  if (ES.IsTemporalInstant(temporalObj)) {\n    return {\n      epochNs: GetSlot(temporalObj, EPOCHNANOSECONDS),\n      formatter: getSlotLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n\nfunction temporalDurationToCompatibilityRecord(duration: Temporal.Duration) {\n  const record = Object.create(null);\n  record.years = GetSlot(duration, YEARS);\n  record.months = GetSlot(duration, MONTHS);\n  record.weeks = GetSlot(duration, WEEKS);\n  record.days = GetSlot(duration, DAYS);\n  record.hours = GetSlot(duration, HOURS);\n  record.minutes = GetSlot(duration, MINUTES);\n  record.seconds = GetSlot(duration, SECONDS);\n  record.milliseconds = GetSlot(duration, MILLISECONDS);\n  record.microseconds = GetSlot(duration, MICROSECONDS);\n  record.nanoseconds = GetSlot(duration, NANOSECONDS);\n  return record;\n}\n\nconst { format: IntlDurationFormatPrototypeFormat, formatToParts: IntlDurationFormatPrototypeFormatToParts } =\n  Intl.DurationFormat?.prototype ?? Object.create(null);\n\nexport function ModifiedIntlDurationFormatPrototypeFormat(\n  this: Intl.DurationFormat,\n  durationLike: Temporal.DurationLike\n) {\n  Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\n  const duration = ES.ToTemporalDuration(durationLike);\n  const record = temporalDurationToCompatibilityRecord(duration);\n  return IntlDurationFormatPrototypeFormat.call(this, record);\n}\n\nif (Intl.DurationFormat?.prototype) {\n  Intl.DurationFormat.prototype.format = ModifiedIntlDurationFormatPrototypeFormat;\n  Intl.DurationFormat.prototype.formatToParts = function formatToParts(durationLike: Temporal.DurationLike) {\n    Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\n    const duration = ES.ToTemporalDuration(durationLike);\n    const record = temporalDurationToCompatibilityRecord(duration);\n    return IntlDurationFormatPrototypeFormatToParts.call(this, record);\n  };\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\n\nexport class Instant implements Temporal.Instant {\n  constructor(epochNanoseconds: bigint | JSBI) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ES.ToBigInt(epochNanoseconds);\n    ES.CreateTemporalInstantSlots(this, ns);\n  }\n\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.epochNsToMs(value, 'floor');\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.AddDurationToInstant('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.AddDurationToInstant('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.DifferenceTemporalInstant('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.DifferenceTemporalInstant('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundTemporalInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return ES.CreateTemporalInstant(roundedNs);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const other = ES.ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    let timeZone = resolvedOptions.timeZone;\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneIdentifier(timeZone);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundTemporalInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = ES.CreateTemporalInstant(roundedNs);\n    return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\n  }\n  toJSON(): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.TemporalInstantToString(this, undefined, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('Instant');\n  }\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\n  }\n\n  static fromEpochMilliseconds(epochMilliseconds: Params['fromEpochMilliseconds'][0]): Return['fromEpochMilliseconds'] {\n    const epochNanoseconds = ES.epochMsToNs(ES.ToNumber(epochMilliseconds));\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n  static fromEpochNanoseconds(\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\n  ): Return['fromEpochNanoseconds'] {\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    return ES.ToTemporalInstant(item);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalInstant(oneParam);\n    const two = ES.ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.Instant';\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE, TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\n\nexport class PlainDate implements Temporal.PlainDate {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    isoDay: Params['constructor'][2],\n    calendarParam: Params['constructor'][3] = 'iso8601'\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    ES.RejectISODate(year, month, day);\n\n    ES.CreateTemporalDateSlots(this, { year, month, day }, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return GetSlot(this, CALENDAR);\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalDateLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    if (!ES.IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const partialDate = ES.PrepareCalendarFields(\n      calendar,\n      temporalDateLike,\n      ['year', 'month', 'monthCode', 'day'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarDateFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.AddDurationToDate('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.AddDurationToDate('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const other = ES.ToTemporalDate(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalDateToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.TemporalDateToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainDate');\n  }\n  toPlainDateTime(temporalTime: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE), time);\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n\n    let timeZone, temporalTime;\n    if (ES.IsObject(item)) {\n      const timeZoneLike = item.timeZone;\n      if (timeZoneLike === undefined) {\n        timeZone = ES.ToTemporalTimeZoneIdentifier(item);\n      } else {\n        timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneLike);\n        temporalTime = item.plainTime;\n      }\n    } else {\n      timeZone = ES.ToTemporalTimeZoneIdentifier(item);\n    }\n\n    const isoDate = GetSlot(this, ISO_DATE);\n    let epochNs;\n    if (temporalTime === undefined) {\n      epochNs = ES.GetStartOfDay(timeZone, isoDate);\n    } else {\n      temporalTime = ES.ToTemporalTime(temporalTime);\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoDate, GetSlot(temporalTime, TIME));\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, isoDateTime, 'compatible');\n    }\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = GetSlot(this, CALENDAR);\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, 'constrain');\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = GetSlot(this, CALENDAR);\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, 'constrain');\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalDate(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  date: Temporal.PlainDate,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(date, ES.IsTemporalDate);\n  const isoDate = GetSlot(date, ISO_DATE);\n  return ES.calendarImplForObj(date).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport { CALENDAR, GetSlot, ISO_DATE_TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\n\nexport class PlainDateTime implements Temporal.PlainDateTime {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    isoDay: Params['constructor'][2],\n    hourParam: Params['constructor'][3] = 0,\n    minuteParam: Params['constructor'][4] = 0,\n    secondParam: Params['constructor'][5] = 0,\n    millisecondParam: Params['constructor'][6] = 0,\n    microsecondParam: Params['constructor'][7] = 0,\n    nanosecondParam: Params['constructor'][8] = 0,\n    calendarParam: Params['constructor'][9] = 'iso8601'\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n\n    ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n    ES.CreateTemporalDateTimeSlots(\n      this,\n      { isoDate: { year, month, day }, time: { hour, minute, second, millisecond, microsecond, nanosecond } },\n      calendar\n    );\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return GetSlot(this, CALENDAR);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get hour(): Return['hour'] {\n    return getTimeProperty(this, 'hour');\n  }\n  get minute(): Return['minute'] {\n    return getTimeProperty(this, 'minute');\n  }\n  get second(): Return['second'] {\n    return getTimeProperty(this, 'second');\n  }\n  get millisecond(): Return['millisecond'] {\n    return getTimeProperty(this, 'millisecond');\n  }\n  get microsecond(): Return['microsecond'] {\n    return getTimeProperty(this, 'microsecond');\n  }\n  get nanosecond(): Return['nanosecond'] {\n    return getTimeProperty(this, 'nanosecond');\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    if (!ES.IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\n    let fields = {\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\n      ...isoDateTime.time\n    };\n    const partialDateTime = ES.PrepareCalendarFields(\n      calendar,\n      temporalDateTimeLike,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\n    return ES.CreateTemporalDateTime(newDateTime, calendar);\n  }\n  withPlainTime(temporalTime: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE_TIME).isoDate, time);\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalDateTime(GetSlot(this, ISO_DATE_TIME), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.AddDurationToDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.AddDurationToDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\n    if (roundingIncrement === 1 && smallestUnit === 'nanosecond') {\n      return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n    }\n    const result = ES.RoundISODateTime(isoDateTime, roundingIncrement, smallestUnit, roundingMode);\n\n    return ES.CreateTemporalDateTime(result, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const other = ES.ToTemporalDateTime(otherParam);\n    if (ES.CompareISODateTime(GetSlot(this, ISO_DATE_TIME), GetSlot(other, ISO_DATE_TIME)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const result = ES.RoundISODateTime(GetSlot(this, ISO_DATE_TIME), increment, unit, roundingMode);\n    ES.RejectDateTimeRange(result);\n    return ES.ISODateTimeToString(result, GetSlot(this, CALENDAR), precision, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.ISODateTimeToString(GetSlot(this, ISO_DATE_TIME), GetSlot(this, CALENDAR), 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainDateTime');\n  }\n\n  toZonedDateTime(\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\n    options: Params['toZonedDateTime'][1] = undefined\n  ): Return['toZonedDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\n    const epochNs = ES.GetEpochNanosecondsFor(timeZone, GetSlot(this, ISO_DATE_TIME), disambiguation);\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE_TIME).isoDate, GetSlot(this, CALENDAR));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.CreateTemporalTime(GetSlot(this, ISO_DATE_TIME).time);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDateTime(oneParam);\n    const two = ES.ToTemporalDateTime(twoParam);\n    return ES.CompareISODateTime(GetSlot(one, ISO_DATE_TIME), GetSlot(two, ISO_DATE_TIME));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  dt: Temporal.PlainDateTime,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\n  const isoDate = GetSlot(dt, ISO_DATE_TIME).isoDate;\n  return ES.calendarImplForObj(dt).isoToDate(isoDate, { [prop]: true })[prop];\n}\n\nfunction getTimeProperty(dt: Temporal.PlainDateTime, prop: Temporal.TimeUnit) {\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\n  return GetSlot(dt, ISO_DATE_TIME).time[prop];\n}\n","import { DEBUG } from './debug';\nimport { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { ModifiedIntlDurationFormatPrototypeFormat } from './intl';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  ISO_DATE,\n  SetSlot,\n  TIME_ZONE\n} from './slots';\nimport { TimeDuration } from './timeduration';\nimport type { Temporal } from '..';\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\nimport JSBI from 'jsbi';\n\nexport class Duration implements Temporal.Duration {\n  constructor(\n    yearsParam: Params['constructor'][0] = 0,\n    monthsParam: Params['constructor'][1] = 0,\n    weeksParam: Params['constructor'][2] = 0,\n    daysParam: Params['constructor'][3] = 0,\n    hoursParam: Params['constructor'][4] = 0,\n    minutesParam: Params['constructor'][5] = 0,\n    secondsParam: Params['constructor'][6] = 0,\n    millisecondsParam: Params['constructor'][7] = 0,\n    microsecondsParam: Params['constructor'][8] = 0,\n    nanosecondsParam: Params['constructor'][9] = 0\n  ) {\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\n\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `Temporal.Duration <${ES.TemporalDurationToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get years(): Return['years'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, YEARS);\n  }\n  get months(): Return['months'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MONTHS);\n  }\n  get weeks(): Return['weeks'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, WEEKS);\n  }\n  get days(): Return['days'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, DAYS);\n  }\n  get hours(): Return['hours'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, HOURS);\n  }\n  get minutes(): Return['minutes'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MINUTES);\n  }\n  get seconds(): Return['seconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, SECONDS);\n  }\n  get milliseconds(): Return['milliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MILLISECONDS);\n  }\n  get microseconds(): Return['microseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MICROSECONDS);\n  }\n  get nanoseconds(): Return['nanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, NANOSECONDS);\n  }\n  get sign(): Return['sign'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.DurationSign(this);\n  }\n  get blank(): Return['blank'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.DurationSign(this) === 0;\n  }\n  with(durationLike: Params['with'][0]): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    const partialDuration = ES.ToTemporalPartialDurationRecord(durationLike);\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = partialDuration;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  negated(): Return['negated'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.CreateNegatedTemporalDuration(this);\n  }\n  abs(): Return['abs'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return new Duration(\n      Math.abs(GetSlot(this, YEARS)),\n      Math.abs(GetSlot(this, MONTHS)),\n      Math.abs(GetSlot(this, WEEKS)),\n      Math.abs(GetSlot(this, DAYS)),\n      Math.abs(GetSlot(this, HOURS)),\n      Math.abs(GetSlot(this, MINUTES)),\n      Math.abs(GetSlot(this, SECONDS)),\n      Math.abs(GetSlot(this, MILLISECONDS)),\n      Math.abs(GetSlot(this, MICROSECONDS)),\n      Math.abs(GetSlot(this, NANOSECONDS))\n    );\n  }\n  add(other: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.AddDurations('add', this, other);\n  }\n  subtract(other: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.AddDurations('subtract', this, other);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n\n    const existingLargestUnit = ES.DefaultTemporalLargestUnit(this);\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n\n    let largestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(roundTo);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    let smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'datetime', undefined);\n\n    let smallestUnitPresent = true;\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n    const defaultLargestUnit = ES.LargerOfTwoTemporalUnits(existingLargestUnit, smallestUnit);\n    let largestUnitPresent = true;\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n\n    const maximumIncrements = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    } as { [k in Temporal.DateTimeUnit]?: number };\n    const maximum = maximumIncrements[smallestUnit];\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n    if (roundingIncrement > 1 && ES.TemporalUnitCategory(smallestUnit) === 'date' && largestUnit !== smallestUnit) {\n      throw new RangeError('For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit');\n    }\n\n    if (zonedRelativeTo) {\n      let duration = ES.ToInternalDurationRecord(this);\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\n      duration = ES.DifferenceZonedDateTimeWithRounding(\n        relativeEpochNs,\n        targetEpochNs,\n        timeZone,\n        calendar,\n        largestUnit,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode\n      );\n      if (ES.TemporalUnitCategory(largestUnit) === 'date') largestUnit = 'hour';\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\n    }\n\n    if (plainRelativeTo) {\n      let duration = ES.ToInternalDurationRecordWith24HourDays(this);\n      const targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\n\n      // Delegate the date part addition to the calendar\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\n\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\n      duration = ES.DifferencePlainDateTimeWithRounding(\n        isoDateTime,\n        targetDateTime,\n        calendar,\n        largestUnit,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode\n      );\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\n    }\n\n    // No reference date to calculate difference relative to\n    if (ES.IsCalendarUnit(existingLargestUnit)) {\n      throw new RangeError(`a starting point is required for ${existingLargestUnit}s balancing`);\n    }\n    if (ES.IsCalendarUnit(largestUnit)) {\n      throw new RangeError(`a starting point is required for ${largestUnit}s balancing`);\n    }\n    assert(!ES.IsCalendarUnit(smallestUnit), 'smallestUnit was larger than largestUnit');\n    let internalDuration = ES.ToInternalDurationRecordWith24HourDays(this);\n    if (smallestUnit === 'day') {\n      // First convert time units up to days\n      const { quotient, remainder } = internalDuration.time.divmod(ES.DAY_NANOS);\n      let days = internalDuration.date.days + quotient + ES.TotalTimeDuration(remainder, 'day');\n      days = ES.RoundNumberToIncrement(days, roundingIncrement, roundingMode);\n      const dateDuration = { years: 0, months: 0, weeks: 0, days };\n      internalDuration = ES.CombineDateAndTimeDuration(dateDuration, TimeDuration.ZERO);\n    } else {\n      const timeDuration = ES.RoundTimeDuration(internalDuration.time, roundingIncrement, smallestUnit, roundingMode);\n      internalDuration = ES.CombineDateAndTimeDuration(ES.ZeroDateDuration(), timeDuration);\n    }\n    return ES.TemporalDurationFromInternal(internalDuration, largestUnit);\n  }\n  total(optionsParam: Params['total'][0]): Return['total'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options =\n      typeof optionsParam === 'string'\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\n        : ES.GetOptionsObject(optionsParam);\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(options);\n    const unit = ES.GetTemporalUnitValuedOption(options, 'unit', 'datetime', ES.REQUIRED);\n\n    if (zonedRelativeTo) {\n      const duration = ES.ToInternalDurationRecord(this);\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\n      return ES.DifferenceZonedDateTimeWithTotal(relativeEpochNs, targetEpochNs, timeZone, calendar, unit);\n    }\n\n    if (plainRelativeTo) {\n      const duration = ES.ToInternalDurationRecordWith24HourDays(this);\n      let targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\n\n      // Delegate the date part addition to the calendar\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\n\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\n      return ES.DifferencePlainDateTimeWithTotal(isoDateTime, targetDateTime, calendar, unit);\n    }\n\n    // No reference date to calculate difference relative to\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\n    if (ES.IsCalendarUnit(largestUnit)) {\n      throw new RangeError(`a starting point is required for ${largestUnit}s total`);\n    }\n    if (ES.IsCalendarUnit(unit)) {\n      throw new RangeError(`a starting point is required for ${unit}s total`);\n    }\n    const duration = ES.ToInternalDurationRecordWith24HourDays(this);\n    return ES.TotalTimeDuration(duration.time, unit);\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\n    }\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\n      precision,\n      'Precision cannot be \"minute\" because of RangeError above'\n    );\n\n    if (unit === 'nanosecond' && increment === 1) return ES.TemporalDurationToString(this, precision);\n\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\n    let internalDuration = ES.ToInternalDurationRecord(this);\n    const timeDuration = ES.RoundTimeDuration(internalDuration.time, increment, unit, roundingMode);\n    internalDuration = ES.CombineDateAndTimeDuration(internalDuration.date, timeDuration);\n    const roundedDuration = ES.TemporalDurationFromInternal(\n      internalDuration,\n      ES.LargerOfTwoTemporalUnits(largestUnit, 'second')\n    );\n    return ES.TemporalDurationToString(roundedDuration, precision);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.TemporalDurationToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    if (typeof Intl.DurationFormat === 'function') {\n      const formatter = new Intl.DurationFormat(locales, options as Intl.DurationFormatOptions);\n      return ModifiedIntlDurationFormatPrototypeFormat.call(formatter, this);\n    }\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return ES.TemporalDurationToString(this, 'auto');\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('Duration');\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    return ES.ToTemporalDuration(item);\n  }\n  static compare(\n    oneParam: Params['compare'][0],\n    twoParam: Params['compare'][1],\n    options: Params['compare'][2] = undefined\n  ): Return['compare'] {\n    const one = ES.ToTemporalDuration(oneParam);\n    const two = ES.ToTemporalDuration(twoParam);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(resolvedOptions);\n\n    if (\n      GetSlot(one, YEARS) === GetSlot(two, YEARS) &&\n      GetSlot(one, MONTHS) === GetSlot(two, MONTHS) &&\n      GetSlot(one, WEEKS) === GetSlot(two, WEEKS) &&\n      GetSlot(one, DAYS) === GetSlot(two, DAYS) &&\n      GetSlot(one, HOURS) === GetSlot(two, HOURS) &&\n      GetSlot(one, MINUTES) === GetSlot(two, MINUTES) &&\n      GetSlot(one, SECONDS) === GetSlot(two, SECONDS) &&\n      GetSlot(one, MILLISECONDS) === GetSlot(two, MILLISECONDS) &&\n      GetSlot(one, MICROSECONDS) === GetSlot(two, MICROSECONDS) &&\n      GetSlot(one, NANOSECONDS) === GetSlot(two, NANOSECONDS)\n    ) {\n      return 0;\n    }\n\n    const largestUnit1 = ES.DefaultTemporalLargestUnit(one);\n    const largestUnit2 = ES.DefaultTemporalLargestUnit(two);\n    const duration1 = ES.ToInternalDurationRecord(one);\n    const duration2 = ES.ToInternalDurationRecord(two);\n\n    if (\n      zonedRelativeTo &&\n      (ES.TemporalUnitCategory(largestUnit1) === 'date' || ES.TemporalUnitCategory(largestUnit2) === 'date')\n    ) {\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const epochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n\n      const after1 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration1);\n      const after2 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration2);\n      return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(after1, after2)));\n    }\n\n    let d1 = duration1.date.days;\n    let d2 = duration2.date.days;\n    if (ES.IsCalendarUnit(largestUnit1) || ES.IsCalendarUnit(largestUnit2)) {\n      if (!plainRelativeTo) {\n        throw new RangeError('A starting point is required for years, months, or weeks comparison');\n      }\n      d1 = ES.DateDurationDays(duration1.date, plainRelativeTo);\n      d2 = ES.DateDurationDays(duration2.date, plainRelativeTo);\n    }\n    const timeDuration1 = duration1.time.add24HourDays(d1);\n    const timeDuration2 = duration2.time.add24HourDays(d2);\n    return timeDuration1.cmp(timeDuration2);\n  }\n  [Symbol.toStringTag]!: 'Temporal.Duration';\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\n\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonth: Params['constructor'][0],\n    isoDay: Params['constructor'][0],\n    calendarParam = 'iso8601',\n    referenceISOYear = 1972\n  ) {\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    const year = ES.ToIntegerWithTruncation(referenceISOYear);\n\n    ES.RejectISODate(year, month, day);\n    ES.CreateTemporalMonthDaySlots(this, { year, month, day }, calendar);\n  }\n\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return GetSlot(this, CALENDAR);\n  }\n\n  with(temporalMonthDayLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    if (!ES.IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\n    const partialMonthDay = ES.PrepareCalendarFields(\n      calendar,\n      temporalMonthDayLike,\n      ['year', 'month', 'monthCode', 'day'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    const other = ES.ToTemporalMonthDay(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalMonthDayToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return ES.TemporalMonthDayToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainMonthDay');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['year'], [], []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalMonthDay(item, options);\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  md: Temporal.PlainMonthDay,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(md, ES.IsTemporalMonthDay);\n  const isoDate = GetSlot(md, ISO_DATE);\n  return ES.calendarImplForObj(md).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import * as ES from './ecmascript';\nimport type { Temporal } from '..';\n\nfunction SystemDateTime(timeZone: string) {\n  return ES.GetISODateTimeFor(timeZone, ES.SystemUTCEpochNanoSeconds());\n}\n\nconst instant: (typeof Temporal.Now)['instant'] = () => {\n  return ES.CreateTemporalInstant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTimeISO: (typeof Temporal.Now)['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalDateTime(isoDateTime, 'iso8601');\n};\nconst zonedDateTimeISO: (typeof Temporal.Now)['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), timeZone, 'iso8601');\n};\nconst plainDateISO: (typeof Temporal.Now)['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalDate(isoDateTime.isoDate, 'iso8601');\n};\nconst plainTimeISO: (typeof Temporal.Now)['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalTime(isoDateTime.time);\n};\nconst timeZoneId: (typeof Temporal.Now)['timeZoneId'] = () => {\n  return ES.DefaultTimeZone();\n};\n\nexport const Now: typeof Temporal.Now = {\n  instant,\n  plainDateTimeISO,\n  plainDateISO,\n  plainTimeISO,\n  timeZoneId,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport { GetSlot, TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\n\nexport class PlainTime implements Temporal.PlainTime {\n  constructor(isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) {\n    const hour = isoHour === undefined ? 0 : ES.ToIntegerWithTruncation(isoHour);\n    const minute = isoMinute === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinute);\n    const second = isoSecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecond);\n    const millisecond = isoMillisecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecond);\n    const microsecond = isoMicrosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecond);\n    const nanosecond = isoNanosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecond);\n\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    const time = { hour, minute, second, millisecond, microsecond, nanosecond };\n\n    ES.CreateTemporalTimeSlots(this, time);\n  }\n\n  get hour(): Return['hour'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).hour;\n  }\n  get minute(): Return['minute'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).minute;\n  }\n  get second(): Return['second'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).second;\n  }\n  get millisecond(): Return['millisecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).millisecond;\n  }\n  get microsecond(): Return['microsecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).microsecond;\n  }\n  get nanosecond(): Return['nanosecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).nanosecond;\n  }\n\n  with(temporalTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    if (!ES.IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalTimeLike);\n\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n\n    const fields = ES.ToTemporalTimeRecord(this);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = Object.assign(fields, partialTime);\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.AddDurationToTime('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.AddDurationToTime('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const MAX_INCREMENTS = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\n\n    const time = ES.RoundTime(GetSlot(this, TIME), roundingIncrement, smallestUnit, roundingMode);\n    return ES.CreateTemporalTime(time);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    const other = ES.ToTemporalTime(otherParam);\n    return ES.CompareTimeRecord(GetSlot(this, TIME), GetSlot(other, TIME)) === 0;\n  }\n\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const time = ES.RoundTime(GetSlot(this, TIME), increment, unit, roundingMode);\n    return ES.TimeRecordToString(time, precision);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.TimeRecordToString(GetSlot(this, TIME), 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainTime');\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalTime(oneParam);\n    const two = ES.ToTemporalTime(twoParam);\n    return ES.CompareTimeRecord(GetSlot(one, TIME), GetSlot(two, TIME));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type {\n  CalendarDateRecord,\n  PlainYearMonthParams as Params,\n  PlainYearMonthReturn as Return\n} from './internaltypes';\n\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    calendarParam: Params['constructor'][2] = 'iso8601',\n    referenceISODay: Params['constructor'][3] = 1\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    const day = ES.ToIntegerWithTruncation(referenceISODay);\n\n    ES.RejectISODate(year, month, day);\n    ES.CreateTemporalYearMonthSlots(this, { year, month, day }, calendar);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return GetSlot(this, CALENDAR);\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalYearMonthLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    if (!ES.IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\n    const partialYearMonth = ES.PrepareCalendarFields(\n      calendar,\n      temporalYearMonthLike,\n      ['year', 'month', 'monthCode'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.AddDurationToYearMonth('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.AddDurationToYearMonth('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    const other = ES.ToTemporalYearMonth(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalYearMonthToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.TemporalYearMonthToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainYearMonth');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['day'], [], []);\n    const mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalYearMonth(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalYearMonth(oneParam);\n    const two = ES.ToTemporalYearMonth(twoParam);\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  ym: Temporal.PlainYearMonth,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(ym, ES.IsTemporalYearMonth);\n  const isoDate = GetSlot(ym, ISO_DATE);\n  return ES.calendarImplForObj(ym).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, EPOCHNANOSECONDS, TIME, TIME_ZONE, GetSlot } from './slots';\nimport { TimeDuration } from './timeduration';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type {\n  BuiltinCalendarId,\n  CalendarDateRecord,\n  ZonedDateTimeParams as Params,\n  ZonedDateTimeReturn as Return\n} from './internaltypes';\n\nimport JSBI from 'jsbi';\n\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\n\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\n  constructor(epochNanosecondsParam: bigint | JSBI, timeZoneParam: string, calendarParam = 'iso8601') {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    let timeZone = ES.RequireString(timeZoneParam);\n    const { tzName, offsetMinutes } = ES.ParseTimeZoneIdentifier(timeZone);\n    if (offsetMinutes === undefined) {\n      // if offsetMinutes is undefined, then tzName must be present\n      const record = ES.GetAvailableNamedTimeZoneIdentifier(tzName);\n      if (!record) throw new RangeError(`unknown time zone ${tzName}`);\n      timeZone = record.identifier;\n    } else {\n      timeZone = ES.FormatOffsetTimeZoneIdentifier(offsetMinutes);\n    }\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return GetSlot(this, CALENDAR);\n  }\n  get timeZoneId(): Return['timeZoneId'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return GetSlot(this, TIME_ZONE);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get hour(): Return['hour'] {\n    return getTimeProperty(this, 'hour');\n  }\n  get minute(): Return['minute'] {\n    return getTimeProperty(this, 'minute');\n  }\n  get second(): Return['second'] {\n    return getTimeProperty(this, 'second');\n  }\n  get millisecond(): Return['millisecond'] {\n    return getTimeProperty(this, 'millisecond');\n  }\n  get microsecond(): Return['microsecond'] {\n    return getTimeProperty(this, 'microsecond');\n  }\n  get nanosecond(): Return['nanosecond'] {\n    return getTimeProperty(this, 'nanosecond');\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.epochNsToMs(value, 'floor');\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get hoursInDay(): Return['hoursInDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const today = dateTime(this).isoDate;\n    const tomorrow = ES.BalanceISODate(today.year, today.month, today.day + 1);\n    const todayNs = ES.GetStartOfDay(timeZone, today);\n    const tomorrowNs = ES.GetStartOfDay(timeZone, tomorrow);\n    const diff = TimeDuration.fromEpochNsDiff(tomorrowNs, todayNs);\n    return ES.TotalTimeDuration(diff, 'hour');\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  get offset(): Return['offset'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const offsetNs = ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\n    return ES.FormatUTCOffsetNanoseconds(offsetNs);\n  }\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\n  }\n  with(temporalZonedDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const epochNs = GetSlot(this, EPOCHNANOSECONDS);\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, epochNs);\n    const isoDateTime = dateTime(this);\n    let fields = {\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\n      ...isoDateTime.time,\n      offset: ES.FormatUTCOffsetNanoseconds(offsetNs)\n    };\n    const partialZonedDateTime = ES.PrepareCalendarFields(\n      calendar,\n      temporalZonedDateTimeLike,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset'],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\n\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\n    const offset = ES.GetTemporalOffsetOption(resolvedOptions, 'prefer');\n    const overflow = ES.GetTemporalOverflowOption(resolvedOptions);\n\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\n    const newOffsetNs = ES.ParseDateTimeUTCOffset(fields.offset);\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      newDateTime.isoDate,\n      newDateTime.time,\n      'option',\n      newOffsetNs,\n      timeZone,\n      disambiguation,\n      offset,\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const iso = dateTime(this).isoDate;\n\n    let epochNs;\n    if (temporalTimeParam === undefined) {\n      epochNs = ES.GetStartOfDay(timeZone, iso);\n    } else {\n      const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n      const dt = ES.CombineISODateAndTimeRecord(iso, GetSlot(temporalTime, TIME));\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, dt, 'compatible');\n    }\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, calendar);\n  }\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.AddDurationToZonedDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.AddDurationToZonedDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    if (smallestUnit === 'nanosecond' && roundingIncrement === 1) {\n      return ES.CreateTemporalZonedDateTime(\n        GetSlot(this, EPOCHNANOSECONDS),\n        GetSlot(this, TIME_ZONE),\n        GetSlot(this, CALENDAR)\n      );\n    }\n\n    // first, round the underlying DateTime fields\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const thisNs = GetSlot(this, EPOCHNANOSECONDS);\n    const iso = dateTime(this);\n    let epochNanoseconds;\n\n    if (smallestUnit === 'day') {\n      // Compute Instants for start-of-day and end-of-day\n      // Determine how far the current instant has progressed through this span.\n      const dateStart = iso.isoDate;\n      const dateEnd = ES.BalanceISODate(dateStart.year, dateStart.month, dateStart.day + 1);\n\n      const startNs = ES.GetStartOfDay(timeZone, dateStart);\n      assert(\n        JSBI.greaterThanOrEqual(thisNs, startNs),\n        'cannot produce an instant during a day that occurs before start-of-day instant'\n      );\n\n      const endNs = ES.GetStartOfDay(timeZone, dateEnd);\n      assert(\n        JSBI.lessThan(thisNs, endNs),\n        'cannot produce an instant during a day that occurs on or after end-of-day instant'\n      );\n\n      const dayLengthNs = JSBI.subtract(endNs, startNs);\n      const dayProgressNs = TimeDuration.fromEpochNsDiff(thisNs, startNs);\n      const roundedDayNs = dayProgressNs.round(dayLengthNs, roundingMode);\n      epochNanoseconds = roundedDayNs.addToEpochNs(startNs);\n    } else {\n      // smallestUnit < day\n      // Round based on ISO-calendar time units\n      const roundedDateTime = ES.RoundISODateTime(iso, roundingIncrement, smallestUnit, roundingMode);\n\n      // Now reset all DateTime fields but leave the TimeZone. The offset will\n      // also be retained if the new date/time values are still OK with the old\n      // offset. Otherwise the offset will be changed to be compatible with the\n      // new date/time values. If DST disambiguation is required, the `compatible`\n      // disambiguation algorithm will be used.\n      const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, thisNs);\n      epochNanoseconds = ES.InterpretISODateTimeOffset(\n        roundedDateTime.isoDate,\n        roundedDateTime.time,\n        'option',\n        offsetNs,\n        timeZone,\n        'compatible',\n        'prefer',\n        /* matchMinute = */ false\n      );\n    }\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const other = ES.ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const showOffset = ES.GetTemporalShowOffsetOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const showTimeZone = ES.GetTemporalShowTimeZoneNameOption(resolvedOptions);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n\n    // This is not quite per specification, but this polyfill's DateTimeFormat\n    // already doesn't match the InitializeDateTimeFormat operation, and the\n    // access order might change anyway;\n    // see https://github.com/tc39/ecma402/issues/747\n    const optionsCopy = Object.create(null);\n    ES.CopyDataProperties(optionsCopy, resolvedOptions, ['timeZone']);\n\n    if (resolvedOptions.timeZone !== undefined) {\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\n    }\n\n    if (\n      optionsCopy.year === undefined &&\n      optionsCopy.month === undefined &&\n      optionsCopy.day === undefined &&\n      optionsCopy.era === undefined &&\n      optionsCopy.weekday === undefined &&\n      optionsCopy.dateStyle === undefined &&\n      optionsCopy.hour === undefined &&\n      optionsCopy.minute === undefined &&\n      optionsCopy.second === undefined &&\n      optionsCopy.fractionalSecondDigits === undefined &&\n      optionsCopy.timeStyle === undefined &&\n      optionsCopy.dayPeriod === undefined &&\n      optionsCopy.timeZoneName === undefined\n    ) {\n      optionsCopy.timeZoneName = 'short';\n      // The rest of the defaults will be filled in by formatting the Instant\n    }\n\n    optionsCopy.timeZone = GetSlot(this, TIME_ZONE);\n    if (ES.IsOffsetTimeZoneIdentifier(optionsCopy.timeZone)) {\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\n      throw new RangeError('toLocaleString does not currently support offset time zones');\n    }\n\n    const formatter = new DateTimeFormat(locales, optionsCopy);\n\n    const localeCalendarIdentifier = customResolvedOptions.call(formatter).calendar as BuiltinCalendarId;\n    const calendarIdentifier = GetSlot(this, CALENDAR);\n    if (\n      calendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== 'iso8601' &&\n      !ES.CalendarEquals(localeCalendarIdentifier, calendarIdentifier)\n    ) {\n      throw new RangeError(\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\n          ` in locale with calendar ${localeCalendarIdentifier}`\n      );\n    }\n\n    return formatter.format(ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('ZonedDateTime');\n  }\n  startOfDay(): Return['startOfDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const isoDate = dateTime(this).isoDate;\n    const epochNanoseconds = ES.GetStartOfDay(timeZone, isoDate);\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  getTimeZoneTransition(directionParam: Params['getTimeZoneTransition'][0]): Return['getTimeZoneTransition'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n\n    if (directionParam === undefined) throw new TypeError('options parameter is required');\n    const direction = ES.GetDirectionOption(\n      typeof directionParam === 'string'\n        ? (ES.CreateOnePropObject('direction', directionParam) as Exclude<typeof directionParam, string>)\n        : ES.GetOptionsObject(directionParam)\n    );\n    if (direction === undefined) throw new TypeError('direction option is required');\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsOffsetTimeZoneIdentifier(timeZone) || timeZone === 'UTC') {\n      return null;\n    }\n\n    const thisEpochNanoseconds = GetSlot(this, EPOCHNANOSECONDS);\n    const epochNanoseconds =\n      direction === 'next'\n        ? ES.GetNamedTimeZoneNextTransition(timeZone, thisEpochNanoseconds)\n        : ES.GetNamedTimeZonePreviousTransition(timeZone, thisEpochNanoseconds);\n    return epochNanoseconds === null\n      ? null\n      : ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  toInstant(): Return['toInstant'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalDate(dateTime(this).isoDate, GetSlot(this, CALENDAR));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalTime(dateTime(this).time);\n  }\n  toPlainDateTime(): Return['toPlainDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalDateTime(dateTime(this), GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalZonedDateTime(item, optionsParam);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalZonedDateTime(oneParam);\n    const two = ES.ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\n  return ES.GetISODateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, EPOCHNANOSECONDS));\n}\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  zdt: Temporal.ZonedDateTime,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\n  const isoDate = dateTime(zdt).isoDate;\n  return ES.calendarImplForObj(zdt).isoToDate(isoDate, { [prop]: true })[prop];\n}\n\nfunction getTimeProperty(zdt: Temporal.ZonedDateTime, prop: Temporal.TimeUnit) {\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\n  return dateTime(zdt).time[prop];\n}\n","import * as ES from './ecmascript';\n\n// By default, a plain function can be called as a constructor. A method such as\n// Date.prototype.toTemporalInstant should not be able to. We could check\n// new.target in the body of toTemporalInstant, but that is not sufficient for\n// preventing construction when passing it as the newTarget parameter of\n// Reflect.construct. So we create it as a method of an otherwise unused class,\n// and monkeypatch it onto Date.prototype.\n\nclass LegacyDateImpl {\n  toTemporalInstant(this: Date) {\n    const epochNanoseconds = ES.epochMsToNs(Date.prototype.valueOf.call(this));\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n}\n\nexport const toTemporalInstant = LegacyDateImpl.prototype.toTemporalInstant;\n","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\n\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n  Temporal.Instant,\n  Temporal.PlainDate,\n  Temporal.PlainDateTime,\n  Temporal.Duration,\n  Temporal.PlainMonthDay,\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\n  Temporal.PlainTime,\n  Temporal.PlainYearMonth,\n  Temporal.ZonedDateTime\n];\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { Temporal, Intl, toTemporalInstant };\n"],"names":["ZERO","JSBI","BigInt","ONE","TWO","TEN","TWENTY_FOUR","SIXTY","THOUSAND","MILLION","BILLION","HOUR_NANOS","multiply","MINUTE_NANOS_JSBI","DAY_NANOS_JSBI","ensureJSBI","value","toString","isEven","equal","remainder","abs","x","lessThan","unaryMinus","compare","y","greaterThan","divmod","quotient","divide","EPOCHNANOSECONDS","ISO_DATE","ISO_DATE_TIME","TIME","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","DATE","YM","MD","TIME_FMT","DATETIME","INST","ORIGINAL","TZ_CANONICAL","TZ_ORIGINAL","CAL_ID","LOCALE","OPTIONS","globalSlots","WeakMap","GetSlotsSymbol","Symbol","for","_a","globalThis","container","get","GetSlots","CreateSlotsSymbol","_b","set","Object","create","CreateSlots","HasSlot","ids","myslots","every","id","GetSlot","undefined","TypeError","SetSlot","slots","INTRINSICS","MakeIntrinsicClass","Class","name","defineProperty","prototype","toStringTag","writable","enumerable","configurable","staticNames","getOwnPropertyNames","i","length","prop","desc","getOwnPropertyDescriptor","protoNames","DefineIntrinsic","key","Error","GetIntrinsic","intrinsic","TruncatingDivModByPowerOf10","xParam","p","div","mod","sign","Math","xDigits","trunc","log10","xStr","toPrecision","Number","parseInt","slice","FMAPowerOf10","zParam","z","repeat","resStr","padStart","GetUnsignedRoundingMode","mode","isNegative","ApplyUnsignedRoundingMode","r1","r2","cmp","evenCardinality","unsignedRoundingMode","TimeDuration","constructor","totalNs","this","sec","toNumber","subsec","static","operation","MAX","RangeError","epochNs1","epochNs2","diff","subtract","h","min","s","ms","ns","add","validateNew","other","add24HourDays","days","addToEpochNs","epochNs","n","fdiv","nParam","nBigInt","decimalDigits","digit","push","join","isZero","round","incrementParam","increment","rounded","result","tzComponent","timeZoneID","RegExp","source","yearpart","monthpart","daypart","datesplit","timesplit","offset","offsetpart","annotation","zoneddatetime","time","yearmonth","monthday","fraction","durationTime","duration","DAY_MS","DAY_NANOS","MINUTE_NANOS","MS_MAX","NS_MAX","epochMsToNs","NS_MIN","DATETIME_NS_MIN","DATETIME_NS_MAX","MS_IN_400_YEAR_CYCLE","YEAR_MIN","YEAR_MAX","BEFORE_FIRST_DST","Date","UTC","BUILTIN_CALENDAR_IDS","ICU_LEGACY_TIME_ZONE_IDS","Set","IsObject","ToNumber","ToString","String","ToIntegerWithTruncation","number","isNaN","Infinity","integer","ToPositiveIntegerWithTruncation","valueParam","property","ToIntegerIfIntegral","argument","absValue","floor","IsIntegralNumber","ToZeroPaddedDecimalString","minLength","RequireString","ToPrimitive","preferredType","CALENDAR_FIELD_KEYS","BUILTIN_CASTS","era","eraYear","year","month","monthCode","indexOf","day","hour","minute","second","millisecond","microsecond","nanosecond","ParseDateTimeUTCOffset","timeZone","ToTemporalTimeZoneIdentifier","BUILTIN_DEFAULTS","TEMPORAL_UNITS","SINGULAR_FOR","fromEntries","map","e","PLURAL_FOR","UNITS_DESCENDING","NS_PER_TIME_UNIT","DURATION_FIELDS","OriginalIntlDateTimeFormat","Intl","DateTimeFormat","IntlDateTimeFormatEnUsCache","Map","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","lowercaseIdentifier","ASCIILowercase","instance","hour12","IsTemporalInstant","item","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","CheckReceiver","test","RejectTemporalLikeObject","calendar","FormatCalendarAnnotation","showCalendar","processAnnotations","annotations","match","calendarWasCritical","PARSE.annotation","lastIndex","exec","critical","ParseISODateTime","isoString","PARSE.zoneddatetime","yearString","hasTime","tzAnnotation","RejectDateTime","ParseTemporalTimeString","PARSE.time","RejectTime","ParseTemporalMonthDayString","RejectISODate","ParseTemporalYearMonthString","PARSE.yearmonth","referenceISODay","PARSE.monthday","referenceISOYear","TIMEZONE_IDENTIFIER","PARSE.timeZoneID","OFFSET_IDENTIFIER","throwBadTimeZoneStringError","timeZoneString","msg","OFFSET","ParseTimeZoneIdentifier","identifier","offsetMinutes","tzName","RegulateISODate","yearParam","monthParam","dayParam","overflow","ConstrainISODate","RegulateTime","hourParam","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","ConstrainToRange","ToTemporalPartialDurationRecord","temporalDurationLike","years","months","weeks","hours","minutes","seconds","milliseconds","microseconds","nanoseconds","any","index","AdjustDateDurationRecord","newDays","newWeeks","newMonths","CombineISODateAndTimeRecord","isoDate","GetTemporalOverflowOption","options","GetOption","GetTemporalDisambiguationOption","GetRoundingModeOption","fallback","GetTemporalOffsetOption","GetTemporalShowCalendarNameOption","GetTemporalRoundingIncrementOption","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","GetTemporalFractionalSecondDigitsOption","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","isFinite","ToSecondsStringPrecisionRecord","smallestUnit","precision","unit","REQUIRED","GetTemporalUnitValuedOption","unitGroup","requiredOrDefault","extraValues","allowedSingular","unitInfo","singular","category","concat","defaultVal","allowedValues","plural","retval","GetTemporalRelativeToOption","relativeTo","offsetBehaviour","matchMinutes","zonedRelativeTo","plainRelativeTo","CreateTemporalDate","GetTemporalCalendarIdentifierWithISODefault","fields","PrepareCalendarFields","InterpretTemporalDateTimeFields","CanonicalizeCalendar","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","DefaultTemporalLargestUnit","LargerOfTwoTemporalUnits","unit1","unit2","IsCalendarUnit","TemporalUnitCategory","calendarImplForID","calendarImplForObj","temporalObj","ISODateToFields","type","calendarDate","isoToDate","bag","calendarFieldNames","nonCalendarFieldNames","requiredFields","extraFieldNames","extraFields","sort","castExists","includes","ToTemporalTimeRecord","completeness","field","ToTemporalDate","GetOptionsObject","isoDateTime","GetISODateTimeFor","CalendarDateFromFields","ToTemporalDateTime","CreateTemporalDateTime","deltaDays","ToTemporalDuration","TemporalDuration","PARSE.duration","part","fHours","minutesStr","fMinutes","secondsStr","fSeconds","excessNanoseconds","RejectDuration","ParseTemporalDurationStringRaw","ParseTemporalDurationString","partial","ToTemporalInstant","itemParam","CreateTemporalInstant","ParseTemporalInstantString","balanced","BalanceISODateTime","CheckISODaysRange","GetUTCEpochNanoseconds","ToTemporalMonthDay","CreateTemporalMonthDay","ToTemporalCalendarIdentifier","CalendarMonthDayFromFields","RejectDateRange","ToTemporalTime","CreateTemporalTime","ToTimeRecordOrMidnight","ToTemporalYearMonth","CreateTemporalYearMonth","CalendarYearMonthFromFields","RejectYearMonthRange","offsetNs","disambiguation","offsetOpt","matchMinute","GetStartOfDay","dt","GetEpochNanosecondsFor","ValidateEpochNanoseconds","utcEpochNs","possibleEpochNs","GetPossibleEpochNanoseconds","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","offsetStr","FormatUTCOffsetNanoseconds","dtStr","ISODateTimeToString","DisambiguatePossibleEpochNanoseconds","ToTemporalZonedDateTime","resolvedOptions","ParseTemporalZonedDateTimeString","CreateTemporalDateSlots","TemporalPlainDate","CreateTemporalDateTimeSlots","RejectDateTimeRange","TemporalPlainDateTime","CreateTemporalMonthDaySlots","TemporalPlainMonthDay","CreateTemporalTimeSlots","TemporalPlainTime","CreateTemporalYearMonthSlots","TemporalPlainYearMonth","CreateTemporalInstantSlots","epochNanoseconds","TemporalInstant","CreateTemporalZonedDateTimeSlots","TemporalZonedDateTime","CalendarFieldKeysPresent","filter","CalendarMergeFields","additionalFields","additionalKeys","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ix","propValue","CalendarDateAdd","dateDuration","dateAdd","CalendarDateUntil","isoOtherDate","largestUnit","dateUntil","calendarLike","CalendarEquals","one","two","calendarImpl","resolveFields","dateToISO","monthDayToISOReferenceDate","temporalTimeZoneLike","stringIdent","ParseTemporalTimeZoneStringRaw","ParseTemporalTimeZoneString","FormatOffsetTimeZoneIdentifier","record","GetAvailableNamedTimeZoneIdentifier","TimeZoneEquals","offsetMinutes1","offsetMinutes2","idRecord2","idRecord1","primaryIdentifier","GetOffsetNanosecondsFor","GetNamedTimeZoneOffsetNanoseconds","absoluteNs","subSecondNs","FormatTimeString","GetISOPartsFromEpoch","numInstants","utcns","dayBefore","offsetBefore","dayAfter","timeDuration","fromComponents","earlierTime","AddTime","BalanceISODate","laterTime","possible","nsEarlier","nsLater","earlierOffsetNs","laterOffsetNs","candidates","offsetNanoseconds","parts","epochMilliseconds","GetFormatterParts","GetNamedTimeZoneDateTimeParts","CompareISODateTime","GetNamedTimeZoneEpochNanoseconds","GetNamedTimeZoneNextTransition","ISOYearString","ISODateTimePartString","FormatFractionalSeconds","subSecondNanoseconds","replace","TemporalInstantToString","instant","outputTimeZone","dateTimeString","FormatDateTimeUTCOffsetRounded","TemporalDurationToString","DurationSign","datePart","timePart","secondsDuration","TemporalDateToString","date","TimeRecordToString","TemporalMonthDayToString","monthDay","resultString","calendarString","TemporalYearMonthToString","yearMonth","TemporalZonedDateTimeToString","zdt","showTimeZone","showOffset","roundingMode","RoundTemporalInstant","tz","IsOffsetTimeZoneIdentifier","string","OFFSET_WITH_PARTS","canonicalTimeZoneIdsCache","isTZIDSep","assign","_","canonicalTimeZoneIds","supportedValuesOf","lower","has","segments","c","toUpperCase","split","specialCases","GetNamedTimeZoneOffsetNanosecondsImpl","GetUTCEpochMilliseconds","epochNsToMs","absoluteMinutes","offsetNanosecondsParam","reducedYear","yearCycles","legacyDate","setUTCHours","setUTCFullYear","getTime","subMs","nanos","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","now","uppercap","max","leftMs","leftOffsetNs","rightMs","rightOffsetNs","bisect","epochMs","GetNamedTimeZonePreviousTransition","lookahead","prevBeforeLookahead","lastPrecomputed","datetime","splits","parseFromEnUsFormat","format","LeapYear","ISODaysInMonth","standard","leapyear","DateDurationSign","fieldNames","InternalDurationSign","dateSign","BalanceISOYearMonth","daysIn400YearCycle","nCycles","daysInYear","testYear","BalanceTime","DateDurationDays","yearsMonthsWeeksDuration","later","epochDaysEarlier","ISODateToEpochDays","yearsMonthsWeeksInDays","CreateNegatedTemporalDuration","RejectToRange","AssertISODateTimeWithinLimits","mon","w","d","propSign","msResult","nsResult","remainderSec","totalSec","isSafeInteger","ToInternalDurationRecord","ToInternalDurationRecordWith24HourDays","ToDateDurationRecordWithoutTime","internalDuration","TemporalDurationFromInternal","CombineDateAndTimeDuration","DifferenceTime","time1","time2","DifferenceInstant","ns1","ns2","fromEpochNsDiff","RoundTimeDuration","DifferenceISODateTime","isoDateTime1","isoDateTime2","timeSign","CompareISODate","adjustedDate","dateLargestUnit","dateDifference","DifferenceZonedDateTime","nsDiff","isoDtStart","isoDtEnd","intermediateDateTime","dayCorrection","maxDayCorrection","intermediateNs","NudgeToCalendarUnit","durationParam","destEpochNs","startDuration","endDuration","yearsMonths","weeksStart","untilResult","start","end","startEpochNs","endEpochNs","startDateTime","endDateTime","numerator","denominator","even","roundedUnit","total","didExpandCalendarUnit","nudgeResult","nudgedEpochNs","RoundRelativeDuration","largestUnitParam","irregularLengthUnit","daySpan","unitIncrement","roundedTimeDuration","beyondDaySpan","didRoundBeyondDay","dayDelta","NudgeToZonedTime","roundedTime","diffTime","wholeDays","roundedWholeDays","didExpandDays","NudgeToDayOrTime","largestUnitIndex","unitIndex","BubbleRelativeDuration","TotalRelativeDuration","TotalTimeDuration","DifferencePlainDateTimeWithRounding","DifferenceZonedDateTimeWithRounding","GetDifferenceSettings","op","group","disallowed","fallbackSmallest","smallestLargestDefaultUnit","ALLOWED_UNITS","reduce","allowed","NegateRoundingMode","defaultLargestUnit","DifferenceTemporalInstant","otherParam","settings","DifferenceTemporalPlainDate","plainDate","otherCalendar","Duration","isoOther","DifferenceTemporalPlainDateTime","plainDateTime","DifferenceTemporalPlainTime","plainTime","DifferenceTemporalPlainYearMonth","thisFields","thisDate","otherFields","otherDate","DifferenceTemporalZonedDateTime","zonedDateTime","AddInstant","AddZonedDateTime","AddDurations","d1","d2","AddDurationToInstant","durationLike","AddDurationToDate","AddDurationToDateTime","dateTime","timeResult","AddDurationToTime","temporalTime","AddDurationToYearMonth","startDate","nextMonth","durationToAdd","AddDurationToZonedDateTime","quantity","ComparisonResult","incrementNs","quantityParam","RoundNumberToIncrementAsIfPositive","RoundISODateTime","RoundTime","nsPerUnit","divisor","isoDate1","isoDate2","CompareTimeRecord","dateResult","ToBigIntExternal","arg","jsbiBI","ToBigInt","epochNanosecondsParam","isInteger","prim","toPrimFn","toPrimitive","call","SystemUTCEpochNanoSeconds","DefaultTimeZone","CreateOnePropObject","propName","o","idParam","str","lowercase","code","charCodeAt","fromCharCode","ValueOfThrows","constructorName","PARSE.offset","getState","leftParam","rightParam","lstateParam","rstateParam","left","right","lstate","rstate","middle","mstate","arrayFromSet","src","calendarDateWeekOfYear","impl","yow","dayOfWeek","dayOfYear","fdow","getFirstDayOfWeek","mdow","getMinimalDaysInFirstWeek","relDow","relDowJan1","woy","firstDayOfWeek","minimalDaysInFirstWeek","desiredDay","periodStartDayOfWeek","weekNo","weekNumber","lastRelDow","week","ISODateSurpasses","y1","m1","nonLeapMonthCodeNumberPart","startsWith","buildMonthCode","leap","resolveNonLunisolarMonth","monthsPerYear","ES.RejectToRange","ES.ConstrainToRange","numberPart","ES.RegulateISODate","keys","ES.BalanceISOYearMonth","ES.BalanceISODate","ES.CompareISODate","intermediate","candidateYears","candidateMonths","constrained","ES.ConstrainISODate","ES.ISODateToEpochDays","requestedFields","daysInWeek","monthsInYear","shiftedMonth","shiftedYear","century","yearInCentury","dow","m","ES.ISODaysInMonth","weekOfYear","daysInMonth","inLeapYear","ES.LeapYear","OneObjectCache","cacheToClone","calls","hits","misses","entry","entries","MAX_CACHE_ENTRIES","report","setObject","obj","objectMap","cache","toUtcIsoDateString","isoYear","isoMonth","isoDay","ES.ISOYearString","ES.ISODateTimePartString","simpleDateDiff","HelperBase","eras","hasEra","erasBeginMidYear","getFormatter","formatter","getCalendarParts","dateTimeFormat","locale","formatToParts","isoToCalendarDate","JSON","stringify","func","cached","matches","monthExtra","normalize","toLowerCase","replacement","find","genericName","reviseIntlEra","checkIcuBugs","adjustCalendarDate","forEach","keyReverse","validateCalendarDate","calendarDateParam","fromLegacyDate","calendarType","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","dateParam","originalDate","keyOriginal","isoEstimate","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","oldSign","date1","date2","ES.ComparisonResult","regulateDate","addDaysCalendar","addedIso","addMonthsCalendar","absMonths","oldCalendarDate","daysInPreviousMonth","monthsInOldYear","addCalendar","addedYears","addedMonths","initialDays","untilCalendar","calendarOne","calendarTwo","calendarDaysUntil","totalDays","diffYears","diffInYearSign","current","next","addedIsoDate","addedCalendarDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","startOfCalendarYear","startOfCalendarMonth","oneIso","twoIso","monthDaySearchStartYear","monthDayFromFields","closestCalendar","closestIso","startDateIso","calendarOfStartDateIso","calendarYear","roundTripCalendarDate","maxDayForMonthCode","maxLengthOfMonthCodeInAnyYear","HebrewHelper","Tishri","regular","Heshvan","Kislev","Tevet","Shevat","Adar","Nisan","Iyar","Sivan","Tamuz","Av","Elul","minMaxMonthLength","minOrMax","getMonthCode","monthInfo","endsWith","IslamicBaseHelper","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","startOfYearCalendar","startOfNextYearCalendar","IslamicHelper","IslamicUmalquraHelper","IslamicTblaHelper","IslamicCivilHelper","IslamicRgsaHelper","IslamicCcHelper","PersianHelper","IndianHelper","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","GregorianBaseHelperFixedEpoch","isoEpoch","super","GregorianBaseHelper","originalEras","anchorEra","erasParam","reverseOf","isAnchor","anchorEpoch","hasYearZero","reversedEra","e1","e2","lastEraReversed","adjustEras","completeEraYear","checkField","names","currentValue","preferredName","eraFromYear","adjustedCalendarDate","matchingEra","eraNames","matchData","SameMonthDayAsGregorianBaseHelper","OrthodoxOps","OrthodoxBaseHelperFixedEpoch","OrthodoxBaseHelper","EthioaaHelper","CopticHelper","EthiopicHelper","RocHelper","BuddhistHelper","GregoryHelper","JapaneseHelper","ChineseBaseHelper","getMonthList","M01L","M02L","M03L","M04L","M05L","M06L","M07L","M08L","M09L","M10L","M11L","M12L","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","calendarMonthString","tv","calendarDay","calendarYearPartToVerify","calendarYearToVerify","isoDaysDelta","oldCalendarDay","oldMonthString","monthIndex","done","monthString","ch","withoutML","monthEntries","matchingMonthEntry","ChineseHelper","DangiHelper","NonIsoCalendar","helper","getCacheForObject","added","isoAdded","cacheOne","cacheTwo","startOfYear","Helper","getSlotLazy","slot","val","ResetSlot","IsPatchedDateTimeFormat","DateTimeFormatImpl","locales","dtf","optionsParam","hasOptions","props","ES.ToObject","newOptions","hasOwnProperty","original","ro","clonedResolved","hourCycle","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","datetimeAmend","instantAmend","timeZoneOption","ES.ToString","ES.ToTemporalTimeZoneIdentifier","createDateTimeFormat","ES.CheckReceiver","boundFormat","bind","defineProperties","formatRange","a","b","rest","formatRangeToParts","resolved","formatArgs","overrides","extractOverrides","ES.epochNsToMs","aParam","bParam","toDateTimeFormattable","isTemporalObject","sameTemporalType","aa","aformatter","bb","bformatter","amend","amended","opt","originalOptions","weekday","timeZoneName","dateStyle","timeStyle","hasTimeOptions","hasAnyDateTimeOptions","dateStyleHacks","short","medium","long","full","dayPeriod","style","hasDateOptions","ES.IsTemporalDate","ES.IsTemporalTime","ES.IsTemporalDateTime","ES.IsTemporalZonedDateTime","ES.IsTemporalYearMonth","ES.IsTemporalMonthDay","ES.IsTemporalInstant","ES.ToNumber","main","ES.GetEpochNanosecondsFor","mainCalendar","ES.CombineISODateAndTimeRecord","temporalDurationToCompatibilityRecord","supportedLocalesOf","IntlDurationFormatPrototypeFormat","IntlDurationFormatPrototypeFormatToParts","DurationFormat","ModifiedIntlDurationFormatPrototypeFormat","ES.ToTemporalDuration","Instant","arguments","ES.CreateTemporalInstantSlots","ES.ToBigInt","ES.ToBigIntExternal","ES.AddDurationToInstant","until","ES.DifferenceTemporalInstant","since","roundToParam","roundTo","ES.CreateOnePropObject","ES.GetOptionsObject","ES.GetTemporalRoundingIncrementOption","ES.GetRoundingModeOption","ES.GetTemporalUnitValuedOption","ES.REQUIRED","ES.ValidateTemporalRoundingIncrement","ES.CreateTemporalInstant","ES.RoundTemporalInstant","equals","ES.ToTemporalInstant","digits","ES.GetTemporalFractionalSecondDigitsOption","ES.ToSecondsStringPrecisionRecord","ES.TemporalInstantToString","toJSON","toLocaleString","valueOf","ES.ValueOfThrows","toZonedDateTimeISO","timeZoneParam","ES.CreateTemporalZonedDateTime","ES.epochMsToNs","oneParam","twoParam","oneNs","twoNs","PlainDate","calendarParam","ES.ToIntegerWithTruncation","ES.CanonicalizeCalendar","ES.RequireString","ES.RejectISODate","ES.CreateTemporalDateSlots","calendarId","getCalendarProperty","yearOfWeek","with","temporalDateLike","ES.IsObject","ES.RejectTemporalLikeObject","ES.ISODateToFields","ES.CalendarMergeFields","ES.PrepareCalendarFields","ES.CreateTemporalDate","ES.CalendarDateFromFields","ES.GetTemporalOverflowOption","withCalendar","ES.ToTemporalCalendarIdentifier","ES.AddDurationToDate","ES.DifferenceTemporalPlainDate","ES.ToTemporalDate","ES.CalendarEquals","ES.TemporalDateToString","ES.GetTemporalShowCalendarNameOption","toPlainDateTime","ES.ToTimeRecordOrMidnight","ES.CreateTemporalDateTime","toZonedDateTime","timeZoneLike","ES.GetStartOfDay","ES.ToTemporalTime","toPlainYearMonth","ES.CreateTemporalYearMonth","ES.CalendarYearMonthFromFields","toPlainMonthDay","ES.CreateTemporalMonthDay","ES.CalendarMonthDayFromFields","ES.calendarImplForObj","PlainDateTime","ES.RejectDateTime","ES.CreateTemporalDateTimeSlots","getTimeProperty","temporalDateTimeLike","ES.InterpretTemporalDateTimeFields","withPlainTime","ES.AddDurationToDateTime","ES.DifferenceTemporalPlainDateTime","ES.RoundISODateTime","ES.ToTemporalDateTime","ES.CompareISODateTime","ES.RejectDateTimeRange","ES.ISODateTimeToString","ES.GetTemporalDisambiguationOption","toPlainDate","toPlainTime","ES.CreateTemporalTime","yearsParam","monthsParam","weeksParam","daysParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","ES.ToIntegerIfIntegral","ES.RejectDuration","ES.IsTemporalDuration","ES.DurationSign","blank","partialDuration","ES.ToTemporalPartialDurationRecord","negated","ES.CreateNegatedTemporalDuration","ES.AddDurations","existingLargestUnit","ES.DefaultTemporalLargestUnit","ES.GetTemporalRelativeToOption","smallestUnitPresent","ES.LargerOfTwoTemporalUnits","largestUnitPresent","ES.TemporalUnitCategory","ES.ToInternalDurationRecord","relativeEpochNs","ES.DifferenceZonedDateTimeWithRounding","ES.AddZonedDateTime","ES.TemporalDurationFromInternal","ES.ToInternalDurationRecordWith24HourDays","targetTime","ES.AddTime","isoRelativeToDate","targetDate","ES.CalendarDateAdd","ES.AdjustDateDurationRecord","ES.DifferencePlainDateTimeWithRounding","ES.IsCalendarUnit","ES.DAY_NANOS","ES.TotalTimeDuration","ES.RoundNumberToIncrement","ES.CombineDateAndTimeDuration","ES.RoundTimeDuration","ES.DifferenceZonedDateTimeWithTotal","ES.DifferencePlainDateTimeWithTotal","ES.TemporalDurationToString","console","warn","largestUnit1","largestUnit2","duration1","duration2","after1","after2","ES.DateDurationDays","timeDuration1","timeDuration2","PlainMonthDay","ES.CreateTemporalMonthDaySlots","temporalMonthDayLike","ES.ToTemporalMonthDay","ES.TemporalMonthDayToString","md","SystemDateTime","ES.GetISODateTimeFor","ES.SystemUTCEpochNanoSeconds","Now","plainDateTimeISO","ES.DefaultTimeZone","plainDateISO","plainTimeISO","timeZoneId","zonedDateTimeISO","PlainTime","isoHour","isoMinute","isoSecond","isoMillisecond","isoMicrosecond","isoNanosecond","ES.RejectTime","ES.CreateTemporalTimeSlots","temporalTimeLike","partialTime","ES.ToTemporalTimeRecord","ES.RegulateTime","ES.AddDurationToTime","ES.DifferenceTemporalPlainTime","ES.RoundTime","ES.CompareTimeRecord","ES.TimeRecordToString","PlainYearMonth","ES.CreateTemporalYearMonthSlots","temporalYearMonthLike","ES.AddDurationToYearMonth","ES.DifferenceTemporalPlainYearMonth","ES.ToTemporalYearMonth","ES.TemporalYearMonthToString","ym","customResolvedOptions","ZonedDateTime","ES.ParseTimeZoneIdentifier","ES.GetAvailableNamedTimeZoneIdentifier","ES.FormatOffsetTimeZoneIdentifier","ES.CreateTemporalZonedDateTimeSlots","hoursInDay","today","tomorrow","todayNs","tomorrowNs","ES.FormatUTCOffsetNanoseconds","ES.GetOffsetNanosecondsFor","temporalZonedDateTimeLike","ES.GetTemporalOffsetOption","newDateTime","newOffsetNs","ES.ParseDateTimeUTCOffset","ES.InterpretISODateTimeOffset","temporalTimeParam","iso","withTimeZone","ES.AddDurationToZonedDateTime","ES.DifferenceTemporalZonedDateTime","thisNs","dateStart","dateEnd","startNs","endNs","dayLengthNs","roundedDateTime","ES.ToTemporalZonedDateTime","ES.TimeZoneEquals","ES.GetTemporalShowOffsetOption","ES.GetTemporalShowTimeZoneNameOption","ES.TemporalZonedDateTimeToString","optionsCopy","target","excludedKeys","excludedValues","Reflect","ownKeys","nextKey","some","is","propertyIsEnumerable","ES.CopyDataProperties","ES.IsOffsetTimeZoneIdentifier","localeCalendarIdentifier","calendarIdentifier","startOfDay","getTimeZoneTransition","directionParam","direction","thisEpochNanoseconds","ES.GetNamedTimeZoneNextTransition","ES.GetNamedTimeZonePreviousTransition","toInstant","toTemporalInstant","LegacyDateImpl","types","Temporal.Instant","Temporal.PlainDate","Temporal.PlainDateTime","Temporal.Duration","Temporal.PlainMonthDay","Temporal.PlainTime","Temporal.PlainYearMonth","Temporal.ZonedDateTime","descriptor"],"mappings":"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"}