{"version":3,"file":"index.umd.js","sources":["../lib/bigintmath.ts","../lib/slots.ts","../lib/intrinsicclass.ts","../lib/math.ts","../lib/timeduration.ts","../lib/regex.ts","../lib/ecmascript.ts","../lib/calendar.ts","../lib/intl.ts","../lib/instant.ts","../lib/plaindate.ts","../lib/plaindatetime.ts","../lib/duration.ts","../lib/plainmonthday.ts","../lib/now.ts","../lib/plaintime.ts","../lib/plainyearmonth.ts","../lib/zoneddatetime.ts","../lib/legacydate.ts","../lib/index.ts"],"sourcesContent":["import JSBI from 'jsbi';\n\nexport const ZERO = JSBI.BigInt(0);\nexport const ONE = JSBI.BigInt(1);\nexport const TWO = JSBI.BigInt(2);\nexport const TEN = JSBI.BigInt(10);\nconst TWENTY_FOUR = JSBI.BigInt(24);\nconst SIXTY = JSBI.BigInt(60);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst HOUR_SECONDS = 3600;\nexport const HOUR_NANOS = JSBI.multiply(JSBI.BigInt(HOUR_SECONDS), BILLION);\nexport const MINUTE_NANOS_JSBI = JSBI.multiply(SIXTY, BILLION);\nexport const DAY_NANOS_JSBI = JSBI.multiply(HOUR_NANOS, TWENTY_FOUR);\n\n/** Handle a JSBI or native BigInt. For user input, use ES.ToBigInt instead */\nexport function ensureJSBI(value: JSBI | bigint) {\n  return typeof value === 'bigint' ? JSBI.BigInt(value.toString(10)) : value;\n}\n\nexport function isEven(value: JSBI): boolean {\n  return JSBI.equal(JSBI.remainder(value, TWO), ZERO);\n}\n\nexport function abs(x: JSBI): JSBI {\n  if (JSBI.lessThan(x, ZERO)) return JSBI.unaryMinus(x);\n  return x;\n}\n\nexport function compare(x: JSBI, y: JSBI): -1 | 0 | 1 {\n  return JSBI.lessThan(x, y) ? -1 : JSBI.greaterThan(x, y) ? 1 : 0;\n}\n\nexport function divmod(x: JSBI, y: JSBI): { quotient: JSBI; remainder: JSBI } {\n  const quotient = JSBI.divide(x, y);\n  const remainder = JSBI.remainder(x, y);\n  return { quotient, remainder };\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  AnySlottedType,\n  FormatterOrAmender,\n  ISODate,\n  ISODateTime,\n  TimeRecord\n} from './internaltypes';\nimport type { DateTimeFormatImpl } from './intl';\n\n// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_DATE = 'slot-iso-date';\nexport const ISO_DATE_TIME = 'slot-iso-date-time';\nexport const TIME = 'slot-time';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n\n// ZonedDateTime\nexport const TIME_ZONE = 'slot-time-zone';\n\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n\n// DateTimeFormatImpl\nexport const DATE = 'date';\nexport const YM = 'ym';\nexport const MD = 'md';\nexport const TIME_FMT = 'time';\nexport const DATETIME = 'datetime';\nexport const INST = 'instant';\nexport const ORIGINAL = 'original';\nexport const TZ_CANONICAL = 'timezone-canonical';\nexport const TZ_ORIGINAL = 'timezone-original';\nexport const CAL_ID = 'calendar-id';\nexport const LOCALE = 'locale';\nexport const OPTIONS = 'options';\n\ninterface SlotInfo<ValueType, UsedByType extends AnySlottedType> {\n  value: ValueType;\n  usedBy: UsedByType;\n}\n\ninterface SlotInfoRecord {\n  [k: string]: SlotInfo<unknown, AnySlottedType>;\n}\n\ninterface Slots extends SlotInfoRecord {\n  // Instant\n  [EPOCHNANOSECONDS]: SlotInfo<JSBI, Temporal.Instant | Temporal.ZonedDateTime>; // number? JSBI?\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_DATE]: SlotInfo<ISODate, Temporal.PlainDate | Temporal.PlainMonthDay | Temporal.PlainYearMonth>;\n  [ISO_DATE_TIME]: SlotInfo<ISODateTime, Temporal.PlainDateTime>;\n  [TIME]: SlotInfo<TimeRecord, Temporal.PlainTime>;\n  [CALENDAR]: SlotInfo<BuiltinCalendarId, TypesWithCalendarUnits>;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: SlotInfo<true, Temporal.PlainDate>;\n  [YEAR_MONTH_BRAND]: SlotInfo<true, Temporal.PlainYearMonth>;\n  [MONTH_DAY_BRAND]: SlotInfo<true, Temporal.PlainMonthDay>;\n\n  // ZonedDateTime\n  [TIME_ZONE]: SlotInfo<string, Temporal.ZonedDateTime>;\n\n  // Duration\n  [YEARS]: SlotInfo<number, Temporal.Duration>;\n  [MONTHS]: SlotInfo<number, Temporal.Duration>;\n  [WEEKS]: SlotInfo<number, Temporal.Duration>;\n  [DAYS]: SlotInfo<number, Temporal.Duration>;\n  [HOURS]: SlotInfo<number, Temporal.Duration>;\n  [MINUTES]: SlotInfo<number, Temporal.Duration>;\n  [SECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MILLISECONDS]: SlotInfo<number, Temporal.Duration>;\n  [MICROSECONDS]: SlotInfo<number, Temporal.Duration>;\n  [NANOSECONDS]: SlotInfo<number, Temporal.Duration>;\n\n  // DateTimeFormatImpl\n  [DATE]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [YM]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [MD]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [TIME_FMT]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [DATETIME]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [INST]: SlotInfo<FormatterOrAmender, DateTimeFormatImpl>;\n  [ORIGINAL]: SlotInfo<globalThis.Intl.DateTimeFormat, DateTimeFormatImpl>;\n  [TZ_CANONICAL]: SlotInfo<string, DateTimeFormatImpl>;\n  [TZ_ORIGINAL]: SlotInfo<string, DateTimeFormatImpl>;\n  [CAL_ID]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['calendar'], DateTimeFormatImpl>;\n  [LOCALE]: SlotInfo<globalThis.Intl.ResolvedDateTimeFormatOptions['locale'], DateTimeFormatImpl>;\n  [OPTIONS]: SlotInfo<Intl.DateTimeFormatOptions, DateTimeFormatImpl>;\n}\n\ntype TypesWithCalendarUnits =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime;\n\ninterface SlotsToTypes {\n  // Instant\n  [EPOCHNANOSECONDS]: Temporal.Instant;\n\n  // DateTime, Date, Time, YearMonth, MonthDay\n  [ISO_DATE]: Temporal.PlainDate | Temporal.PlainYearMonth | Temporal.PlainMonthDay;\n  [ISO_DATE_TIME]: Temporal.PlainDateTime;\n  [TIME]: Temporal.PlainTime;\n  [CALENDAR]: TypesWithCalendarUnits;\n\n  // Date, YearMonth, MonthDay common slots\n  [DATE_BRAND]: Temporal.PlainDate;\n  [YEAR_MONTH_BRAND]: Temporal.PlainYearMonth;\n  [MONTH_DAY_BRAND]: Temporal.PlainMonthDay;\n\n  // ZonedDateTime\n  [TIME_ZONE]: Temporal.ZonedDateTime;\n\n  // Duration\n  [YEARS]: Temporal.Duration;\n  [MONTHS]: Temporal.Duration;\n  [WEEKS]: Temporal.Duration;\n  [DAYS]: Temporal.Duration;\n  [HOURS]: Temporal.Duration;\n  [MINUTES]: Temporal.Duration;\n  [SECONDS]: Temporal.Duration;\n  [MILLISECONDS]: Temporal.Duration;\n  [MICROSECONDS]: Temporal.Duration;\n  [NANOSECONDS]: Temporal.Duration;\n\n  // DateTimeFormatImpl\n  [DATE]: DateTimeFormatImpl;\n  [YM]: DateTimeFormatImpl;\n  [MD]: DateTimeFormatImpl;\n  [TIME_FMT]: DateTimeFormatImpl;\n  [DATETIME]: DateTimeFormatImpl;\n  [INST]: DateTimeFormatImpl;\n  [ORIGINAL]: DateTimeFormatImpl;\n  [TZ_CANONICAL]: DateTimeFormatImpl;\n  [TZ_ORIGINAL]: DateTimeFormatImpl;\n  [CAL_ID]: DateTimeFormatImpl;\n  [LOCALE]: DateTimeFormatImpl;\n  [OPTIONS]: DateTimeFormatImpl;\n}\n\ntype SlotKey = keyof SlotsToTypes;\n\nconst globalSlots = new WeakMap<Slots[keyof Slots]['usedBy'], Record<keyof Slots, Slots[keyof Slots]['value']>>();\n\nfunction _GetSlots(container: Slots[keyof Slots]['usedBy']) {\n  return globalSlots.get(container);\n}\n\nconst GetSlotsSymbol = Symbol.for('@@Temporal__GetSlots');\n\n// expose GetSlots to avoid dual package hazards\n(globalThis as any)[GetSlotsSymbol] ||= _GetSlots;\n\nconst GetSlots = (globalThis as any)[GetSlotsSymbol] as typeof _GetSlots;\n\nfunction _CreateSlots(container: Slots[keyof Slots]['usedBy']): void {\n  globalSlots.set(container, Object.create(null));\n}\n\nconst CreateSlotsSymbol = Symbol.for('@@Temporal__CreateSlots');\n\n// expose CreateSlots to avoid dual package hazards\n(globalThis as any)[CreateSlotsSymbol] ||= _CreateSlots;\n\nexport const CreateSlots = (globalThis as any)[CreateSlotsSymbol] as typeof _CreateSlots;\n\n// TODO: is there a better way than 9 overloads to make HasSlot into a type\n// guard that takes a variable number of parameters?\nexport function HasSlot<ID1 extends SlotKey>(container: unknown, id1: ID1): container is Slots[ID1]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3\n): container is Slots[ID1]['usedBy'] | Slots[ID2]['usedBy'] | Slots[ID3]['usedBy'];\nexport function HasSlot<ID1 extends SlotKey, ID2 extends SlotKey, ID3 extends SlotKey, ID4 extends SlotKey>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4\n): container is Slots[ID1 | ID2 | ID3 | ID4]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8]['usedBy'];\nexport function HasSlot<\n  ID1 extends SlotKey,\n  ID2 extends SlotKey,\n  ID3 extends SlotKey,\n  ID4 extends SlotKey,\n  ID5 extends SlotKey,\n  ID6 extends SlotKey,\n  ID7 extends SlotKey,\n  ID8 extends SlotKey,\n  ID9 extends SlotKey\n>(\n  container: unknown,\n  id1: ID1,\n  id2: ID2,\n  id3: ID3,\n  id4: ID4,\n  id5: ID5,\n  id6: ID6,\n  id7: ID7,\n  id8: ID8,\n  id9: ID9\n): container is Slots[ID1 | ID2 | ID3 | ID4 | ID5 | ID6 | ID7 | ID8 | ID9]['usedBy'];\nexport function HasSlot(container: unknown, ...ids: (keyof Slots)[]): boolean {\n  if (!container || 'object' !== typeof container) return false;\n  const myslots = GetSlots(container as AnySlottedType);\n  return !!myslots && ids.every((id) => id in myslots);\n}\nexport function GetSlot<KeyT extends keyof Slots>(\n  container: Slots[typeof id]['usedBy'],\n  id: KeyT\n): Slots[KeyT]['value'] {\n  const value = GetSlots(container)?.[id];\n  if (value === undefined) throw new TypeError(`Missing internal slot ${id}`);\n  return value;\n}\nexport function SetSlot<KeyT extends SlotKey>(\n  container: Slots[KeyT]['usedBy'],\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot) throw new TypeError(`${id} already has set`);\n\n  slots[id] = value;\n}\n\nexport function ResetSlot<KeyT extends SlotKey>(\n  container: DateTimeFormatImpl,\n  id: KeyT,\n  value: Slots[KeyT]['value']\n): void {\n  const slots = GetSlots(container);\n\n  if (slots === undefined) throw new TypeError('Missing slots for the given container');\n\n  const existingSlot = slots[id];\n\n  if (existingSlot === undefined) throw new TypeError(`tried to reset ${id} which was not set`);\n\n  slots[id] = value;\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\nimport type { CalendarImpl } from './calendar';\nimport type { BuiltinCalendarId } from './internaltypes';\nimport type { DateTimeFormatImpl } from './intl';\n\nimport { DEBUG } from './debug';\nimport { GetSlot, ORIGINAL } from './slots';\n\ntype OmitConstructor<T> = { [P in keyof T as T[P] extends new (...args: any[]) => any ? P : never]: T[P] };\n\ntype TemporalIntrinsics = {\n  ['Intl.DateTimeFormat']: typeof globalThis.Intl.DateTimeFormat;\n  ['Temporal.Duration']: typeof Temporal.Duration;\n  ['Temporal.Instant']: OmitConstructor<Temporal.Instant> &\n    (new (epochNanoseconds: JSBI) => Temporal.Instant) & { prototype: typeof Temporal.Instant.prototype };\n  ['Temporal.PlainDate']: typeof Temporal.PlainDate;\n  ['Temporal.PlainDateTime']: typeof Temporal.PlainDateTime;\n  ['Temporal.PlainMonthDay']: typeof Temporal.PlainMonthDay;\n  ['Temporal.PlainTime']: typeof Temporal.PlainTime;\n  ['Temporal.PlainYearMonth']: typeof Temporal.PlainYearMonth;\n  ['Temporal.ZonedDateTime']: OmitConstructor<Temporal.ZonedDateTime> &\n    (new (epochNanoseconds: JSBI, timeZone: string, calendar?: string) => Temporal.ZonedDateTime) & {\n      prototype: typeof Temporal.ZonedDateTime.prototype;\n      from: typeof Temporal.ZonedDateTime.from;\n      compare: typeof Temporal.ZonedDateTime.compare;\n    };\n};\ntype TemporalIntrinsicRegistrations = {\n  [key in keyof TemporalIntrinsics]: TemporalIntrinsics[key];\n};\ntype TemporalIntrinsicPrototypeRegistrations = {\n  [key in keyof TemporalIntrinsics as `${key}.prototype`]: TemporalIntrinsics[key]['prototype'];\n};\ntype TemporalIntrinsicRegisteredKeys = {\n  [key in keyof TemporalIntrinsicRegistrations as `%${key}%`]: TemporalIntrinsicRegistrations[key];\n};\ntype TemporalIntrinsicPrototypeRegisteredKeys = {\n  [key in keyof TemporalIntrinsicPrototypeRegistrations as `%${key}%`]: TemporalIntrinsicPrototypeRegistrations[key];\n};\n\ntype OtherIntrinsics = {\n  calendarImpl: (id: BuiltinCalendarId) => CalendarImpl;\n};\ntype OtherIntrinsicKeys = { [key in keyof OtherIntrinsics as `%${key}%`]: OtherIntrinsics[key] };\n\nconst INTRINSICS = {} as TemporalIntrinsicRegisteredKeys &\n  TemporalIntrinsicPrototypeRegisteredKeys &\n  OtherIntrinsicKeys;\n\ntype StylizeOption = (value: unknown, type: 'number' | 'special') => string;\n\ntype customFormatFunction<T> = (\n  this: T & { _repr_: string }, // _repr_ is present if DEBUG\n  depth: number,\n  options: { stylize: StylizeOption },\n  inspect: (object: T, options?: { depth: number; stylize: StylizeOption }) => string\n) => string;\nconst customUtilInspectFormatters: Partial<{\n  [key in keyof TemporalIntrinsicRegistrations]: customFormatFunction<\n    InstanceType<TemporalIntrinsicRegistrations[key]>\n  >;\n}> = {\n  ['Intl.DateTimeFormat'](depth, options, inspect) {\n    return inspect(GetSlot(this as DateTimeFormatImpl, ORIGINAL), { depth, ...options });\n  },\n  ['Temporal.Duration'](depth, options) {\n    const descr = options.stylize(this._repr_, 'special');\n    if (depth < 1) return descr;\n    const entries: string[] = [];\n    const props = [\n      'years',\n      'months',\n      'weeks',\n      'days',\n      'hours',\n      'minutes',\n      'seconds',\n      'milliseconds',\n      'microseconds',\n      'nanoseconds'\n    ] as const;\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (this[prop] !== 0) {\n        entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n      }\n    }\n    return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n  }\n};\n\ntype InspectFormatterOptions = { stylize: (str: string, styleType: string) => string };\nfunction defaultUtilInspectFormatter(this: any, depth: number, options: InspectFormatterOptions) {\n  return options.stylize(this._repr_, 'special');\n}\n\nexport function MakeIntrinsicClass(\n  Class: TemporalIntrinsicRegistrations[typeof name],\n  name: keyof TemporalIntrinsicRegistrations\n) {\n  Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  if (DEBUG) {\n    Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n      value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  const staticNames = Object.getOwnPropertyNames(Class);\n  for (let i = 0; i < staticNames.length; i++) {\n    const prop = staticNames[i];\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class, prop, desc);\n  }\n  const protoNames = Object.getOwnPropertyNames(Class.prototype);\n  for (let i = 0; i < protoNames.length; i++) {\n    const prop = protoNames[i];\n    // we know that `prop` is present, so the descriptor is never undefined\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop)!;\n    if (!desc.configurable || !desc.enumerable) continue;\n    desc.enumerable = false;\n    Object.defineProperty(Class.prototype, prop, desc);\n  }\n\n  DefineIntrinsic(name, Class);\n  DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\n\ntype IntrinsicDefinitionKeys =\n  | keyof TemporalIntrinsicRegistrations\n  | keyof TemporalIntrinsicPrototypeRegistrations\n  | keyof OtherIntrinsics;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof TemporalIntrinsicPrototypeRegistrations>(\n  name: KeyT,\n  value: TemporalIntrinsicPrototypeRegistrations[KeyT]\n): void;\nexport function DefineIntrinsic<KeyT extends keyof OtherIntrinsics>(name: KeyT, value: OtherIntrinsics[KeyT]): void;\nexport function DefineIntrinsic<KeyT>(name: KeyT, value: never): void;\nexport function DefineIntrinsic<KeyT extends IntrinsicDefinitionKeys>(name: KeyT, value: unknown): void {\n  const key: `%${IntrinsicDefinitionKeys}%` = `%${name}%`;\n  if (INTRINSICS[key] !== undefined) throw new Error(`intrinsic ${name} already exists`);\n  INTRINSICS[key] = value;\n}\nexport function GetIntrinsic<KeyT extends keyof typeof INTRINSICS>(intrinsic: KeyT): (typeof INTRINSICS)[KeyT] {\n  return INTRINSICS[intrinsic];\n}\n","import type JSBI from 'jsbi';\nimport type { Temporal } from '..';\n\n// Computes trunc(x / 10**p) and x % 10**p, returning { div, mod }, with\n// precision loss only once in the quotient, by string manipulation. If the\n// quotient and remainder are safe integers, then they are exact. x must be an\n// integer. p must be a non-negative integer. Both div and mod have the sign of\n// x.\nexport function TruncatingDivModByPowerOf10(xParam: number, p: number) {\n  let x = xParam;\n  if (x === 0) return { div: x, mod: x }; // preserves signed zero\n\n  const sign = Math.sign(x);\n  x = Math.abs(x);\n\n  const xDigits = Math.trunc(1 + Math.log10(x));\n  if (p >= xDigits) return { div: sign * 0, mod: sign * x };\n  if (p === 0) return { div: sign * x, mod: sign * 0 };\n\n  // would perform nearest rounding if x was not an integer:\n  const xStr = x.toPrecision(xDigits);\n  const div = sign * Number.parseInt(xStr.slice(0, xDigits - p), 10);\n  const mod = sign * Number.parseInt(xStr.slice(xDigits - p), 10);\n\n  return { div, mod };\n}\n\n// Computes x * 10**p + z with precision loss only at the end, by string\n// manipulation. If the result is a safe integer, then it is exact. x must be\n// an integer. p must be a non-negative integer. z must have the same sign as\n// x and be less than 10**p.\nexport function FMAPowerOf10(xParam: number, p: number, zParam: number) {\n  let x = xParam;\n  let z = zParam;\n  if (x === 0) return z;\n\n  const sign = Math.sign(x) || Math.sign(z);\n  x = Math.abs(x);\n  z = Math.abs(z);\n\n  const xStr = x.toPrecision(Math.trunc(1 + Math.log10(x)));\n\n  if (z === 0) return sign * Number.parseInt(xStr + '0'.repeat(p), 10);\n\n  const zStr = z.toPrecision(Math.trunc(1 + Math.log10(z)));\n\n  const resStr = xStr + zStr.padStart(p, '0');\n  return sign * Number.parseInt(resStr, 10);\n}\n\ntype UnsignedRoundingMode = 'half-even' | 'half-infinity' | 'half-zero' | 'infinity' | 'zero';\n\nexport function GetUnsignedRoundingMode(\n  mode: Temporal.RoundingMode,\n  sign: 'positive' | 'negative'\n): UnsignedRoundingMode {\n  const isNegative = sign === 'negative';\n  switch (mode) {\n    case 'ceil':\n      return isNegative ? 'zero' : 'infinity';\n    case 'floor':\n      return isNegative ? 'infinity' : 'zero';\n    case 'expand':\n      return 'infinity';\n    case 'trunc':\n      return 'zero';\n    case 'halfCeil':\n      return isNegative ? 'half-zero' : 'half-infinity';\n    case 'halfFloor':\n      return isNegative ? 'half-infinity' : 'half-zero';\n    case 'halfExpand':\n      return 'half-infinity';\n    case 'halfTrunc':\n      return 'half-zero';\n    case 'halfEven':\n      return 'half-even';\n  }\n}\n\n// Omits first step from spec algorithm so that it can be used both for\n// RoundNumberToIncrement and RoundTimeDurationToIncrement\nexport function ApplyUnsignedRoundingMode<T extends number | JSBI>(\n  r1: T,\n  r2: T,\n  cmp: -1 | 0 | 1,\n  evenCardinality: boolean,\n  unsignedRoundingMode: UnsignedRoundingMode\n) {\n  if (unsignedRoundingMode === 'zero') return r1;\n  if (unsignedRoundingMode === 'infinity') return r2;\n  if (cmp < 0) return r1;\n  if (cmp > 0) return r2;\n  if (unsignedRoundingMode === 'half-zero') return r1;\n  if (unsignedRoundingMode === 'half-infinity') return r2;\n  return evenCardinality ? r1 : r2;\n}\n","import JSBI from 'jsbi';\n\nimport { assert } from './assert';\nimport {\n  abs,\n  BILLION,\n  compare,\n  DAY_NANOS_JSBI,\n  divmod,\n  ensureJSBI,\n  HOUR_NANOS,\n  isEven,\n  MILLION,\n  MINUTE_NANOS_JSBI,\n  ONE,\n  TEN,\n  THOUSAND,\n  TWO,\n  ZERO\n} from './bigintmath';\nimport { ApplyUnsignedRoundingMode, GetUnsignedRoundingMode } from './math';\nimport type { Temporal } from '..';\n\nexport class TimeDuration {\n  static MAX = JSBI.BigInt('9007199254740991999999999');\n  static ZERO = new TimeDuration(ZERO);\n\n  totalNs: JSBI;\n  sec: number;\n  subsec: number;\n\n  constructor(totalNs: bigint | JSBI) {\n    assert(typeof totalNs !== 'number', 'big integer required');\n    this.totalNs = ensureJSBI(totalNs);\n    assert(JSBI.lessThanOrEqual(abs(this.totalNs), TimeDuration.MAX), 'integer too big');\n\n    this.sec = JSBI.toNumber(JSBI.divide(this.totalNs, BILLION));\n    this.subsec = JSBI.toNumber(JSBI.remainder(this.totalNs, BILLION));\n    assert(Number.isSafeInteger(this.sec), 'seconds too big');\n    assert(Math.abs(this.subsec) <= 999_999_999, 'subseconds too big');\n  }\n\n  static validateNew(totalNs: JSBI, operation: string) {\n    if (JSBI.greaterThan(abs(totalNs), TimeDuration.MAX)) {\n      throw new RangeError(`${operation} of duration time units cannot exceed ${TimeDuration.MAX} s`);\n    }\n    return new TimeDuration(totalNs);\n  }\n\n  static fromEpochNsDiff(epochNs1: JSBI | bigint, epochNs2: JSBI | bigint) {\n    const diff = JSBI.subtract(ensureJSBI(epochNs1), ensureJSBI(epochNs2));\n    // No extra validate step. Should instead fail assertion if too big\n    return new TimeDuration(diff);\n  }\n\n  static fromComponents(h: number, min: number, s: number, ms: number, µs: number, ns: number) {\n    const totalNs = JSBI.add(\n      JSBI.add(\n        JSBI.add(\n          JSBI.add(\n            JSBI.add(JSBI.BigInt(ns), JSBI.multiply(JSBI.BigInt(µs), THOUSAND)),\n            JSBI.multiply(JSBI.BigInt(ms), MILLION)\n          ),\n          JSBI.multiply(JSBI.BigInt(s), BILLION)\n        ),\n        JSBI.multiply(JSBI.BigInt(min), MINUTE_NANOS_JSBI)\n      ),\n      JSBI.multiply(JSBI.BigInt(h), HOUR_NANOS)\n    );\n    return TimeDuration.validateNew(totalNs, 'total');\n  }\n\n  abs() {\n    return new TimeDuration(abs(this.totalNs));\n  }\n\n  add(other: TimeDuration) {\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, other.totalNs), 'sum');\n  }\n\n  add24HourDays(days: number) {\n    assert(Number.isInteger(days), 'days must be an integer');\n    return TimeDuration.validateNew(JSBI.add(this.totalNs, JSBI.multiply(JSBI.BigInt(days), DAY_NANOS_JSBI)), 'sum');\n  }\n\n  addToEpochNs(epochNs: JSBI | bigint) {\n    return JSBI.add(ensureJSBI(epochNs), this.totalNs);\n  }\n\n  cmp(other: TimeDuration) {\n    return compare(this.totalNs, other.totalNs);\n  }\n\n  divmod(n: number) {\n    assert(n !== 0, 'division by zero');\n    const { quotient, remainder } = divmod(this.totalNs, JSBI.BigInt(n));\n    const q = JSBI.toNumber(quotient);\n    const r = new TimeDuration(remainder);\n    return { quotient: q, remainder: r };\n  }\n\n  fdiv(nParam: JSBI | bigint) {\n    const n = ensureJSBI(nParam);\n    assert(!JSBI.equal(n, ZERO), 'division by zero');\n    const nBigInt = JSBI.BigInt(n);\n    let { quotient, remainder } = divmod(this.totalNs, nBigInt);\n\n    // Perform long division to calculate the fractional part of the quotient\n    // remainder / n with more accuracy than 64-bit floating point division\n    const precision = 50;\n    const decimalDigits: number[] = [];\n    let digit;\n    const sign = (JSBI.lessThan(this.totalNs, ZERO) ? -1 : 1) * Math.sign(JSBI.toNumber(n));\n    while (!JSBI.equal(remainder, ZERO) && decimalDigits.length < precision) {\n      remainder = JSBI.multiply(remainder, TEN);\n      ({ quotient: digit, remainder } = divmod(remainder, nBigInt));\n      decimalDigits.push(Math.abs(JSBI.toNumber(digit)));\n    }\n    return sign * Number(abs(quotient).toString() + '.' + decimalDigits.join(''));\n  }\n\n  isZero() {\n    return JSBI.equal(this.totalNs, ZERO);\n  }\n\n  round(incrementParam: JSBI | bigint, mode: Temporal.RoundingMode) {\n    const increment = ensureJSBI(incrementParam);\n    if (JSBI.equal(increment, ONE)) return this;\n    const { quotient, remainder } = divmod(this.totalNs, increment);\n    const sign = JSBI.lessThan(this.totalNs, ZERO) ? 'negative' : 'positive';\n    const r1 = JSBI.multiply(abs(quotient), increment);\n    const r2 = JSBI.add(r1, increment);\n    const cmp = compare(abs(JSBI.multiply(remainder, TWO)), increment);\n    const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\n    const rounded = JSBI.equal(abs(this.totalNs), r1)\n      ? r1\n      : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(quotient), unsignedRoundingMode);\n    const result = sign === 'positive' ? rounded : JSBI.unaryMinus(rounded);\n    return TimeDuration.validateNew(result, 'rounding');\n  }\n\n  sign() {\n    return this.cmp(new TimeDuration(ZERO));\n  }\n\n  subtract(other: TimeDuration) {\n    return TimeDuration.validateNew(JSBI.subtract(this.totalNs, other.totalNs), 'difference');\n  }\n}\n","const offsetIdentifierNoCapture = /(?:[+-](?:[01][0-9]|2[0-3])(?::?[0-5][0-9])?)/;\nconst tzComponent = /[A-Za-z._][A-Za-z._0-9+-]*/;\nexport const timeZoneID = new RegExp(\n  `(?:${offsetIdentifierNoCapture.source}|(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*)`\n);\n\nconst yearpart = /(?:[+-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(\n  `(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`\n);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offsetWithParts = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /((?:[+-])(?:[01][0-9]|2[0-3])(?::?(?:[0-5][0-9])(?::?(?:[0-5][0-9])(?:[.,](?:\\d{1,9}))?)?)?)/;\nconst offsetpart = new RegExp(`([zZ])|${offset.source}?`);\nexport const offsetIdentifier = /([+-])([01][0-9]|2[0-3])(?::?([0-5][0-9])?)?/;\nexport const annotation = /\\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\\]/g;\n\nexport const zoneddatetime = new RegExp(\n  [\n    `^${datesplit.source}`,\n    `(?:(?:[tT]|\\\\s+)${timesplit.source}(?:${offsetpart.source})?)?`,\n    `(?:\\\\[!?(${timeZoneID.source})\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join('')\n);\n\nexport const time = new RegExp(\n  [\n    `^[tT]?${timesplit.source}`,\n    `(?:${offsetpart.source})?`,\n    `(?:\\\\[!?${timeZoneID.source}\\\\])?`,\n    `((?:${annotation.source})*)$`\n  ].join('')\n);\n\n// The short forms of YearMonth and MonthDay are only for the ISO calendar, but\n// annotations are still allowed, and will throw if the calendar annotation is\n// not ISO.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\n// UTC offsets are not allowed, because they are not allowed with any date-only\n// format; also, YYYY-MM-UU is ambiguous with YYYY-MM-DD\nexport const yearmonth = new RegExp(\n  `^(${yearpart.source})-?(${monthpart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\nexport const monthday = new RegExp(\n  `^(?:--)?(${monthpart.source})-?(${daypart.source})(?:\\\\[!?${timeZoneID.source}\\\\])?((?:${annotation.source})*)$`\n);\n\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\n\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n","import { DEBUG, ENABLE_ASSERTS } from './debug';\nimport JSBI from 'jsbi';\n\nimport type { Temporal } from '..';\nimport { assert, assertNotReached } from './assert';\nimport { abs, compare, DAY_NANOS_JSBI, divmod, ensureJSBI, isEven, MILLION, ONE, TWO, ZERO } from './bigintmath';\nimport type { CalendarImpl } from './calendar';\nimport type {\n  AnyTemporalLikeType,\n  UnitSmallerThanOrEqualTo,\n  InstantParams,\n  PlainMonthDayParams,\n  ZonedDateTimeParams,\n  PlainDateParams,\n  PlainTimeParams,\n  DurationParams,\n  PlainDateTimeParams,\n  PlainYearMonthParams,\n  BuiltinCalendarId,\n  Keys,\n  AnyTemporalKey,\n  FieldKey,\n  InternalDuration,\n  ISODateTime,\n  ISODate,\n  TimeRecord,\n  ISODateToFieldsType,\n  DateDuration,\n  CalendarFieldsRecord,\n  MonthDayFromFieldsObject,\n  Overflow,\n  Resolve,\n  AnySlottedType\n} from './internaltypes';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { ApplyUnsignedRoundingMode, FMAPowerOf10, GetUnsignedRoundingMode, TruncatingDivModByPowerOf10 } from './math';\nimport { TimeDuration } from './timeduration';\nimport {\n  CreateSlots,\n  GetSlot,\n  HasSlot,\n  SetSlot,\n  EPOCHNANOSECONDS,\n  ISO_DATE,\n  ISO_DATE_TIME,\n  TIME,\n  DATE_BRAND,\n  YEAR_MONTH_BRAND,\n  MONTH_DAY_BRAND,\n  TIME_ZONE,\n  CALENDAR,\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS\n} from './slots';\n\nconst DAY_MS = 86400_000;\nexport const DAY_NANOS = DAY_MS * 1e6;\nconst MINUTE_NANOS = 60e9;\n// Instant range is 100 million days (inclusive) before or after epoch.\nconst MS_MAX = DAY_MS * 1e8;\nconst NS_MAX = epochMsToNs(MS_MAX);\nconst NS_MIN = JSBI.unaryMinus(NS_MAX);\n// PlainDateTime range is 24 hours wider (exclusive) than the Instant range on\n// both ends, to allow for valid Instant=>PlainDateTime conversion for all\n// built-in time zones (whose offsets must have a magnitude less than 24 hours).\nconst DATETIME_NS_MIN = JSBI.add(JSBI.subtract(NS_MIN, DAY_NANOS_JSBI), ONE);\nconst DATETIME_NS_MAX = JSBI.subtract(JSBI.add(NS_MAX, DAY_NANOS_JSBI), ONE);\n// The pattern of leap years in the ISO 8601 calendar repeats every 400 years.\n// The constant below is the number of nanoseconds in 400 years. It is used to\n// avoid overflows when dealing with values at the edge legacy Date's range.\nconst MS_IN_400_YEAR_CYCLE = (400 * 365 + 97) * DAY_MS;\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_DST = Date.UTC(1847, 0, 1); // 1847-01-01T00:00:00Z\n\nconst BUILTIN_CALENDAR_IDS = [\n  'iso8601',\n  'hebrew',\n  'islamic',\n  'islamic-umalqura',\n  'islamic-tbla',\n  'islamic-civil',\n  'islamic-rgsa',\n  'islamicc',\n  'persian',\n  'ethiopic',\n  'ethioaa',\n  'ethiopic-amete-alem',\n  'coptic',\n  'chinese',\n  'dangi',\n  'roc',\n  'indian',\n  'buddhist',\n  'japanese',\n  'gregory'\n];\n\nconst ICU_LEGACY_TIME_ZONE_IDS = new Set([\n  'ACT',\n  'AET',\n  'AGT',\n  'ART',\n  'AST',\n  'BET',\n  'BST',\n  'CAT',\n  'CNT',\n  'CST',\n  'CTT',\n  'EAT',\n  'ECT',\n  'IET',\n  'IST',\n  'JST',\n  'MIT',\n  'NET',\n  'NST',\n  'PLT',\n  'PNT',\n  'PRT',\n  'PST',\n  'SST',\n  'VST'\n]);\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function */\n/**\n * uncheckedAssertNarrowedType forces TypeScript to change the type of the argument to the one given in\n * the type parameter. This should only be used to help TS understand when variables change types,\n * but TS can't or won't infer this automatically. They should be used sparingly, because\n * if used incorrectly can lead to difficult-to-diagnose problems.\n * */\nexport function uncheckedAssertNarrowedType<T = unknown>(\n  arg: unknown,\n  justification: string\n): asserts arg is T extends typeof arg ? T : never {}\n/* eslint-enable */\n\n/**\n * In debug builds, this function verifies that the given argument \"exists\" (is not\n * null or undefined). This function becomes a no-op in the final bundles distributed via NPM.\n * @param arg\n */\nexport function assertExists<A>(arg: A): asserts arg is NonNullable<A> {\n  if (ENABLE_ASSERTS) {\n    if (arg == null) {\n      throw new Error('Expected arg to be set.');\n    }\n  }\n}\n\n/** Similar to assertExists, but returns the argument. */\nfunction castExists<A>(arg: A): NonNullable<A> {\n  assertExists(arg);\n  return arg;\n}\n\n// For unknown values, this narrows the result to a Record. But for union types\n// like `Temporal.DurationLike | string`, it'll strip the primitive types while\n// leaving the object type(s) unchanged.\nexport function IsObject<T>(\n  value: T\n): value is Exclude<T, string | null | undefined | number | bigint | symbol | boolean>;\nexport function IsObject(value: unknown): value is Record<string | number | symbol, unknown> {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\n\nexport function ToNumber(value: unknown): number {\n  // ES 2022's es-abstract made minor changes to ToNumber, but polyfilling these\n  // changes adds zero benefit to Temporal and brings in a lot of extra code. So\n  // we'll leave ToNumber as-is.\n  // See https://github.com/ljharb/es-abstract/blob/main/2022/ToNumber.js\n  if (typeof value === 'bigint') throw new TypeError('Cannot convert BigInt to number');\n  return Number(value);\n}\n\nfunction IsIntegralNumber(argument: unknown) {\n  if (typeof argument !== 'number' || Number.isNaN(argument) || argument === Infinity || argument === -Infinity) {\n    return false;\n  }\n  const absValue = Math.abs(argument);\n  return Math.floor(absValue) === absValue;\n}\n\nexport function ToString(value: unknown): string {\n  if (typeof value === 'symbol') {\n    throw new TypeError('Cannot convert a Symbol value to a String');\n  }\n  return String(value);\n}\n\nexport function ToIntegerWithTruncation(value: unknown): number {\n  const number = ToNumber(value);\n  if (number === 0) return 0;\n  if (Number.isNaN(number) || number === Infinity || number === -Infinity) {\n    throw new RangeError('invalid number value');\n  }\n  const integer = Math.trunc(number);\n  if (integer === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return integer;\n}\n\nfunction ToPositiveIntegerWithTruncation(valueParam: unknown, property?: string): number {\n  const integer = ToIntegerWithTruncation(valueParam);\n  if (integer <= 0) {\n    if (property !== undefined) {\n      throw new RangeError(`property '${property}' cannot be a a number less than one`);\n    }\n    throw new RangeError('Cannot convert a number less than one to a positive integer');\n  }\n  return integer;\n}\n\nexport function ToIntegerIfIntegral(valueParam: unknown): number {\n  const number = ToNumber(valueParam);\n  if (Number.isNaN(number)) throw new RangeError('not a number');\n  if (number === Infinity || number === -Infinity) throw new RangeError('infinity is out of range');\n  if (!IsIntegralNumber(number)) throw new RangeError(`unsupported fractional value ${valueParam}`);\n  if (number === 0) return 0; // ℝ(value) in spec text; converts -0 to 0\n  return number;\n}\n\nfunction ToZeroPaddedDecimalString(n: number, minLength: number) {\n  if (DEBUG) {\n    if (!IsIntegralNumber(n) || n < 0) {\n      throw new RangeError('Assertion failed: `${n}` must be a non-negative integer');\n    }\n  }\n  const s = String(n);\n  return s.padStart(minLength, '0');\n}\n\n// This convenience function isn't in the spec, but is useful in the polyfill\n// for DRY and better error messages.\nexport function RequireString(value: unknown): string {\n  if (typeof value !== 'string') {\n    // Use String() to ensure that Symbols won't throw\n    throw new TypeError(`expected a string, not ${String(value)}`);\n  }\n  return value;\n}\n\nfunction ToSyntacticallyValidMonthCode(valueParam: unknown) {\n  const value = RequireString(ToPrimitive(valueParam, String));\n  if (\n    value.length < 3 ||\n    value.length > 4 ||\n    value[0] !== 'M' ||\n    '0123456789'.indexOf(value[1]) === -1 ||\n    '0123456789'.indexOf(value[2]) === -1 ||\n    (value[1] + value[2] === '00' && value[3] !== 'L') ||\n    (value[3] !== 'L' && value[3] !== undefined)\n  ) {\n    throw new RangeError(`bad month code ${value}; must match M01-M99 or M00L-M99L`);\n  }\n  return value;\n}\n\nfunction ToOffsetString(valueParam: unknown) {\n  const value = RequireString(ToPrimitive(valueParam, String));\n  ParseDateTimeUTCOffset(value);\n  return value;\n}\n\n// Limited implementation of ToPrimitive that only handles the string case,\n// because that's all that's used in this polyfill.\nfunction ToPrimitive(value: unknown, preferredType: typeof String): string | number {\n  assertExists(preferredType === String);\n  if (IsObject(value)) {\n    const result = value?.toString();\n    if (typeof result === 'string' || typeof result === 'number') return result;\n    throw new TypeError('Cannot convert object to primitive value');\n  }\n  return value;\n}\n\nconst CALENDAR_FIELD_KEYS: readonly FieldKey[] = [\n  'era',\n  'eraYear',\n  'year',\n  'month',\n  'monthCode',\n  'day',\n  'hour',\n  'minute',\n  'second',\n  'millisecond',\n  'microsecond',\n  'nanosecond',\n  'offset',\n  'timeZone'\n] as const;\n\ntype BuiltinCastFunction = (v: unknown) => string | number;\nconst BUILTIN_CASTS: Partial<Record<FieldKey, BuiltinCastFunction>> = {\n  era: ToString,\n  eraYear: ToIntegerWithTruncation,\n  year: ToIntegerWithTruncation,\n  month: ToPositiveIntegerWithTruncation,\n  monthCode: ToSyntacticallyValidMonthCode,\n  day: ToPositiveIntegerWithTruncation,\n  hour: ToIntegerWithTruncation,\n  minute: ToIntegerWithTruncation,\n  second: ToIntegerWithTruncation,\n  millisecond: ToIntegerWithTruncation,\n  microsecond: ToIntegerWithTruncation,\n  nanosecond: ToIntegerWithTruncation,\n  offset: ToOffsetString,\n  timeZone: ToTemporalTimeZoneIdentifier\n};\n\nconst BUILTIN_DEFAULTS: Partial<Record<FieldKey, number>> = {\n  hour: 0,\n  minute: 0,\n  second: 0,\n  millisecond: 0,\n  microsecond: 0,\n  nanosecond: 0\n};\n\n// each item is [plural, singular, category, (length in ns)]\nconst TEMPORAL_UNITS = [\n  ['years', 'year', 'date'],\n  ['months', 'month', 'date'],\n  ['weeks', 'week', 'date'],\n  ['days', 'day', 'date'],\n  ['hours', 'hour', 'time'],\n  ['minutes', 'minute', 'time'],\n  ['seconds', 'second', 'time'],\n  ['milliseconds', 'millisecond', 'time'],\n  ['microseconds', 'microsecond', 'time'],\n  ['nanoseconds', 'nanosecond', 'time']\n] as const;\nconst SINGULAR_FOR = Object.fromEntries(TEMPORAL_UNITS.map((e) => [e[0], e[1]] as const));\nconst PLURAL_FOR = Object.fromEntries(TEMPORAL_UNITS.map(([p, s]) => [s, p] as const));\nconst UNITS_DESCENDING = TEMPORAL_UNITS.map(([, s]) => s);\ntype TimeUnitOrDay = Temporal.TimeUnit | 'day';\nconst NS_PER_TIME_UNIT = {\n  day: DAY_NANOS,\n  hour: 3600e9,\n  minute: 60e9,\n  second: 1e9,\n  millisecond: 1e6,\n  microsecond: 1e3,\n  nanosecond: 1\n};\n\nconst DURATION_FIELDS = [\n  'days',\n  'hours',\n  'microseconds',\n  'milliseconds',\n  'minutes',\n  'months',\n  'nanoseconds',\n  'seconds',\n  'weeks',\n  'years'\n] as const;\n\nimport * as PARSE from './regex';\n\n// Save the original Intl.DateTimeFormat, it will likely be overwritten with the\n// one from this polyfill. Caching the formatter below may be reentrant, so we\n// need to use the original one\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\nconst IntlDateTimeFormatEnUsCache = new Map<string, Intl.DateTimeFormat>();\n\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier: string) {\n  const lowercaseIdentifier = ASCIILowercase(timeZoneIdentifier);\n  let instance = IntlDateTimeFormatEnUsCache.get(lowercaseIdentifier);\n  if (instance === undefined) {\n    instance = new OriginalIntlDateTimeFormat('en-us', {\n      timeZone: lowercaseIdentifier,\n      hour12: false,\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n    IntlDateTimeFormatEnUsCache.set(lowercaseIdentifier, instance);\n  }\n  return instance;\n}\n\nexport function ToObject<T>(value: T): T extends Record<string, unknown> ? T : Record<PropertyKey, unknown> {\n  if (typeof value === 'undefined' || value === null) {\n    throw new TypeError(`Expected object not ${value}`);\n  }\n  return Object(value);\n}\n\n// Adapted from https://github.com/ljharb/es-abstract/blob/main/2022/CopyDataProperties.js\n// but simplified (e.g. removed assertions) for this polyfill to reduce bundle size.\nexport function CopyDataProperties<K extends PropertyKey, T extends Record<K, unknown>>(\n  target: T,\n  source: T | undefined,\n  excludedKeys: K[],\n  excludedValues?: unknown[]\n) {\n  if (typeof source === 'undefined' || source === null) return;\n\n  const keys = Reflect.ownKeys(source) as (keyof T)[];\n  for (let index = 0; index < keys.length; index++) {\n    const nextKey = keys[index];\n    if (excludedKeys.some((e) => Object.is(e, nextKey))) continue;\n    if (Object.prototype.propertyIsEnumerable.call(source, nextKey)) {\n      const propValue = source[nextKey];\n      if (excludedValues && excludedValues.some((e) => Object.is(e, propValue))) continue;\n\n      target[nextKey] = propValue;\n    }\n  }\n}\n\nexport function IsTemporalInstant(item: unknown): item is Temporal.Instant {\n  return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\n\nexport function IsTemporalDuration(item: unknown): item is Temporal.Duration {\n  return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item: unknown): item is Temporal.PlainDate {\n  return HasSlot(item, DATE_BRAND);\n}\n\nexport function IsTemporalTime(item: unknown): item is Temporal.PlainTime {\n  return HasSlot(item, TIME);\n}\n\nexport function IsTemporalDateTime(item: unknown): item is Temporal.PlainDateTime {\n  return HasSlot(item, ISO_DATE_TIME);\n}\n\nexport function IsTemporalYearMonth(item: unknown): item is Temporal.PlainYearMonth {\n  return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item: unknown): item is Temporal.PlainMonthDay {\n  return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item: unknown): item is Temporal.ZonedDateTime {\n  return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\n\nexport function CheckReceiver<T extends AnySlottedType>(\n  item: unknown,\n  test: (item: unknown) => item is T\n): asserts item is T {\n  if (!test(item)) throw new TypeError('invalid receiver: method called with the wrong type of this-object');\n}\n\nexport function RejectTemporalLikeObject(item: AnyTemporalLikeType) {\n  if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n    throw new TypeError('with() does not support a calendar or timeZone property');\n  }\n  if (IsTemporalTime(item)) {\n    throw new TypeError('with() does not accept Temporal.PlainTime, use withPlainTime() instead');\n  }\n  if ((item as { calendar: unknown }).calendar !== undefined) {\n    throw new TypeError('with() does not support a calendar property');\n  }\n  if ((item as { timeZone: unknown }).timeZone !== undefined) {\n    throw new TypeError('with() does not support a timeZone property');\n  }\n}\n\nfunction FormatCalendarAnnotation(id: BuiltinCalendarId, showCalendar: Temporal.ShowCalendarOption['calendarName']) {\n  if (showCalendar === 'never') return '';\n  if (showCalendar === 'auto' && id === 'iso8601') return '';\n  const flag = showCalendar === 'critical' ? '!' : '';\n  return `[${flag}u-ca=${id}]`;\n}\n\n// Not a separate abstract operation in the spec, because it only occurs in one\n// place: ParseISODateTime. In the code it's more convenient to split up\n// ParseISODateTime for the YYYY-MM, MM-DD, and THH:MM:SS parse goals, so it's\n// repeated four times.\nfunction processAnnotations(annotations: string) {\n  let calendar;\n  let calendarWasCritical = false;\n  // Avoid the user code minefield of matchAll.\n  let match;\n  PARSE.annotation.lastIndex = 0;\n  while ((match = PARSE.annotation.exec(annotations))) {\n    const { 1: critical, 2: key, 3: value } = match;\n    if (key === 'u-ca') {\n      if (calendar === undefined) {\n        calendar = value;\n        calendarWasCritical = critical === '!';\n      } else if (critical === '!' || calendarWasCritical) {\n        throw new RangeError(`Invalid annotations in ${annotations}: more than one u-ca present with critical flag`);\n      }\n    } else if (critical === '!') {\n      throw new RangeError(`Unrecognized annotation: !${key}=${value}`);\n    }\n  }\n  return calendar;\n}\n\nfunction ParseISODateTime(isoString: string) {\n  // ZDT is the superset of fields for every other Temporal type\n  const match = PARSE.zoneddatetime.exec(isoString);\n  if (!match) throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n  const calendar = processAnnotations(match[16]);\n  let yearString = match[1];\n  if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n  const year = +yearString;\n  const month = +(match[2] ?? match[4] ?? 1);\n  const day = +(match[3] ?? match[5] ?? 1);\n  const hasTime = match[6] !== undefined;\n  const hour = +(match[6] ?? 0);\n  const minute = +(match[7] ?? match[10] ?? 0);\n  let second = +(match[8] ?? match[11] ?? 0);\n  if (second === 60) second = 59;\n  const fraction = (match[9] ?? match[12] ?? '') + '000000000';\n  const millisecond = +fraction.slice(0, 3);\n  const microsecond = +fraction.slice(3, 6);\n  const nanosecond = +fraction.slice(6, 9);\n  let offset;\n  let z = false;\n  if (match[13]) {\n    offset = undefined;\n    z = true;\n  } else if (match[14]) {\n    offset = match[14];\n  }\n  const tzAnnotation = match[15];\n  RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n  return {\n    year,\n    month,\n    day,\n    time: hasTime ? { hour, minute, second, millisecond, microsecond, nanosecond } : ('start-of-day' as const),\n    tzAnnotation,\n    offset,\n    z,\n    calendar\n  };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.z && !result.offset) throw new RangeError('Temporal.Instant requires a time zone offset');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString: string) {\n  const result = ParseISODateTime(isoString);\n  if (!result.tzAnnotation) throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n  return result;\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString: string) {\n  return ParseISODateTime(isoString);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString: string) {\n  const match = PARSE.time.exec(isoString);\n  let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n  if (match) {\n    calendar = processAnnotations(match[10]);\n    hour = +(match[1] ?? 0);\n    minute = +(match[2] ?? match[5] ?? 0);\n    second = +(match[3] ?? match[6] ?? 0);\n    if (second === 60) second = 59;\n    const fraction = (match[4] ?? match[7] ?? '') + '000000000';\n    millisecond = +fraction.slice(0, 3);\n    microsecond = +fraction.slice(3, 6);\n    nanosecond = +fraction.slice(6, 9);\n    if (match[8]) throw new RangeError('Z designator not supported for PlainTime');\n  } else {\n    let time, z;\n    ({ time, z, calendar } = ParseISODateTime(isoString));\n    if (time === 'start-of-day') throw new RangeError(`time is missing in string: ${isoString}`);\n    if (z) throw new RangeError('Z designator not supported for PlainTime');\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = time);\n  }\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  // if it's a date-time string, OK\n  if (/[tT ][0-9][0-9]/.test(isoString)) {\n    return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n  }\n  try {\n    const { month, day } = ParseTemporalMonthDayString(isoString);\n    RejectISODate(1972, month, day);\n  } catch {\n    try {\n      const { year, month } = ParseTemporalYearMonthString(isoString);\n      RejectISODate(year, month, 1);\n    } catch {\n      return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n  }\n  throw new RangeError(`invalid RFC 9557 time-only string ${isoString}; may need a T prefix`);\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString: string) {\n  const match = PARSE.yearmonth.exec(isoString);\n  let year, month, calendar, referenceISODay;\n  if (match) {\n    calendar = processAnnotations(match[3]);\n    let yearString = match[1];\n    if (yearString === '-000000') throw new RangeError(`invalid RFC 9557 string: ${isoString}`);\n    year = +yearString;\n    month = +match[2];\n    referenceISODay = 1;\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('YYYY-MM format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainYearMonth');\n  }\n  return { year, month, calendar, referenceISODay };\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString: string) {\n  const match = PARSE.monthday.exec(isoString);\n  let month, day, calendar, referenceISOYear;\n  if (match) {\n    calendar = processAnnotations(match[3]);\n    month = +match[1];\n    day = +match[2];\n    if (calendar !== undefined && calendar !== 'iso8601') {\n      throw new RangeError('MM-DD format is only valid with iso8601 calendar');\n    }\n  } else {\n    let z;\n    ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n    if (z) throw new RangeError('Z designator not supported for PlainMonthDay');\n  }\n  return { month, day, calendar, referenceISOYear };\n}\n\nconst TIMEZONE_IDENTIFIER = new RegExp(`^${PARSE.timeZoneID.source}$`, 'i');\nconst OFFSET_IDENTIFIER = new RegExp(`^${PARSE.offsetIdentifier.source}$`);\n\nfunction throwBadTimeZoneStringError(timeZoneString: string): never {\n  // Offset identifiers only support minute precision, but offsets in ISO\n  // strings support nanosecond precision. If the identifier is invalid but\n  // it's a valid ISO offset, then it has sub-minute precision. Show a clearer\n  // error message in that case.\n  const msg = OFFSET.test(timeZoneString) ? 'Seconds not allowed in offset time zone' : 'Invalid time zone';\n  throw new RangeError(`${msg}: ${timeZoneString}`);\n}\n\nexport function ParseTimeZoneIdentifier(\n  identifier: string\n): { tzName: string; offsetMinutes?: undefined } | { tzName?: undefined; offsetMinutes: number } {\n  if (!TIMEZONE_IDENTIFIER.test(identifier)) {\n    throwBadTimeZoneStringError(identifier);\n  }\n  if (OFFSET_IDENTIFIER.test(identifier)) {\n    const offsetNanoseconds = ParseDateTimeUTCOffset(identifier);\n    // The regex limits the input to minutes precision, so we know that the\n    // division below will result in an integer.\n    return { offsetMinutes: offsetNanoseconds / 60e9 };\n  }\n  return { tzName: identifier };\n}\n\n// This operation doesn't exist in the spec, but in the polyfill it's split from\n// ParseTemporalTimeZoneString so that parsing can be tested separately from the\n// logic of converting parsed values into a named or offset identifier.\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneStringRaw(timeZoneString: string): {\n  tzAnnotation: string;\n  offset: string | undefined;\n  z: boolean;\n} {\n  if (TIMEZONE_IDENTIFIER.test(timeZoneString)) {\n    return { tzAnnotation: timeZoneString, offset: undefined, z: false };\n  }\n  try {\n    // Try parsing ISO string instead\n    const { tzAnnotation, offset, z } = ParseISODateTime(timeZoneString);\n    if (z || tzAnnotation || offset) {\n      return { tzAnnotation, offset, z };\n    }\n  } catch {\n    // fall through\n  }\n  throwBadTimeZoneStringError(timeZoneString);\n}\n\nfunction ParseTemporalTimeZoneString(stringIdent: string): ReturnType<typeof ParseTimeZoneIdentifier> {\n  const { tzAnnotation, offset, z } = ParseTemporalTimeZoneStringRaw(stringIdent);\n  if (tzAnnotation) return ParseTimeZoneIdentifier(tzAnnotation);\n  if (z) return ParseTimeZoneIdentifier('UTC');\n  if (offset) return ParseTimeZoneIdentifier(offset);\n  /* c8 ignore next */ assertNotReached();\n}\n\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationStringRaw(isoString: string) {\n  const match = PARSE.duration.exec(isoString);\n  if (!match) throw new RangeError(`invalid duration: ${isoString}`);\n  if (match.every((part, i) => i < 2 || part === undefined)) {\n    throw new RangeError(`invalid duration: ${isoString}`);\n  }\n  const sign = match[1] === '-' ? -1 : 1;\n  const years = match[2] === undefined ? 0 : ToIntegerWithTruncation(match[2]) * sign;\n  const months = match[3] === undefined ? 0 : ToIntegerWithTruncation(match[3]) * sign;\n  const weeks = match[4] === undefined ? 0 : ToIntegerWithTruncation(match[4]) * sign;\n  const days = match[5] === undefined ? 0 : ToIntegerWithTruncation(match[5]) * sign;\n  const hours = match[6] === undefined ? 0 : ToIntegerWithTruncation(match[6]) * sign;\n  const fHours = match[7];\n  const minutesStr = match[8];\n  const fMinutes = match[9];\n  const secondsStr = match[10];\n  const fSeconds = match[11];\n  let minutes = 0;\n  let seconds = 0;\n  // fractional hours, minutes, or seconds, expressed in whole nanoseconds:\n  let excessNanoseconds = 0;\n\n  if (fHours !== undefined) {\n    if (minutesStr ?? fMinutes ?? secondsStr ?? fSeconds ?? false) {\n      throw new RangeError('only the smallest unit can be fractional');\n    }\n    excessNanoseconds = ToIntegerWithTruncation((fHours + '000000000').slice(0, 9)) * 3600 * sign;\n  } else {\n    minutes = minutesStr === undefined ? 0 : ToIntegerWithTruncation(minutesStr) * sign;\n    if (fMinutes !== undefined) {\n      if (secondsStr ?? fSeconds ?? false) {\n        throw new RangeError('only the smallest unit can be fractional');\n      }\n      excessNanoseconds = ToIntegerWithTruncation((fMinutes + '000000000').slice(0, 9)) * 60 * sign;\n    } else {\n      seconds = secondsStr === undefined ? 0 : ToIntegerWithTruncation(secondsStr) * sign;\n      if (fSeconds !== undefined) {\n        excessNanoseconds = ToIntegerWithTruncation((fSeconds + '000000000').slice(0, 9)) * sign;\n      }\n    }\n  }\n\n  const nanoseconds = excessNanoseconds % 1000;\n  const microseconds = Math.trunc(excessNanoseconds / 1000) % 1000;\n  const milliseconds = Math.trunc(excessNanoseconds / 1e6) % 1000;\n  seconds += Math.trunc(excessNanoseconds / 1e9) % 60;\n  minutes += Math.trunc(excessNanoseconds / 60e9);\n\n  RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n\nfunction ParseTemporalDurationString(isoString: string) {\n  const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n    ParseTemporalDurationStringRaw(isoString);\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    years,\n    months,\n    weeks,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds\n  );\n}\n\nexport function RegulateISODate(yearParam: number, monthParam: number, dayParam: number, overflow: Overflow) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  switch (overflow) {\n    case 'reject':\n      RejectISODate(year, month, day);\n      break;\n    case 'constrain':\n      ({ year, month, day } = ConstrainISODate(year, month, day));\n      break;\n  }\n  return { year, month, day };\n}\n\nexport function RegulateTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number,\n  overflow: Overflow\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n\n  switch (overflow) {\n    case 'reject':\n      RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n      break;\n    case 'constrain':\n      hour = ConstrainToRange(hour, 0, 23);\n      minute = ConstrainToRange(minute, 0, 59);\n      second = ConstrainToRange(second, 0, 59);\n      millisecond = ConstrainToRange(millisecond, 0, 999);\n      microsecond = ConstrainToRange(microsecond, 0, 999);\n      nanosecond = ConstrainToRange(nanosecond, 0, 999);\n      break;\n  }\n  return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function ToTemporalPartialDurationRecord(temporalDurationLike: Temporal.DurationLike | string) {\n  if (!IsObject(temporalDurationLike)) {\n    throw new TypeError('invalid duration-like');\n  }\n  const result: Record<(typeof DURATION_FIELDS)[number], number | undefined> = {\n    years: undefined,\n    months: undefined,\n    weeks: undefined,\n    days: undefined,\n    hours: undefined,\n    minutes: undefined,\n    seconds: undefined,\n    milliseconds: undefined,\n    microseconds: undefined,\n    nanoseconds: undefined\n  };\n  let any = false;\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\n    const property = DURATION_FIELDS[index];\n    const value = temporalDurationLike[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = ToIntegerIfIntegral(value);\n    }\n  }\n  if (!any) {\n    throw new TypeError('invalid duration-like');\n  }\n  return result;\n}\n\nexport function AdjustDateDurationRecord(\n  { years, months, weeks, days }: DateDuration,\n  newDays: number,\n  newWeeks?: number,\n  newMonths?: number\n) {\n  return {\n    years,\n    months: newMonths ?? months,\n    weeks: newWeeks ?? weeks,\n    days: newDays ?? days\n  };\n}\n\nexport function ZeroDateDuration() {\n  return { years: 0, months: 0, weeks: 0, days: 0 };\n}\n\nexport function CombineISODateAndTimeRecord(isoDate: ISODate, time: TimeRecord) {\n  return { isoDate, time };\n}\n\nexport function MidnightTimeRecord() {\n  return { deltaDays: 0, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n}\n\nexport function NoonTimeRecord() {\n  return { deltaDays: 0, hour: 12, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n}\n\nexport function GetTemporalOverflowOption(options: Temporal.AssignmentOptions) {\n  return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\n\nexport function GetTemporalDisambiguationOption(options: Temporal.ToInstantOptions) {\n  return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\n\nexport function GetRoundingModeOption(\n  options: { roundingMode?: Temporal.RoundingMode },\n  fallback: Temporal.RoundingMode\n) {\n  return GetOption(\n    options,\n    'roundingMode',\n    ['ceil', 'floor', 'expand', 'trunc', 'halfCeil', 'halfFloor', 'halfExpand', 'halfTrunc', 'halfEven'],\n    fallback\n  );\n}\n\nfunction NegateRoundingMode(roundingMode: Temporal.RoundingMode) {\n  switch (roundingMode) {\n    case 'ceil':\n      return 'floor';\n    case 'floor':\n      return 'ceil';\n    case 'halfCeil':\n      return 'halfFloor';\n    case 'halfFloor':\n      return 'halfCeil';\n    default:\n      return roundingMode;\n  }\n}\n\nexport function GetTemporalOffsetOption(\n  options: Temporal.OffsetDisambiguationOptions,\n  fallback: Required<Temporal.OffsetDisambiguationOptions>['offset']\n) {\n  return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\n\nexport function GetTemporalShowCalendarNameOption(options: Temporal.ShowCalendarOption) {\n  return GetOption(options, 'calendarName', ['auto', 'always', 'never', 'critical'], 'auto');\n}\n\nexport function GetTemporalShowTimeZoneNameOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'timeZoneName', ['auto', 'never', 'critical'], 'auto');\n}\n\nexport function GetTemporalShowOffsetOption(options: Temporal.ZonedDateTimeToStringOptions) {\n  return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\n\nexport function GetDirectionOption(options: { direction?: 'next' | 'previous' }) {\n  return GetOption(options, 'direction', ['next', 'previous'], REQUIRED);\n}\n\nexport function GetTemporalRoundingIncrementOption(options: { roundingIncrement?: number }) {\n  let increment = options.roundingIncrement;\n  if (increment === undefined) return 1;\n  const integerIncrement = ToIntegerWithTruncation(increment);\n  if (integerIncrement < 1 || integerIncrement > 1e9) {\n    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${increment}`);\n  }\n  return integerIncrement;\n}\nexport function ValidateTemporalRoundingIncrement(increment: number, dividend: number, inclusive: boolean) {\n  const maximum = inclusive ? dividend : dividend - 1;\n  if (increment > maximum) {\n    throw new RangeError(`roundingIncrement must be at least 1 and less than ${maximum}, not ${increment}`);\n  }\n  if (dividend % increment !== 0) {\n    throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n  }\n}\n\nexport function GetTemporalFractionalSecondDigitsOption(\n  normalizedOptions: Temporal.ToStringPrecisionOptions\n): Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] {\n  const digitsValue = normalizedOptions.fractionalSecondDigits;\n  if (digitsValue === undefined) return 'auto';\n  if (typeof digitsValue !== 'number') {\n    if (ToString(digitsValue) !== 'auto') {\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n    }\n    return 'auto';\n  }\n  const digitCount = Math.floor(digitsValue);\n  if (!Number.isFinite(digitCount) || digitCount < 0 || digitCount > 9) {\n    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digitsValue}`);\n  }\n  return digitCount as Exclude<Temporal.ToStringPrecisionOptions['fractionalSecondDigits'], 'auto'>;\n}\n\ninterface SecondsStringPrecisionRecord {\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits'] | 'minute';\n  unit: UnitSmallerThanOrEqualTo<'minute'>;\n  increment: number;\n}\n\nexport function ToSecondsStringPrecisionRecord(\n  smallestUnit: Temporal.ToStringPrecisionOptions['smallestUnit'],\n  precision: Temporal.ToStringPrecisionOptions['fractionalSecondDigits']\n): SecondsStringPrecisionRecord {\n  switch (smallestUnit) {\n    case 'minute':\n      return { precision: 'minute', unit: 'minute', increment: 1 };\n    case 'second':\n      return { precision: 0, unit: 'second', increment: 1 };\n    case 'millisecond':\n      return { precision: 3, unit: 'millisecond', increment: 1 };\n    case 'microsecond':\n      return { precision: 6, unit: 'microsecond', increment: 1 };\n    case 'nanosecond':\n      return { precision: 9, unit: 'nanosecond', increment: 1 };\n    default: // fall through if option not given\n  }\n  switch (precision) {\n    case 'auto':\n      return { precision, unit: 'nanosecond', increment: 1 };\n    case 0:\n      return { precision, unit: 'second', increment: 1 };\n    case 1:\n    case 2:\n    case 3:\n      return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n    case 4:\n    case 5:\n    case 6:\n      return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n    case 7:\n    case 8:\n    case 9:\n      return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n    default:\n      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${precision}`);\n  }\n}\n\nexport const REQUIRED = Symbol('~required~');\n\ninterface TemporalUnitOptionsBag {\n  smallestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n  largestUnit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit | 'auto';\n  unit?: Temporal.PluralUnit<Temporal.DateTimeUnit> | Temporal.DateTimeUnit;\n}\ntype UnitTypeMapping = {\n  date: Temporal.DateUnit;\n  time: Temporal.TimeUnit;\n  datetime: Temporal.DateTimeUnit;\n};\n// This type specifies the allowed defaults for each unit key type.\ntype AllowedGetTemporalUnitDefaultValues = {\n  smallestUnit: undefined;\n  largestUnit: 'auto' | undefined;\n  unit: undefined;\n};\n\nexport function GetTemporalUnitValuedOption<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  R extends Exclude<D, typeof REQUIRED> | UnitTypeMapping[T]\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D): R;\nexport function GetTemporalUnitValuedOption<\n  U extends keyof TemporalUnitOptionsBag,\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | AllowedGetTemporalUnitDefaultValues[U],\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(options: TemporalUnitOptionsBag, key: U, unitGroup: T, requiredOrDefault: D, extraValues: ReadonlyArray<E>): R;\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnitValuedOption<\n  T extends keyof UnitTypeMapping,\n  D extends typeof REQUIRED | UnitTypeMapping[T] | 'auto' | undefined,\n  E extends 'auto' | Temporal.DateTimeUnit,\n  R extends UnitTypeMapping[T] | Exclude<D, typeof REQUIRED> | E\n>(\n  options: TemporalUnitOptionsBag,\n  key: keyof typeof options,\n  unitGroup: T,\n  requiredOrDefault: D,\n  extraValues: ReadonlyArray<E> | never[] = []\n): R {\n  let allowedSingular: Array<Temporal.DateTimeUnit | 'auto'> = [];\n  for (let index = 0; index < TEMPORAL_UNITS.length; index++) {\n    const unitInfo = TEMPORAL_UNITS[index];\n    const singular = unitInfo[1];\n    const category = unitInfo[2];\n    if (unitGroup === 'datetime' || unitGroup === category) {\n      allowedSingular.push(singular);\n    }\n  }\n  allowedSingular = allowedSingular.concat(extraValues);\n  let defaultVal: typeof REQUIRED | Temporal.DateTimeUnit | 'auto' | undefined = requiredOrDefault;\n  if (defaultVal === REQUIRED) {\n    defaultVal = undefined;\n  } else if (defaultVal !== undefined) {\n    allowedSingular.push(defaultVal);\n  }\n  let allowedValues: Array<Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | 'auto'> = [];\n  allowedValues = allowedValues.concat(allowedSingular);\n  for (let index = 0; index < allowedSingular.length; index++) {\n    const singular = allowedSingular[index];\n    const plural = PLURAL_FOR[singular];\n    if (plural !== undefined) allowedValues.push(plural);\n  }\n  let retval = GetOption(options, key, allowedValues, defaultVal);\n  if (retval === undefined && requiredOrDefault === REQUIRED) {\n    throw new RangeError(`${key} is required`);\n  }\n  // Coerce any plural units into their singular form\n  return (retval && retval in SINGULAR_FOR ? SINGULAR_FOR[retval] : retval) as R;\n}\n\nexport function GetTemporalRelativeToOption(options: {\n  relativeTo?:\n    | Temporal.ZonedDateTime\n    | Temporal.PlainDateTime\n    | Temporal.ZonedDateTimeLike\n    | Temporal.PlainDateTimeLike\n    | string\n    | undefined;\n}):\n  | { zonedRelativeTo?: Temporal.ZonedDateTime; plainRelativeTo?: never }\n  | { plainRelativeTo?: Temporal.PlainDate; zonedRelativeTo?: never } {\n  const relativeTo = options.relativeTo;\n  if (relativeTo === undefined) return {};\n\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let matchMinutes = false;\n  let isoDate, time, calendar, timeZone, offset;\n  if (IsObject(relativeTo)) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n      return { zonedRelativeTo: relativeTo };\n    }\n    if (IsTemporalDate(relativeTo)) return { plainRelativeTo: relativeTo };\n    if (IsTemporalDateTime(relativeTo)) {\n      return {\n        plainRelativeTo: CreateTemporalDate(GetSlot(relativeTo, ISO_DATE_TIME).isoDate, GetSlot(relativeTo, CALENDAR))\n      };\n    }\n    calendar = GetTemporalCalendarIdentifierWithISODefault(relativeTo);\n    const fields = PrepareCalendarFields(\n      calendar,\n      relativeTo,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\n      []\n    );\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, 'constrain'));\n    ({ offset, timeZone } = fields);\n    if (offset === undefined) offsetBehaviour = 'wall';\n  } else {\n    let tzAnnotation, z, year, month, day;\n    ({ year, month, day, time, calendar, tzAnnotation, offset, z } = ParseISODateTime(RequireString(relativeTo)));\n    if (tzAnnotation) {\n      timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\n      if (z) {\n        offsetBehaviour = 'exact';\n      } else if (!offset) {\n        offsetBehaviour = 'wall';\n      }\n      matchMinutes = true;\n    } else if (z) {\n      throw new RangeError(\n        'Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone'\n      );\n    }\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    isoDate = { year, month, day };\n  }\n  if (timeZone === undefined) {\n    return { plainRelativeTo: CreateTemporalDate(isoDate, calendar) };\n  }\n  const offsetNs = offsetBehaviour === 'option' ? ParseDateTimeUTCOffset(castExists(offset)) : 0;\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    isoDate,\n    time,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    'compatible',\n    'reject',\n    matchMinutes\n  );\n  return { zonedRelativeTo: CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar) };\n}\n\nexport function DefaultTemporalLargestUnit(duration: Temporal.Duration) {\n  if (GetSlot(duration, YEARS) !== 0) return 'year';\n  if (GetSlot(duration, MONTHS) !== 0) return 'month';\n  if (GetSlot(duration, WEEKS) !== 0) return 'week';\n  if (GetSlot(duration, DAYS) !== 0) return 'day';\n  if (GetSlot(duration, HOURS) !== 0) return 'hour';\n  if (GetSlot(duration, MINUTES) !== 0) return 'minute';\n  if (GetSlot(duration, SECONDS) !== 0) return 'second';\n  if (GetSlot(duration, MILLISECONDS) !== 0) return 'millisecond';\n  if (GetSlot(duration, MICROSECONDS) !== 0) return 'microsecond';\n  return 'nanosecond';\n}\n\nexport function LargerOfTwoTemporalUnits<T1 extends Temporal.DateTimeUnit, T2 extends Temporal.DateTimeUnit>(\n  unit1: T1,\n  unit2: T2\n) {\n  const i1 = UNITS_DESCENDING.indexOf(unit1);\n  const i2 = UNITS_DESCENDING.indexOf(unit2);\n  if (i1 > i2) {\n    return unit2;\n  }\n  return unit1;\n}\n\nexport function IsCalendarUnit(unit: Temporal.DateTimeUnit): unit is Exclude<Temporal.DateUnit, 'day'> {\n  return unit === 'year' || unit === 'month' || unit === 'week';\n}\n\nexport function TemporalUnitCategory(unit: Temporal.DateTimeUnit) {\n  if (IsCalendarUnit(unit) || unit === 'day') return 'date';\n  return 'time';\n}\n\nfunction calendarImplForID(calendar: BuiltinCalendarId) {\n  return GetIntrinsic('%calendarImpl%')(calendar);\n}\n\nexport function calendarImplForObj(\n  temporalObj:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainMonthDay\n    | Temporal.PlainYearMonth\n    | Temporal.ZonedDateTime\n) {\n  return GetIntrinsic('%calendarImpl%')(GetSlot(temporalObj, CALENDAR));\n}\n\ntype ISODateToFieldsReturn<Type extends ISODateToFieldsType> = Resolve<{\n  year: Type extends 'date' | 'year-month' ? number : never;\n  monthCode: string;\n  day: Type extends 'date' | 'month-day' ? number : never;\n}>;\n\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate): ISODateToFieldsReturn<'date'>;\nexport function ISODateToFields<T extends ISODateToFieldsType>(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  type: T\n): ISODateToFieldsReturn<T>;\nexport function ISODateToFields(calendar: BuiltinCalendarId, isoDate: ISODate, type = 'date') {\n  const fields = Object.create(null);\n  const calendarImpl = calendarImplForID(calendar);\n  const calendarDate = calendarImpl.isoToDate(isoDate, { year: true, monthCode: true, day: true });\n\n  fields.monthCode = calendarDate.monthCode;\n  if (type === 'month-day' || type === 'date') {\n    fields.day = calendarDate.day;\n  }\n  if (type === 'year-month' || type === 'date') {\n    fields.year = calendarDate.year;\n  }\n  return fields;\n}\n\ntype Prop<T, K> = T extends unknown ? (K extends keyof T ? T[K] : undefined) : 'ThisShouldNeverHappen';\n\ntype FieldObjectWithRequired<FieldKeys extends FieldKey> = Resolve<\n  // The resulting object type contains:\n  // - All keys in FieldKeys, which are required properties and their values\n  //   don't include undefined.\n  // - All the other keys in CalendarFieldsRecord that aren't in FieldKeys,\n  //   which are optional properties and their value types explicitly include\n  //   undefined.\n  {\n    -readonly [k in FieldKeys]: Exclude<Prop<CalendarFieldsRecord, k>, undefined>;\n  } & {\n    -readonly [k in Exclude<Keys<CalendarFieldsRecord>, FieldKeys>]?: Prop<CalendarFieldsRecord, k> | undefined;\n  }\n>;\n\ntype PrepareCalendarFieldsReturn<\n  FieldKeys extends FieldKey,\n  RequiredFieldsOpt extends ReadonlyArray<FieldKey> | 'partial'\n> = RequiredFieldsOpt extends 'partial' ? Partial<CalendarFieldsRecord> : FieldObjectWithRequired<FieldKeys>;\n\nexport function PrepareCalendarFields<\n  FieldKeys extends FieldKey,\n  RequiredFields extends ReadonlyArray<FieldKey> | 'partial'\n>(\n  calendar: BuiltinCalendarId,\n  bag: Partial<Record<FieldKeys, unknown>>,\n  calendarFieldNames: Array<FieldKeys>,\n  nonCalendarFieldNames: Array<FieldKeys>,\n  requiredFields: RequiredFields\n): PrepareCalendarFieldsReturn<FieldKeys, RequiredFields> {\n  const extraFieldNames = calendarImplForID(calendar).extraFields(calendarFieldNames) as FieldKeys[];\n  const fields = calendarFieldNames.concat(nonCalendarFieldNames, extraFieldNames);\n  const result: Partial<Record<AnyTemporalKey, unknown>> = Object.create(null);\n  let any = false;\n  fields.sort();\n  for (let index = 0; index < fields.length; index++) {\n    const property = fields[index];\n    const value = bag[property];\n    if (value !== undefined) {\n      any = true;\n      result[property] = castExists(BUILTIN_CASTS[property])(value);\n    } else if (requiredFields !== 'partial') {\n      if (requiredFields.includes(property)) {\n        throw new TypeError(`required property '${property}' missing or undefined`);\n      }\n      result[property] = BUILTIN_DEFAULTS[property];\n    }\n  }\n  if (requiredFields === 'partial' && !any) {\n    throw new TypeError('no supported properties found');\n  }\n  return result as unknown as PrepareCalendarFieldsReturn<FieldKeys, RequiredFields>;\n}\n\ntype FieldCompleteness = 'complete' | 'partial';\n\nexport function ToTemporalTimeRecord(bag: Partial<Record<keyof TimeRecord, string | number>>): TimeRecord;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: 'partial'\n): Partial<TimeRecord>;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number>>,\n  completeness: 'complete'\n): TimeRecord;\nexport function ToTemporalTimeRecord(\n  bag: Partial<Record<keyof TimeRecord, string | number | undefined>>,\n  completeness: FieldCompleteness = 'complete'\n): Partial<TimeRecord> {\n  // NOTE: Field order is sorted to make the sort in PrepareTemporalFields more efficient.\n  const fields: (keyof TimeRecord)[] = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n  let any = false;\n  const result: Partial<TimeRecord> = Object.create(null);\n  for (let index = 0; index < fields.length; index++) {\n    const field = fields[index];\n    const value = bag[field];\n    if (value !== undefined) {\n      result[field] = ToIntegerWithTruncation(value);\n      any = true;\n    } else if (completeness === 'complete') {\n      result[field] = 0;\n    }\n  }\n  if (!any) throw new TypeError('invalid time-like');\n  return result;\n}\n\nexport function ToTemporalDate(\n  item: PlainDateParams['from'][0],\n  options?: PlainDateParams['from'][1]\n): Temporal.PlainDate {\n  if (IsObject(item)) {\n    if (IsTemporalDate(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDate(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n      const isoDate = isoDateTime.isoDate;\n      return CreateTemporalDate(isoDate, GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n      return CreateTemporalDate(GetSlot(item, ISO_DATE_TIME).isoDate, GetSlot(item, CALENDAR));\n    }\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarDateFromFields(calendar, fields, overflow);\n    return CreateTemporalDate(isoDate, calendar);\n  }\n  let { year, month, day, calendar, z } = ParseTemporalDateString(RequireString(item));\n  if (z) throw new RangeError('Z designator not supported for PlainDate');\n  if (!calendar) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n  GetTemporalOverflowOption(GetOptionsObject(options)); // validate and ignore\n  return CreateTemporalDate({ year, month, day }, calendar);\n}\n\nexport function InterpretTemporalDateTimeFields(\n  calendar: BuiltinCalendarId,\n  fields: CalendarFieldsRecord & TimeRecord,\n  overflow: Overflow\n) {\n  const isoDate = CalendarDateFromFields(calendar, fields, overflow);\n  const time = RegulateTime(\n    fields.hour,\n    fields.minute,\n    fields.second,\n    fields.millisecond,\n    fields.microsecond,\n    fields.nanosecond,\n    overflow\n  );\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nexport function ToTemporalDateTime(item: PlainDateTimeParams['from'][0], options?: PlainDateTimeParams['from'][1]) {\n  let isoDate, time, calendar;\n\n  if (IsObject(item)) {\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(GetSlot(item, ISO_DATE_TIME), GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(isoDateTime, GetSlot(item, CALENDAR));\n    }\n    if (IsTemporalDate(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalDateTime(\n        CombineISODateAndTimeRecord(GetSlot(item, ISO_DATE), MidnightTimeRecord()),\n        GetSlot(item, CALENDAR)\n      );\n    }\n\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(\n      calendar,\n      item,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\n      []\n    );\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\n  } else {\n    let z, year, month, day;\n    ({ year, month, day, time, calendar, z } = ParseTemporalDateTimeString(RequireString(item)));\n    if (z) throw new RangeError('Z designator not supported for PlainDateTime');\n    if (time === 'start-of-day') time = MidnightTimeRecord();\n    RejectDateTime(\n      year,\n      month,\n      day,\n      time.hour,\n      time.minute,\n      time.second,\n      time.millisecond,\n      time.microsecond,\n      time.nanosecond\n    );\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    GetTemporalOverflowOption(GetOptionsObject(options));\n    isoDate = { year, month, day };\n  }\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, time);\n  return CreateTemporalDateTime(isoDateTime, calendar);\n}\n\nexport function ToTemporalDuration(item: DurationParams['from'][0]) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  if (IsTemporalDuration(item)) {\n    return new TemporalDuration(\n      GetSlot(item, YEARS),\n      GetSlot(item, MONTHS),\n      GetSlot(item, WEEKS),\n      GetSlot(item, DAYS),\n      GetSlot(item, HOURS),\n      GetSlot(item, MINUTES),\n      GetSlot(item, SECONDS),\n      GetSlot(item, MILLISECONDS),\n      GetSlot(item, MICROSECONDS),\n      GetSlot(item, NANOSECONDS)\n    );\n  }\n  if (!IsObject(item)) {\n    return ParseTemporalDurationString(RequireString(item));\n  }\n  const result = {\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0\n  };\n  let partial = ToTemporalPartialDurationRecord(item);\n  for (let index = 0; index < DURATION_FIELDS.length; index++) {\n    const property = DURATION_FIELDS[index];\n    const value = partial[property];\n    if (value !== undefined) {\n      result[property] = value;\n    }\n  }\n  return new TemporalDuration(\n    result.years,\n    result.months,\n    result.weeks,\n    result.days,\n    result.hours,\n    result.minutes,\n    result.seconds,\n    result.milliseconds,\n    result.microseconds,\n    result.nanoseconds\n  );\n}\n\nexport function ToTemporalInstant(itemParam: InstantParams['from'][0]) {\n  let item: string | number;\n  if (IsObject(itemParam)) {\n    if (IsTemporalInstant(itemParam) || IsTemporalZonedDateTime(itemParam)) {\n      return CreateTemporalInstant(GetSlot(itemParam, EPOCHNANOSECONDS));\n    }\n    item = ToPrimitive(itemParam, String);\n  } else {\n    item = itemParam;\n  }\n  const { year, month, day, time, offset, z } = ParseTemporalInstantString(RequireString(item));\n  const {\n    hour = 0,\n    minute = 0,\n    second = 0,\n    millisecond = 0,\n    microsecond = 0,\n    nanosecond = 0\n  } = time === 'start-of-day' ? {} : time;\n\n  // ParseTemporalInstantString ensures that either `z` is true or or `offset` is non-undefined\n  const offsetNanoseconds = z ? 0 : ParseDateTimeUTCOffset(castExists(offset));\n  const balanced = BalanceISODateTime(\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second,\n    millisecond,\n    microsecond,\n    nanosecond - offsetNanoseconds\n  );\n  CheckISODaysRange(balanced.isoDate);\n  const epochNanoseconds = GetUTCEpochNanoseconds(balanced);\n  return CreateTemporalInstant(epochNanoseconds);\n}\n\nexport function ToTemporalMonthDay(item: PlainMonthDayParams['from'][0], options?: PlainMonthDayParams['from'][1]) {\n  if (IsObject(item)) {\n    if (IsTemporalMonthDay(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalMonthDay(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    let calendar;\n    if (HasSlot(item, CALENDAR)) {\n      calendar = GetSlot(item, CALENDAR);\n    } else {\n      calendar = item.calendar;\n      if (calendar === undefined) calendar = 'iso8601';\n      calendar = ToTemporalCalendarIdentifier(calendar);\n    }\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode', 'day'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarMonthDayFromFields(calendar, fields, overflow);\n    return CreateTemporalMonthDay(isoDate, calendar);\n  }\n\n  let { month, day, referenceISOYear, calendar } = ParseTemporalMonthDayString(RequireString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n\n  GetTemporalOverflowOption(GetOptionsObject(options));\n  if (calendar === 'iso8601') {\n    const isoCalendarReferenceYear = 1972; // First leap year after Unix epoch\n    return CreateTemporalMonthDay({ year: isoCalendarReferenceYear, month, day }, calendar);\n  }\n  assertExists(referenceISOYear);\n  let isoDate = { year: referenceISOYear, month, day };\n  RejectDateRange(isoDate);\n  const result = ISODateToFields(calendar, isoDate, 'month-day');\n  isoDate = CalendarMonthDayFromFields(calendar, result, 'constrain');\n  return CreateTemporalMonthDay(isoDate, calendar);\n}\n\nexport function ToTemporalTime(item: PlainTimeParams['from'][0], options?: PlainTimeParams['from'][1]) {\n  let time;\n  if (IsObject(item)) {\n    if (IsTemporalTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(GetSlot(item, TIME));\n    }\n    if (IsTemporalDateTime(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(GetSlot(item, ISO_DATE_TIME).time);\n    }\n    if (IsTemporalZonedDateTime(item)) {\n      const isoDateTime = GetISODateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, EPOCHNANOSECONDS));\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalTime(isoDateTime.time);\n    }\n    const { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow);\n  } else {\n    time = ParseTemporalTimeString(RequireString(item));\n    GetTemporalOverflowOption(GetOptionsObject(options));\n  }\n  return CreateTemporalTime(time);\n}\n\nexport function ToTimeRecordOrMidnight(item: PlainTimeParams['from'][0] | undefined) {\n  if (item === undefined) return MidnightTimeRecord();\n  return GetSlot(ToTemporalTime(item), TIME);\n}\n\nexport function ToTemporalYearMonth(\n  item: PlainYearMonthParams['from'][0],\n  options?: PlainYearMonthParams['from'][1]\n): Temporal.PlainYearMonth {\n  if (IsObject(item)) {\n    if (IsTemporalYearMonth(item)) {\n      GetTemporalOverflowOption(GetOptionsObject(options));\n      return CreateTemporalYearMonth(GetSlot(item, ISO_DATE), GetSlot(item, CALENDAR));\n    }\n    const calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(calendar, item, ['year', 'month', 'monthCode'], [], []);\n    const overflow = GetTemporalOverflowOption(GetOptionsObject(options));\n    const isoDate = CalendarYearMonthFromFields(calendar, fields, overflow);\n    return CreateTemporalYearMonth(isoDate, calendar);\n  }\n\n  let { year, month, referenceISODay, calendar } = ParseTemporalYearMonthString(RequireString(item));\n  if (calendar === undefined) calendar = 'iso8601';\n  calendar = CanonicalizeCalendar(calendar);\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(calendar, 'lowercased and canonicalized');\n\n  GetTemporalOverflowOption(GetOptionsObject(options));\n  let isoDate = { year, month, day: referenceISODay };\n  RejectYearMonthRange(isoDate);\n  const result = ISODateToFields(calendar, isoDate, 'year-month');\n  isoDate = CalendarYearMonthFromFields(calendar, result, 'constrain');\n  return CreateTemporalYearMonth(isoDate, calendar);\n}\n\ntype OffsetBehaviour = 'wall' | 'exact' | 'option';\n\nexport function InterpretISODateTimeOffset(\n  isoDate: ISODate,\n  time: 'start-of-day' | TimeRecord,\n  offsetBehaviour: OffsetBehaviour,\n  offsetNs: number,\n  timeZone: string,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>,\n  offsetOpt: Temporal.OffsetDisambiguationOptions['offset'],\n  matchMinute: boolean\n) {\n  // start-of-day signifies that we had a string such as YYYY-MM-DD[Zone]. It is\n  // grammatically not possible to specify a UTC offset in that string, so the\n  // behaviour collapses into ~WALL~, which is equivalent to offset: \"ignore\".\n  if (time === 'start-of-day') {\n    assert(offsetBehaviour === 'wall', 'offset cannot be provided in YYYY-MM-DD[Zone] string');\n    assert(offsetNs === 0, 'offset cannot be provided in YYYY-MM-DD[Zone] string');\n    return GetStartOfDay(timeZone, isoDate);\n  }\n\n  const dt = CombineISODateAndTimeRecord(isoDate, time);\n\n  if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n    // Simple case: ISO string without a TZ offset (or caller wants to ignore\n    // the offset), so just convert DateTime to Instant in the given time zone\n    return GetEpochNanosecondsFor(timeZone, dt, disambiguation);\n  }\n\n  // The caller wants the offset to always win ('use') OR the caller is OK\n  // with the offset winning ('prefer' or 'reject') as long as it's valid\n  // for this timezone and date/time.\n  if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n    // Calculate the instant for the input's date/time and offset\n    const balanced = BalanceISODateTime(\n      isoDate.year,\n      isoDate.month,\n      isoDate.day,\n      time.hour,\n      time.minute,\n      time.second,\n      time.millisecond,\n      time.microsecond,\n      time.nanosecond - offsetNs\n    );\n    CheckISODaysRange(balanced.isoDate);\n    const epochNs = GetUTCEpochNanoseconds(balanced);\n    ValidateEpochNanoseconds(epochNs);\n    return epochNs;\n  }\n\n  CheckISODaysRange(isoDate);\n  const utcEpochNs = GetUTCEpochNanoseconds(dt);\n\n  // \"prefer\" or \"reject\"\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, dt);\n  for (let index = 0; index < possibleEpochNs.length; index++) {\n    const candidate = possibleEpochNs[index];\n    const candidateOffset = JSBI.toNumber(JSBI.subtract(utcEpochNs, candidate));\n    const roundedCandidateOffset = RoundNumberToIncrement(candidateOffset, 60e9, 'halfExpand');\n    if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n      return candidate;\n    }\n  }\n\n  // the user-provided offset doesn't match any instants for this time\n  // zone and date/time.\n  if (offsetOpt === 'reject') {\n    const offsetStr = FormatUTCOffsetNanoseconds(offsetNs);\n    const dtStr = ISODateTimeToString(dt, 'iso8601', 'auto');\n    throw new RangeError(`Offset ${offsetStr} is invalid for ${dtStr} in ${timeZone}`);\n  }\n  // fall through: offsetOpt === 'prefer', but the offset doesn't match\n  // so fall back to use the time zone instead.\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, dt, disambiguation);\n}\n\nexport function ToTemporalZonedDateTime(\n  item: ZonedDateTimeParams['from'][0],\n  options?: ZonedDateTimeParams['from'][1]\n) {\n  let isoDate, time, timeZone, offset, calendar;\n  let matchMinute = false;\n  let offsetBehaviour: OffsetBehaviour = 'option';\n  let disambiguation, offsetOpt;\n  if (IsObject(item)) {\n    if (IsTemporalZonedDateTime(item)) {\n      const resolvedOptions = GetOptionsObject(options);\n      GetTemporalDisambiguationOption(resolvedOptions); // validate and ignore\n      GetTemporalOffsetOption(resolvedOptions, 'reject');\n      GetTemporalOverflowOption(resolvedOptions);\n      return CreateTemporalZonedDateTime(\n        GetSlot(item, EPOCHNANOSECONDS),\n        GetSlot(item, TIME_ZONE),\n        GetSlot(item, CALENDAR)\n      );\n    }\n    calendar = GetTemporalCalendarIdentifierWithISODefault(item);\n    const fields = PrepareCalendarFields(\n      calendar,\n      item,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset', 'timeZone'],\n      ['timeZone']\n    );\n    ({ offset, timeZone } = fields);\n    if (offset === undefined) {\n      offsetBehaviour = 'wall';\n    }\n    const resolvedOptions = GetOptionsObject(options);\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\n    const overflow = GetTemporalOverflowOption(resolvedOptions);\n    ({ isoDate, time } = InterpretTemporalDateTimeFields(calendar, fields, overflow));\n  } else {\n    let tzAnnotation, z, year, month, day;\n    ({ year, month, day, time, tzAnnotation, offset, z, calendar } = ParseTemporalZonedDateTimeString(\n      RequireString(item)\n    ));\n    timeZone = ToTemporalTimeZoneIdentifier(tzAnnotation);\n    if (z) {\n      offsetBehaviour = 'exact';\n    } else if (!offset) {\n      offsetBehaviour = 'wall';\n    }\n    if (!calendar) calendar = 'iso8601';\n    calendar = CanonicalizeCalendar(calendar);\n    matchMinute = true; // ISO strings may specify offset with less precision\n    const resolvedOptions = GetOptionsObject(options);\n    disambiguation = GetTemporalDisambiguationOption(resolvedOptions);\n    offsetOpt = GetTemporalOffsetOption(resolvedOptions, 'reject');\n    GetTemporalOverflowOption(resolvedOptions); // validate and ignore\n    isoDate = { year, month, day };\n  }\n  let offsetNs = 0;\n  if (offsetBehaviour === 'option') offsetNs = ParseDateTimeUTCOffset(castExists(offset));\n  const epochNanoseconds = InterpretISODateTimeOffset(\n    isoDate,\n    time,\n    offsetBehaviour,\n    offsetNs,\n    timeZone,\n    disambiguation,\n    offsetOpt,\n    matchMinute\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\nexport function CreateTemporalDateSlots(result: Temporal.PlainDate, isoDate: ISODate, calendar: BuiltinCalendarId) {\n  RejectDateRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, DATE_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalDateToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainDate <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDate(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n  const result = Object.create(TemporalPlainDate.prototype);\n  CreateTemporalDateSlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalDateTimeSlots(\n  result: Temporal.PlainDateTime,\n  isoDateTime: ISODateTime,\n  calendar: BuiltinCalendarId\n) {\n  RejectDateTimeRange(isoDateTime);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE_TIME, isoDateTime);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    let repr = ISODateTimeToString(isoDateTime, calendar, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainDateTime <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalDateTime(isoDateTime: ISODateTime, calendar: BuiltinCalendarId) {\n  const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n  const result = Object.create(TemporalPlainDateTime.prototype);\n  CreateTemporalDateTimeSlots(result, isoDateTime, calendar);\n  return result;\n}\n\nexport function CreateTemporalMonthDaySlots(\n  result: Temporal.PlainMonthDay,\n  isoDate: ISODate,\n  calendar: BuiltinCalendarId\n) {\n  RejectDateRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, MONTH_DAY_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalMonthDayToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainMonthDay <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalMonthDay(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n  const result = Object.create(TemporalPlainMonthDay.prototype);\n  CreateTemporalMonthDaySlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalTimeSlots(result: Temporal.PlainTime, time: TimeRecord) {\n  CreateSlots(result);\n  SetSlot(result, TIME, time);\n\n  if (DEBUG) {\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainTime <${TimeRecordToString(time, 'auto')}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalTime(time: TimeRecord) {\n  const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n  const result = Object.create(TemporalPlainTime.prototype);\n  CreateTemporalTimeSlots(result, time);\n  return result;\n}\n\nexport function CreateTemporalYearMonthSlots(\n  result: Temporal.PlainYearMonth,\n  isoDate: ISODate,\n  calendar: BuiltinCalendarId\n) {\n  RejectYearMonthRange(isoDate);\n\n  CreateSlots(result);\n  SetSlot(result, ISO_DATE, isoDate);\n  SetSlot(result, CALENDAR, calendar);\n  SetSlot(result, YEAR_MONTH_BRAND, true);\n\n  if (DEBUG) {\n    const repr = TemporalYearMonthToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.PlainYearMonth <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalYearMonth(isoDate: ISODate, calendar: BuiltinCalendarId) {\n  const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n  const result = Object.create(TemporalPlainYearMonth.prototype);\n  CreateTemporalYearMonthSlots(result, isoDate, calendar);\n  return result;\n}\n\nexport function CreateTemporalInstantSlots(result: Temporal.Instant, epochNanoseconds: JSBI) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n\n  if (DEBUG) {\n    const iso = GetISOPartsFromEpoch(epochNanoseconds);\n    const repr = ISODateTimeToString(iso, 'iso8601', 'auto', 'never') + 'Z';\n    Object.defineProperty(result, '_repr_', {\n      value: `${result[Symbol.toStringTag]} <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalInstant(epochNanoseconds: JSBI) {\n  const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n  const result: Temporal.Instant = Object.create(TemporalInstant.prototype);\n  CreateTemporalInstantSlots(result, epochNanoseconds);\n  return result;\n}\n\nexport function CreateTemporalZonedDateTimeSlots(\n  result: Temporal.ZonedDateTime,\n  epochNanoseconds: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId\n) {\n  ValidateEpochNanoseconds(epochNanoseconds);\n\n  CreateSlots(result);\n  SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n  SetSlot(result, TIME_ZONE, timeZone);\n  SetSlot(result, CALENDAR, calendar);\n\n  if (DEBUG) {\n    const repr = TemporalZonedDateTimeToString(result, 'auto');\n    Object.defineProperty(result, '_repr_', {\n      value: `Temporal.ZonedDateTime <${repr}>`,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n  }\n}\n\nexport function CreateTemporalZonedDateTime(\n  epochNanoseconds: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId = 'iso8601'\n) {\n  const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n  const result: Temporal.ZonedDateTime = Object.create(TemporalZonedDateTime.prototype);\n  CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n  return result;\n}\n\nfunction CalendarFieldKeysPresent(fields: Record<FieldKey, unknown>) {\n  return CALENDAR_FIELD_KEYS.filter((key) => fields[key] !== undefined);\n}\n\nexport function CalendarMergeFields<Base extends Record<string, unknown>, ToAdd extends Record<string, unknown>>(\n  calendar: BuiltinCalendarId,\n  fields: Base,\n  additionalFields: ToAdd\n) {\n  const additionalKeys = CalendarFieldKeysPresent(additionalFields);\n  const overriddenKeys = calendarImplForID(calendar).fieldKeysToIgnore(additionalKeys);\n  const merged = Object.create(null);\n  const fieldsKeys = CalendarFieldKeysPresent(fields);\n  for (let ix = 0; ix < CALENDAR_FIELD_KEYS.length; ix++) {\n    let propValue = undefined;\n    const key = CALENDAR_FIELD_KEYS[ix];\n    if (fieldsKeys.includes(key) && !overriddenKeys.includes(key)) {\n      propValue = fields[key];\n    }\n    if (additionalKeys.includes(key)) {\n      propValue = additionalFields[key];\n    }\n    if (propValue !== undefined) merged[key] = propValue;\n  }\n  return merged as Base & ToAdd;\n}\n\nexport function CalendarDateAdd(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  dateDuration: Partial<DateDuration>,\n  overflow: Overflow\n) {\n  const result = calendarImplForID(calendar).dateAdd(isoDate, dateDuration, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nfunction CalendarDateUntil(\n  calendar: BuiltinCalendarId,\n  isoDate: ISODate,\n  isoOtherDate: ISODate,\n  largestUnit: Temporal.DateUnit\n) {\n  return calendarImplForID(calendar).dateUntil(isoDate, isoOtherDate, largestUnit);\n}\n\nexport function ToTemporalCalendarIdentifier(calendarLike: Temporal.CalendarLike): BuiltinCalendarId {\n  if (IsObject(calendarLike)) {\n    if (HasSlot(calendarLike, CALENDAR)) return GetSlot(calendarLike, CALENDAR);\n  }\n  const identifier = RequireString(calendarLike);\n  try {\n    // Fast path: identifier is a calendar type, no ISO string parsing needed\n    return CanonicalizeCalendar(identifier);\n  } catch {\n    // fall through\n  }\n  let calendar;\n  try {\n    ({ calendar } = ParseISODateTime(identifier));\n  } catch {\n    try {\n      ({ calendar } = ParseTemporalTimeString(identifier));\n    } catch {\n      try {\n        ({ calendar } = ParseTemporalYearMonthString(identifier));\n      } catch {\n        ({ calendar } = ParseTemporalMonthDayString(identifier));\n      }\n    }\n  }\n  if (!calendar) calendar = 'iso8601';\n  return CanonicalizeCalendar(calendar);\n}\n\nfunction GetTemporalCalendarIdentifierWithISODefault(item: { calendar?: Temporal.CalendarLike }) {\n  if (HasSlot(item, CALENDAR)) return GetSlot(item, CALENDAR);\n  const { calendar } = item;\n  if (calendar === undefined) return 'iso8601';\n  return ToTemporalCalendarIdentifier(calendar);\n}\n\nexport function CalendarEquals(one: BuiltinCalendarId, two: BuiltinCalendarId) {\n  return CanonicalizeCalendar(one) === CanonicalizeCalendar(two);\n}\n\nexport function CalendarDateFromFields(calendar: BuiltinCalendarId, fields: CalendarFieldsRecord, overflow: Overflow) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'date');\n  const result = calendarImpl.dateToISO(fields, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nexport function CalendarYearMonthFromFields(\n  calendar: BuiltinCalendarId,\n  fields: CalendarFieldsRecord,\n  overflow: Overflow\n) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'year-month');\n  fields.day = 1;\n  const result = calendarImpl.dateToISO(fields, overflow);\n  RejectYearMonthRange(result);\n  return result;\n}\n\nexport function CalendarMonthDayFromFields(\n  calendar: BuiltinCalendarId,\n  fields: MonthDayFromFieldsObject,\n  overflow: Overflow\n) {\n  const calendarImpl: CalendarImpl = calendarImplForID(calendar);\n  calendarImpl.resolveFields(fields, 'month-day');\n  const result = calendarImpl.monthDayToISOReferenceDate(fields, overflow);\n  RejectDateRange(result);\n  return result;\n}\n\nexport function ToTemporalTimeZoneIdentifier(temporalTimeZoneLike: unknown): string {\n  if (IsObject(temporalTimeZoneLike)) {\n    if (IsTemporalZonedDateTime(temporalTimeZoneLike)) return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n  }\n  const timeZoneString = RequireString(temporalTimeZoneLike);\n  if (timeZoneString === 'UTC') return 'UTC'; // UTC fast path\n\n  const { tzName, offsetMinutes } = ParseTemporalTimeZoneString(timeZoneString);\n  if (offsetMinutes !== undefined) {\n    return FormatOffsetTimeZoneIdentifier(offsetMinutes);\n  }\n  // if offsetMinutes is undefined, then tzName must be present\n  const record = GetAvailableNamedTimeZoneIdentifier(castExists(tzName));\n  if (!record) throw new RangeError(`Unrecognized time zone ${tzName}`);\n  return record.identifier;\n}\n\nexport function TimeZoneEquals(one: string, two: string) {\n  if (one === two) return true;\n  const offsetMinutes1 = ParseTimeZoneIdentifier(one).offsetMinutes;\n  const offsetMinutes2 = ParseTimeZoneIdentifier(two).offsetMinutes;\n  if (offsetMinutes1 === undefined && offsetMinutes2 === undefined) {\n    // Calling GetAvailableNamedTimeZoneIdentifier is costly, so (unlike the\n    // spec) the polyfill will early-return if one of them isn't recognized. Try\n    // the second ID first because it's more likely to be unknown, because it\n    // can come from the argument of TimeZone.p.equals as opposed to the first\n    // ID which comes from the receiver.\n    const idRecord2 = GetAvailableNamedTimeZoneIdentifier(two);\n    if (!idRecord2) return false;\n    const idRecord1 = GetAvailableNamedTimeZoneIdentifier(one);\n    if (!idRecord1) return false;\n    return idRecord1.primaryIdentifier === idRecord2.primaryIdentifier;\n  } else {\n    return offsetMinutes1 === offsetMinutes2;\n  }\n}\n\nexport function GetOffsetNanosecondsFor(timeZone: string, epochNs: JSBI) {\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\n  if (offsetMinutes !== undefined) return offsetMinutes * 60e9;\n\n  return GetNamedTimeZoneOffsetNanoseconds(timeZone, epochNs);\n}\n\nexport function FormatUTCOffsetNanoseconds(offsetNs: number): string {\n  const sign = offsetNs < 0 ? '-' : '+';\n  const absoluteNs = Math.abs(offsetNs);\n  const hour = Math.floor(absoluteNs / 3600e9);\n  const minute = Math.floor(absoluteNs / 60e9) % 60;\n  const second = Math.floor(absoluteNs / 1e9) % 60;\n  const subSecondNs = absoluteNs % 1e9;\n  const precision = second === 0 && subSecondNs === 0 ? 'minute' : 'auto';\n  const timeString = FormatTimeString(hour, minute, second, subSecondNs, precision);\n  return `${sign}${timeString}`;\n}\n\nexport function GetISODateTimeFor(timeZone: string, epochNs: JSBI) {\n  const offsetNs = GetOffsetNanosecondsFor(timeZone, epochNs);\n  let {\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  } = GetISOPartsFromEpoch(epochNs);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs);\n}\n\nexport function GetEpochNanosecondsFor(\n  timeZone: string,\n  isoDateTime: ISODateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\n  return DisambiguatePossibleEpochNanoseconds(possibleEpochNs, timeZone, isoDateTime, disambiguation);\n}\n\n// TODO: See if this logic can be removed in favour of GetNamedTimeZoneEpochNanoseconds\nfunction DisambiguatePossibleEpochNanoseconds(\n  possibleEpochNs: JSBI[],\n  timeZone: string,\n  isoDateTime: ISODateTime,\n  disambiguation: NonNullable<Temporal.ToInstantOptions['disambiguation']>\n) {\n  const numInstants = possibleEpochNs.length;\n\n  if (numInstants === 1) return possibleEpochNs[0];\n  if (numInstants) {\n    switch (disambiguation) {\n      case 'compatible':\n      // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n      case 'earlier':\n        return possibleEpochNs[0];\n      case 'later':\n        return possibleEpochNs[numInstants - 1];\n      case 'reject': {\n        throw new RangeError('multiple instants found');\n      }\n    }\n  }\n\n  if (disambiguation === 'reject') throw new RangeError('multiple instants found');\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\n\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayBefore);\n  const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n  const dayAfter = JSBI.add(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayAfter);\n  const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n  const nanoseconds = offsetAfter - offsetBefore;\n  assert(Math.abs(nanoseconds) <= DAY_NANOS, 'UTC offset shift longer than 24 hours');\n\n  switch (disambiguation) {\n    case 'earlier': {\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, -nanoseconds);\n      const earlierTime = AddTime(isoDateTime.time, timeDuration);\n      const earlierDate = BalanceISODate(\n        isoDateTime.isoDate.year,\n        isoDateTime.isoDate.month,\n        isoDateTime.isoDate.day + earlierTime.deltaDays\n      );\n      const earlier = CombineISODateAndTimeRecord(earlierDate, earlierTime);\n      return GetPossibleEpochNanoseconds(timeZone, earlier)[0];\n    }\n    case 'compatible':\n    // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n    case 'later': {\n      const timeDuration = TimeDuration.fromComponents(0, 0, 0, 0, 0, nanoseconds);\n      const laterTime = AddTime(isoDateTime.time, timeDuration);\n      const laterDate = BalanceISODate(\n        isoDateTime.isoDate.year,\n        isoDateTime.isoDate.month,\n        isoDateTime.isoDate.day + laterTime.deltaDays\n      );\n      const later = CombineISODateAndTimeRecord(laterDate, laterTime);\n      const possible = GetPossibleEpochNanoseconds(timeZone, later);\n      return possible[possible.length - 1];\n    }\n  }\n}\n\nfunction GetPossibleEpochNanoseconds(timeZone: string, isoDateTime: ISODateTime) {\n  // UTC fast path\n  if (timeZone === 'UTC') {\n    CheckISODaysRange(isoDateTime.isoDate);\n    return [GetUTCEpochNanoseconds(isoDateTime)];\n  }\n\n  const offsetMinutes = ParseTimeZoneIdentifier(timeZone).offsetMinutes;\n  if (offsetMinutes !== undefined) {\n    const balanced = BalanceISODateTime(\n      isoDateTime.isoDate.year,\n      isoDateTime.isoDate.month,\n      isoDateTime.isoDate.day,\n      isoDateTime.time.hour,\n      isoDateTime.time.minute - offsetMinutes,\n      isoDateTime.time.second,\n      isoDateTime.time.millisecond,\n      isoDateTime.time.microsecond,\n      isoDateTime.time.nanosecond\n    );\n    CheckISODaysRange(balanced.isoDate);\n    const epochNs = GetUTCEpochNanoseconds(balanced);\n    ValidateEpochNanoseconds(epochNs);\n    return [epochNs];\n  }\n\n  CheckISODaysRange(isoDateTime.isoDate);\n  return GetNamedTimeZoneEpochNanoseconds(timeZone, isoDateTime);\n}\n\nexport function GetStartOfDay(timeZone: string, isoDate: ISODate) {\n  const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\n  const possibleEpochNs = GetPossibleEpochNanoseconds(timeZone, isoDateTime);\n  // If not a DST gap, return the single or earlier epochNs\n  if (possibleEpochNs.length) return possibleEpochNs[0];\n\n  // Otherwise, 00:00:00 lies within a DST gap. Compute an epochNs that's\n  // guaranteed to be before the transition\n  assert(!IsOffsetTimeZoneIdentifier(timeZone), 'should only be reached with named time zone');\n\n  const utcns = GetUTCEpochNanoseconds(isoDateTime);\n  const dayBefore = JSBI.subtract(utcns, DAY_NANOS_JSBI);\n  ValidateEpochNanoseconds(dayBefore);\n  return castExists(GetNamedTimeZoneNextTransition(timeZone, dayBefore));\n}\n\nexport function ISOYearString(year: number) {\n  let yearString;\n  if (year < 0 || year > 9999) {\n    const sign = year < 0 ? '-' : '+';\n    const yearNumber = Math.abs(year);\n    yearString = sign + ToZeroPaddedDecimalString(yearNumber, 6);\n  } else {\n    yearString = ToZeroPaddedDecimalString(year, 4);\n  }\n  return yearString;\n}\n\nexport function ISODateTimePartString(part: number) {\n  return ToZeroPaddedDecimalString(part, 2);\n}\n\nfunction FormatFractionalSeconds(\n  subSecondNanoseconds: number,\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\n): string {\n  let fraction;\n  if (precision === 'auto') {\n    if (subSecondNanoseconds === 0) return '';\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\n    // now remove any trailing zeroes\n    fraction = fractionFullPrecision.replace(/0+$/, '');\n  } else {\n    if (precision === 0) return '';\n    const fractionFullPrecision = ToZeroPaddedDecimalString(subSecondNanoseconds, 9);\n    fraction = fractionFullPrecision.slice(0, precision);\n  }\n  return `.${fraction}`;\n}\n\nfunction FormatTimeString(\n  hour: number,\n  minute: number,\n  second: number,\n  subSecondNanoseconds: number,\n  precision: SecondsStringPrecisionRecord['precision']\n): string {\n  let result = `${ISODateTimePartString(hour)}:${ISODateTimePartString(minute)}`;\n  if (precision === 'minute') return result;\n\n  result += `:${ISODateTimePartString(second)}`;\n  result += FormatFractionalSeconds(subSecondNanoseconds, precision);\n  return result;\n}\n\nexport function TemporalInstantToString(\n  instant: Temporal.Instant,\n  timeZone: string | undefined,\n  precision: SecondsStringPrecisionRecord['precision']\n) {\n  let outputTimeZone = timeZone;\n  if (outputTimeZone === undefined) outputTimeZone = 'UTC';\n  const epochNs = GetSlot(instant, EPOCHNANOSECONDS);\n  const iso = GetISODateTimeFor(outputTimeZone, epochNs);\n  const dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\n  let timeZoneString = 'Z';\n  if (timeZone !== undefined) {\n    const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, epochNs);\n    timeZoneString = FormatDateTimeUTCOffsetRounded(offsetNs);\n  }\n  return `${dateTimeString}${timeZoneString}`;\n}\n\ninterface ToStringOptions {\n  unit: SecondsStringPrecisionRecord['unit'];\n  increment: number;\n  roundingMode: ReturnType<typeof GetRoundingModeOption>;\n}\n\nexport function TemporalDurationToString(\n  duration: Temporal.Duration,\n  precision: Exclude<SecondsStringPrecisionRecord['precision'], 'minute'>\n) {\n  const years = GetSlot(duration, YEARS);\n  const months = GetSlot(duration, MONTHS);\n  const weeks = GetSlot(duration, WEEKS);\n  const days = GetSlot(duration, DAYS);\n  const hours = GetSlot(duration, HOURS);\n  const minutes = GetSlot(duration, MINUTES);\n  const sign = DurationSign(duration);\n\n  let datePart = '';\n  if (years !== 0) datePart += `${Math.abs(years)}Y`;\n  if (months !== 0) datePart += `${Math.abs(months)}M`;\n  if (weeks !== 0) datePart += `${Math.abs(weeks)}W`;\n  if (days !== 0) datePart += `${Math.abs(days)}D`;\n\n  let timePart = '';\n  if (hours !== 0) timePart += `${Math.abs(hours)}H`;\n  if (minutes !== 0) timePart += `${Math.abs(minutes)}M`;\n\n  // Keeping sub-second units separate avoids losing precision after resolving\n  // any overflows from rounding\n  const secondsDuration = TimeDuration.fromComponents(\n    0,\n    0,\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  );\n  if (\n    !secondsDuration.isZero() ||\n    ['second', 'millisecond', 'microsecond', 'nanosecond'].includes(DefaultTemporalLargestUnit(duration)) ||\n    precision !== 'auto'\n  ) {\n    const secondsPart = Math.abs(secondsDuration.sec);\n    const subSecondsPart = FormatFractionalSeconds(Math.abs(secondsDuration.subsec), precision);\n    timePart += `${secondsPart}${subSecondsPart}S`;\n  }\n  let result = `${sign < 0 ? '-' : ''}P${datePart}`;\n  if (timePart) result = `${result}T${timePart}`;\n  return result;\n}\n\nexport function TemporalDateToString(\n  date: Temporal.PlainDate,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(date, ISO_DATE);\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const calendar = FormatCalendarAnnotation(GetSlot(date, CALENDAR), showCalendar);\n  return `${yearString}-${monthString}-${dayString}${calendar}`;\n}\n\nexport function TimeRecordToString(\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\n  precision: SecondsStringPrecisionRecord['precision']\n) {\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  return FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\n}\n\nexport function ISODateTimeToString(\n  isoDateTime: ISODateTime,\n  calendar: BuiltinCalendarId,\n  precision: SecondsStringPrecisionRecord['precision'],\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto'\n) {\n  const {\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  } = isoDateTime;\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  const subSecondNanoseconds = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n  const timeString = FormatTimeString(hour, minute, second, subSecondNanoseconds, precision);\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  return `${yearString}-${monthString}-${dayString}T${timeString}${calendarString}`;\n}\n\nexport function TemporalMonthDayToString(\n  monthDay: Temporal.PlainMonthDay,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(monthDay, ISO_DATE);\n  const monthString = ISODateTimePartString(month);\n  const dayString = ISODateTimePartString(day);\n  let resultString = `${monthString}-${dayString}`;\n  const calendar = GetSlot(monthDay, CALENDAR);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\n    const yearString = ISOYearString(year);\n    resultString = `${yearString}-${resultString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalYearMonthToString(\n  yearMonth: Temporal.PlainYearMonth,\n  showCalendar: Temporal.ShowCalendarOption['calendarName'] = 'auto'\n) {\n  const { year, month, day } = GetSlot(yearMonth, ISO_DATE);\n  const yearString = ISOYearString(year);\n  const monthString = ISODateTimePartString(month);\n  let resultString = `${yearString}-${monthString}`;\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  if (showCalendar === 'always' || showCalendar === 'critical' || calendar !== 'iso8601') {\n    const dayString = ISODateTimePartString(day);\n    resultString += `-${dayString}`;\n  }\n  const calendarString = FormatCalendarAnnotation(calendar, showCalendar);\n  if (calendarString) resultString += calendarString;\n  return resultString;\n}\n\nexport function TemporalZonedDateTimeToString(\n  zdt: Temporal.ZonedDateTime,\n  precision: SecondsStringPrecisionRecord['precision'],\n  showCalendar: ReturnType<typeof GetTemporalShowCalendarNameOption> = 'auto',\n  showTimeZone: ReturnType<typeof GetTemporalShowTimeZoneNameOption> = 'auto',\n  showOffset: ReturnType<typeof GetTemporalShowOffsetOption> = 'auto',\n  options: ToStringOptions | undefined = undefined\n) {\n  let epochNs = GetSlot(zdt, EPOCHNANOSECONDS);\n\n  if (options) {\n    const { unit, increment, roundingMode } = options;\n    epochNs = RoundTemporalInstant(epochNs, increment, unit, roundingMode);\n  }\n\n  const tz = GetSlot(zdt, TIME_ZONE);\n  const offsetNs = GetOffsetNanosecondsFor(tz, epochNs);\n  const iso = GetISODateTimeFor(tz, epochNs);\n  let dateTimeString = ISODateTimeToString(iso, 'iso8601', precision, 'never');\n  if (showOffset !== 'never') {\n    dateTimeString += FormatDateTimeUTCOffsetRounded(offsetNs);\n  }\n  if (showTimeZone !== 'never') {\n    const flag = showTimeZone === 'critical' ? '!' : '';\n    dateTimeString += `[${flag}${tz}]`;\n  }\n  dateTimeString += FormatCalendarAnnotation(GetSlot(zdt, CALENDAR), showCalendar);\n  return dateTimeString;\n}\n\nexport function IsOffsetTimeZoneIdentifier(string: string) {\n  return OFFSET_IDENTIFIER.test(string);\n}\n\nexport function ParseDateTimeUTCOffset(string: string): number {\n  const match = OFFSET_WITH_PARTS.exec(string);\n  if (!match) {\n    throw new RangeError(`invalid time zone offset: ${string}; must match ±HH:MM[:SS.SSSSSSSSS]`);\n  }\n  const sign = match[1] === '-' ? -1 : +1;\n  const hours = +match[2];\n  const minutes = +(match[3] || 0);\n  const seconds = +(match[4] || 0);\n  const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n  const offsetNanoseconds = sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n  return offsetNanoseconds;\n}\n\nlet canonicalTimeZoneIdsCache: Map<string, string> | undefined | null = undefined;\nconst isTZIDSep = Object.assign(Object.create(null), { '/': true, '-': true, _: true });\n\nexport function GetAvailableNamedTimeZoneIdentifier(\n  identifier: string\n): { identifier: string; primaryIdentifier: string } | undefined {\n  // The most common case is when the identifier is a canonical time zone ID.\n  // Fast-path that case by caching all canonical IDs. For old ECMAScript\n  // implementations lacking this API, set the cache to `null` to avoid retries.\n  if (canonicalTimeZoneIdsCache === undefined) {\n    const canonicalTimeZoneIds = Intl.supportedValuesOf?.('timeZone');\n    if (canonicalTimeZoneIds) {\n      canonicalTimeZoneIdsCache = new Map();\n      for (let ix = 0; ix < canonicalTimeZoneIds.length; ix++) {\n        const id = canonicalTimeZoneIds[ix];\n        canonicalTimeZoneIdsCache.set(ASCIILowercase(id), id);\n      }\n    } else {\n      canonicalTimeZoneIdsCache = null;\n    }\n  }\n\n  const lower = ASCIILowercase(identifier);\n  let primaryIdentifier = canonicalTimeZoneIdsCache?.get(lower);\n  if (primaryIdentifier) return { identifier: primaryIdentifier, primaryIdentifier };\n\n  // It's not already a primary identifier, so get its primary identifier (or\n  // return if it's not an available named time zone ID).\n  try {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(identifier);\n    primaryIdentifier = formatter.resolvedOptions().timeZone;\n  } catch {\n    return undefined;\n  }\n\n  // Special case this legacy identifier that is listed both in `backzone` and\n  // `backward` in the TZDB. Work around implementations that incorrectly use\n  // the `backward` data.\n  if (lower === 'antarctica/south_pole') primaryIdentifier = 'Antarctica/McMurdo';\n\n  // Some legacy identifiers are aliases in ICU but not legal IANA identifiers.\n  // Reject them even if the implementation's Intl supports them, as they are\n  // not present in the IANA time zone database.\n  if (ICU_LEGACY_TIME_ZONE_IDS.has(identifier)) {\n    throw new RangeError(`${identifier} is a legacy time zone identifier from ICU. Use ${primaryIdentifier} instead`);\n  }\n\n  // The identifier is an alias (a deprecated identifier that's a synonym for a\n  // primary identifier), so we need to case-normalize the identifier to match\n  // the IANA TZDB, e.g. america/new_york => America/New_York. There's no\n  // built-in way to do this using Intl.DateTimeFormat, but the we can normalize\n  // almost all aliases (modulo a few special cases) using the TZDB's basic\n  // capitalization pattern:\n  // 1. capitalize the first letter of the identifier\n  // 2. capitalize the letter after every slash, dash, or underscore delimiter\n  const chars = [...lower].map((c, i) => (i === 0 || isTZIDSep[lower[i - 1]] ? c.toUpperCase() : c));\n  const standardCase = chars.join('');\n  const segments = standardCase.split('/');\n\n  if (segments.length === 1) {\n    // If a single-segment legacy ID is 2-3 chars or contains a number or dash, then\n    // (except for the \"GB-Eire\" special case) the case-normalized form is uppercase.\n    // These are: GMT+0, GMT-0, GB, NZ, PRC, ROC, ROK, UCT, GMT, GMT0, CET, CST6CDT,\n    // EET, EST, HST, MET, MST, MST7MDT, PST8PDT, WET, NZ-CHAT, and W-SU.\n    // Otherwise it's standard form: first letter capitalized, e.g. Iran, Egypt, Hongkong\n    if (lower === 'gb-eire') return { identifier: 'GB-Eire', primaryIdentifier };\n    return {\n      identifier: lower.length <= 3 || /[-0-9]/.test(lower) ? lower.toUpperCase() : segments[0],\n      primaryIdentifier\n    };\n  }\n\n  // All Etc zone names are uppercase except three exceptions.\n  if (segments[0] === 'Etc') {\n    const etcName = ['Zulu', 'Greenwich', 'Universal'].includes(segments[1]) ? segments[1] : segments[1].toUpperCase();\n    return { identifier: `Etc/${etcName}`, primaryIdentifier };\n  }\n\n  // Legacy US identifiers like US/Alaska or US/Indiana-Starke are 2 segments and use standard form.\n  if (segments[0] === 'Us') return { identifier: `US/${segments[1]}`, primaryIdentifier };\n\n  // For multi-segment IDs, there's a few special cases in the second/third segments\n  const specialCases = new Map([\n    ['Act', 'ACT'],\n    ['Lhi', 'LHI'],\n    ['Nsw', 'NSW'],\n    ['Dar_Es_Salaam', 'Dar_es_Salaam'],\n    ['Port_Of_Spain', 'Port_of_Spain'],\n    ['Port-Au-Prince', 'Port-au-Prince'],\n    ['Isle_Of_Man', 'Isle_of_Man'],\n    ['Comodrivadavia', 'ComodRivadavia'],\n    ['Knox_In', 'Knox_IN'],\n    ['Dumontdurville', 'DumontDUrville'],\n    ['Mcmurdo', 'McMurdo'],\n    ['Denoronha', 'DeNoronha'],\n    ['Easterisland', 'EasterIsland'],\n    ['Bajanorte', 'BajaNorte'],\n    ['Bajasur', 'BajaSur']\n  ]);\n  segments[1] = specialCases.get(segments[1]) ?? segments[1];\n  if (segments.length > 2) segments[2] = specialCases.get(segments[2]) ?? segments[2];\n  return { identifier: segments.join('/'), primaryIdentifier };\n}\n\nfunction GetNamedTimeZoneOffsetNanosecondsImpl(id: string, epochMilliseconds: number) {\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  let millisecond = epochMilliseconds % 1000;\n  if (millisecond < 0) millisecond += 1000;\n  const utc = GetUTCEpochMilliseconds({ isoDate: { year, month, day }, time: { hour, minute, second, millisecond } });\n  return (utc - epochMilliseconds) * 1e6;\n}\n\nfunction GetNamedTimeZoneOffsetNanoseconds(id: string, epochNanoseconds: JSBI) {\n  // Optimization: We get the offset nanoseconds only with millisecond\n  // resolution, assuming that time zone offset changes don't happen in the\n  // middle of a millisecond\n  return GetNamedTimeZoneOffsetNanosecondsImpl(id, epochNsToMs(epochNanoseconds, 'floor'));\n}\n\nexport function FormatOffsetTimeZoneIdentifier(offsetMinutes: number): string {\n  const sign = offsetMinutes < 0 ? '-' : '+';\n  const absoluteMinutes = Math.abs(offsetMinutes);\n  const hour = Math.floor(absoluteMinutes / 60);\n  const minute = absoluteMinutes % 60;\n  const timeString = FormatTimeString(hour, minute, 0, 0, 'minute');\n  return `${sign}${timeString}`;\n}\n\nfunction FormatDateTimeUTCOffsetRounded(offsetNanosecondsParam: number): string {\n  const offsetNanoseconds = RoundNumberToIncrement(offsetNanosecondsParam, MINUTE_NANOS, 'halfExpand');\n  return FormatOffsetTimeZoneIdentifier(offsetNanoseconds / 60e9);\n}\n\nfunction GetUTCEpochMilliseconds({\n  isoDate: { year, month, day },\n  time: { hour, minute, second, millisecond }\n}: {\n  isoDate: ISODate;\n  time: Omit<TimeRecord, 'microsecond' | 'nanosecond'>;\n}) {\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. To avoid overflowing at the edges of the range, we reduce the year\n  // to the remainder after dividing by 400, and then add back all the\n  // nanoseconds from the multiples of 400 years at the end.\n  const reducedYear = year % 400;\n  const yearCycles = (year - reducedYear) / 400;\n\n  // Note: Date.UTC() interprets one and two-digit years as being in the\n  // 20th century, so don't use it\n  const legacyDate = new Date();\n  legacyDate.setUTCHours(hour, minute, second, millisecond);\n  legacyDate.setUTCFullYear(reducedYear, month - 1, day);\n  const ms = legacyDate.getTime();\n  return ms + MS_IN_400_YEAR_CYCLE * yearCycles;\n}\n\nfunction GetUTCEpochNanoseconds(isoDateTime: ISODateTime) {\n  const ms = GetUTCEpochMilliseconds(isoDateTime);\n  const subMs = isoDateTime.time.microsecond * 1e3 + isoDateTime.time.nanosecond;\n  return JSBI.add(epochMsToNs(ms), JSBI.BigInt(subMs));\n}\n\nfunction GetISOPartsFromEpoch(epochNanoseconds: JSBI) {\n  let epochMilliseconds = epochNsToMs(epochNanoseconds, 'trunc');\n  let nanos = JSBI.toNumber(JSBI.remainder(epochNanoseconds, MILLION));\n  if (nanos < 0) {\n    nanos += 1e6;\n    epochMilliseconds -= 1;\n  }\n  const microsecond = Math.floor(nanos / 1e3) % 1e3;\n  const nanosecond = nanos % 1e3;\n\n  const item = new Date(epochMilliseconds);\n  const year = item.getUTCFullYear();\n  const month = item.getUTCMonth() + 1;\n  const day = item.getUTCDate();\n  const hour = item.getUTCHours();\n  const minute = item.getUTCMinutes();\n  const second = item.getUTCSeconds();\n  const millisecond = item.getUTCMilliseconds();\n\n  return {\n    epochMilliseconds,\n    isoDate: { year, month, day },\n    time: { hour, minute, second, millisecond, microsecond, nanosecond }\n  };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetNamedTimeZoneDateTimeParts(id: string, epochNanoseconds: JSBI) {\n  const {\n    epochMilliseconds,\n    time: { millisecond, microsecond, nanosecond }\n  } = GetISOPartsFromEpoch(epochNanoseconds);\n  const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n  return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function GetNamedTimeZoneNextTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (id === 'UTC') return null; // UTC fast path\n\n  // Optimization: we floor the instant to the previous millisecond boundary\n  // so that we can do Number math instead of BigInt math. This assumes that\n  // time zone transitions don't happen in the middle of a millisecond.\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'floor');\n  if (epochMilliseconds < BEFORE_FIRST_DST) {\n    return GetNamedTimeZoneNextTransition(id, epochMsToNs(BEFORE_FIRST_DST));\n  }\n\n  // Optimization: the farthest that we'll look for a next transition is 3 years\n  // after the later of epochNanoseconds or the current time. If there are no\n  // transitions found before then, we'll assume that there will not be any more\n  // transitions after that.\n  const now = Date.now();\n  const base = Math.max(epochMilliseconds, now);\n  const uppercap = base + DAY_MS * 366 * 3;\n  let leftMs = epochMilliseconds;\n  let leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\n  let rightMs = leftMs;\n  let rightOffsetNs = leftOffsetNs;\n  while (leftOffsetNs === rightOffsetNs && leftMs < uppercap) {\n    rightMs = leftMs + DAY_MS * 2 * 7;\n    if (rightMs > MS_MAX) return null;\n    rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\n    if (leftOffsetNs === rightOffsetNs) {\n      leftMs = rightMs;\n    }\n  }\n  if (leftOffsetNs === rightOffsetNs) return null;\n  const result = bisect(\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\n    leftMs,\n    rightMs,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return epochMsToNs(result);\n}\n\nexport function GetNamedTimeZonePreviousTransition(id: string, epochNanoseconds: JSBI): JSBI | null {\n  if (id === 'UTC') return null; // UTC fast path\n\n  // Optimization: we raise the instant to the next millisecond boundary so\n  // that we can do Number math instead of BigInt math. This assumes that time\n  // zone transitions don't happen in the middle of a millisecond.\n  const epochMilliseconds = epochNsToMs(epochNanoseconds, 'ceil');\n\n  // Optimization: if the instant is more than 3 years in the future and there\n  // are no transitions between the present day and 3 years from now, assume\n  // there are none after.\n  const now = Date.now();\n  const lookahead = now + DAY_MS * 366 * 3;\n  if (epochMilliseconds > lookahead) {\n    const prevBeforeLookahead = GetNamedTimeZonePreviousTransition(id, epochMsToNs(lookahead));\n    if (prevBeforeLookahead === null || JSBI.lessThan(prevBeforeLookahead, epochMsToNs(now))) {\n      return prevBeforeLookahead;\n    }\n  }\n\n  // We assume most time zones either have regular DST rules that extend\n  // indefinitely into the future, or they have no DST transitions between now\n  // and next year. Africa/Casablanca and Africa/El_Aaiun are unique cases\n  // that fit neither of these. Their irregular DST transitions are\n  // precomputed until 2087 in the current time zone database, so requesting\n  // the previous transition for an instant far in the future may take an\n  // extremely long time as it loops backward 2 weeks at a time.\n  if (id === 'Africa/Casablanca' || id === 'Africa/El_Aaiun') {\n    const lastPrecomputed = Date.UTC(2088, 0, 1); // 2088-01-01T00Z\n    if (lastPrecomputed < epochMilliseconds) {\n      return GetNamedTimeZonePreviousTransition(id, epochMsToNs(lastPrecomputed));\n    }\n  }\n\n  let rightMs = epochMilliseconds - 1;\n  if (rightMs < BEFORE_FIRST_DST) return null;\n  let rightOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, rightMs);\n  let leftMs = rightMs;\n  let leftOffsetNs = rightOffsetNs;\n  while (rightOffsetNs === leftOffsetNs && rightMs > BEFORE_FIRST_DST) {\n    leftMs = rightMs - DAY_MS * 2 * 7;\n    if (leftMs < BEFORE_FIRST_DST) return null;\n    leftOffsetNs = GetNamedTimeZoneOffsetNanosecondsImpl(id, leftMs);\n    if (rightOffsetNs === leftOffsetNs) {\n      rightMs = leftMs;\n    }\n  }\n  if (rightOffsetNs === leftOffsetNs) return null;\n  const result = bisect(\n    (epochMs: number) => GetNamedTimeZoneOffsetNanosecondsImpl(id, epochMs),\n    leftMs,\n    rightMs,\n    leftOffsetNs,\n    rightOffsetNs\n  );\n  return epochMsToNs(result);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime: string) {\n  const splits = datetime.split(/[^\\w]+/);\n\n  if (splits.length !== 7) {\n    throw new RangeError(`expected 7 parts in \"${datetime}`);\n  }\n\n  const month = +splits[0];\n  const day = +splits[1];\n  let year = +splits[2];\n  const era = splits[3];\n  if (era[0] === 'b' || era[0] === 'B') {\n    year = -year + 1;\n  } else if (era[0] !== 'a' && era[0] !== 'A') {\n    throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n  }\n  const hour = splits[4] === '24' ? 0 : +splits[4]; // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n  const minute = +splits[5];\n  const second = +splits[6];\n\n  if (\n    !Number.isFinite(year) ||\n    !Number.isFinite(month) ||\n    !Number.isFinite(day) ||\n    !Number.isFinite(hour) ||\n    !Number.isFinite(minute) ||\n    !Number.isFinite(second)\n  ) {\n    throw new RangeError(`Invalid number in \"${datetime}`);\n  }\n\n  return { year, month, day, hour, minute, second };\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone: string, epochMilliseconds: number) {\n  const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n  // Using `format` instead of `formatToParts` for compatibility with older\n  // clients and because it is twice as fast\n  const datetime = formatter.format(epochMilliseconds);\n  return parseFromEnUsFormat(datetime);\n}\n\n// The goal of this function is to find the exact time(s) that correspond to a\n// calendar date and clock time in a particular time zone. Normally there will\n// be only one match. But for repeated clock times after backwards transitions\n// (like when DST ends) there may be two matches. And for skipped clock times\n// after forward transitions, there will be no matches.\nfunction GetNamedTimeZoneEpochNanoseconds(id: string, isoDateTime: ISODateTime) {\n  // Get the offset of one day before and after the requested calendar date and\n  // clock time, avoiding overflows if near the edge of the Instant range.\n  let ns = GetUTCEpochNanoseconds(isoDateTime);\n  let nsEarlier = JSBI.subtract(ns, DAY_NANOS_JSBI);\n  if (JSBI.lessThan(nsEarlier, NS_MIN)) nsEarlier = ns;\n  let nsLater = JSBI.add(ns, DAY_NANOS_JSBI);\n  if (JSBI.greaterThan(nsLater, NS_MAX)) nsLater = ns;\n  const earlierOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsEarlier);\n  const laterOffsetNs = GetNamedTimeZoneOffsetNanoseconds(id, nsLater);\n\n  // If before and after offsets are the same, then we assume there was no\n  // offset transition in between, and therefore only one exact time can\n  // correspond to the provided calendar date and clock time. But if they're\n  // different, then there was an offset transition in between, so test both\n  // offsets to see which one(s) will yield a matching exact time.\n  const found = earlierOffsetNs === laterOffsetNs ? [earlierOffsetNs] : [earlierOffsetNs, laterOffsetNs];\n  const candidates = found.map((offsetNanoseconds) => {\n    const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n    const parts = GetNamedTimeZoneDateTimeParts(id, epochNanoseconds);\n    if (CompareISODateTime(isoDateTime, parts) !== 0) return undefined;\n    ValidateEpochNanoseconds(epochNanoseconds);\n    return epochNanoseconds;\n  });\n  return candidates.filter((x) => x !== undefined) as JSBI[];\n}\n\nexport function LeapYear(year: number) {\n  if (undefined === year) return false;\n  const isDiv4 = year % 4 === 0;\n  const isDiv100 = year % 100 === 0;\n  const isDiv400 = year % 400 === 0;\n  return isDiv4 && (!isDiv100 || isDiv400);\n}\n\nexport function ISODaysInMonth(year: number, month: number) {\n  const DoM = {\n    standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n    leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n  };\n  return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\n\nexport function DurationSign(duration: Temporal.Duration) {\n  const fields = [\n    GetSlot(duration, YEARS),\n    GetSlot(duration, MONTHS),\n    GetSlot(duration, WEEKS),\n    GetSlot(duration, DAYS),\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  ];\n  for (let index = 0; index < fields.length; index++) {\n    const prop = fields[index];\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction DateDurationSign(dateDuration: DateDuration) {\n  const fieldNames = ['years', 'months', 'weeks', 'days'] as const;\n  for (let index = 0; index < fieldNames.length; index++) {\n    const prop = dateDuration[fieldNames[index]];\n    if (prop !== 0) return prop < 0 ? -1 : 1;\n  }\n  return 0;\n}\n\nfunction InternalDurationSign(duration: InternalDuration) {\n  const dateSign = DateDurationSign(duration.date);\n  if (dateSign !== 0) return dateSign;\n  return duration.time.sign();\n}\n\nexport function BalanceISOYearMonth(yearParam: number, monthParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  if (!Number.isFinite(year) || !Number.isFinite(month)) throw new RangeError('infinity is out of range');\n  month -= 1;\n  year += Math.floor(month / 12);\n  month %= 12;\n  if (month < 0) month += 12;\n  month += 1;\n  return { year, month };\n}\n\nexport function BalanceISODate(yearParam: number, monthParam: number, dayParam: number) {\n  let year = yearParam;\n  let month = monthParam;\n  let day = dayParam;\n  if (!Number.isFinite(day)) throw new RangeError('infinity is out of range');\n  ({ year, month } = BalanceISOYearMonth(year, month));\n\n  // The pattern of leap years in the ISO 8601 calendar repeats every 400\n  // years. So if we have more than 400 years in days, there's no need to\n  // convert days to a year 400 times. We can convert a multiple of 400 all at\n  // once.\n  const daysIn400YearCycle = 400 * 365 + 97;\n  if (Math.abs(day) > daysIn400YearCycle) {\n    const nCycles = Math.trunc(day / daysIn400YearCycle);\n    year += 400 * nCycles;\n    day -= nCycles * daysIn400YearCycle;\n  }\n\n  let daysInYear = 0;\n  let testYear = month > 2 ? year : year - 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n    year -= 1;\n    testYear -= 1;\n    day += daysInYear;\n  }\n  testYear += 1;\n  while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n    year += 1;\n    testYear += 1;\n    day -= daysInYear;\n  }\n\n  while (day < 1) {\n    ({ year, month } = BalanceISOYearMonth(year, month - 1));\n    day += ISODaysInMonth(year, month);\n  }\n  while (day > ISODaysInMonth(year, month)) {\n    day -= ISODaysInMonth(year, month);\n    ({ year, month } = BalanceISOYearMonth(year, month + 1));\n  }\n\n  return { year, month, day };\n}\n\nfunction BalanceISODateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  const time = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nfunction BalanceTime(\n  hourParam: number,\n  minuteParam: number,\n  secondParam: number,\n  millisecondParam: number,\n  microsecondParam: number,\n  nanosecondParam: number\n) {\n  let hour = hourParam;\n  let minute = minuteParam;\n  let second = secondParam;\n  let millisecond = millisecondParam;\n  let microsecond = microsecondParam;\n  let nanosecond = nanosecondParam;\n  let div;\n\n  ({ div, mod: nanosecond } = TruncatingDivModByPowerOf10(nanosecond, 3));\n  microsecond += div;\n  if (nanosecond < 0) {\n    microsecond -= 1;\n    nanosecond += 1000;\n  }\n\n  ({ div, mod: microsecond } = TruncatingDivModByPowerOf10(microsecond, 3));\n  millisecond += div;\n  if (microsecond < 0) {\n    millisecond -= 1;\n    microsecond += 1000;\n  }\n\n  second += Math.trunc(millisecond / 1000);\n  millisecond %= 1000;\n  if (millisecond < 0) {\n    second -= 1;\n    millisecond += 1000;\n  }\n\n  minute += Math.trunc(second / 60);\n  second %= 60;\n  if (second < 0) {\n    minute -= 1;\n    second += 60;\n  }\n\n  hour += Math.trunc(minute / 60);\n  minute %= 60;\n  if (minute < 0) {\n    hour -= 1;\n    minute += 60;\n  }\n\n  let deltaDays = Math.trunc(hour / 24);\n  hour %= 24;\n  if (hour < 0) {\n    deltaDays -= 1;\n    hour += 24;\n  }\n\n  // Results are possibly -0 at this point, but these are mathematical values in\n  // the spec. Force -0 to +0.\n  deltaDays += 0;\n  hour += 0;\n  minute += 0;\n  second += 0;\n  millisecond += 0;\n  microsecond += 0;\n  nanosecond += 0;\n\n  return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n\nexport function DateDurationDays(dateDuration: DateDuration, plainRelativeTo: Temporal.PlainDate) {\n  const yearsMonthsWeeksDuration = AdjustDateDurationRecord(dateDuration, 0);\n  if (DateDurationSign(yearsMonthsWeeksDuration) === 0) return dateDuration.days;\n\n  // balance years, months, and weeks down to days\n  const isoDate = GetSlot(plainRelativeTo, ISO_DATE);\n  const later = CalendarDateAdd(GetSlot(plainRelativeTo, CALENDAR), isoDate, yearsMonthsWeeksDuration, 'constrain');\n  const epochDaysEarlier = ISODateToEpochDays(isoDate.year, isoDate.month - 1, isoDate.day);\n  const epochDaysLater = ISODateToEpochDays(later.year, later.month - 1, later.day);\n  const yearsMonthsWeeksInDays = epochDaysLater - epochDaysEarlier;\n  return dateDuration.days + yearsMonthsWeeksInDays;\n}\n\nexport function CreateNegatedTemporalDuration(duration: Temporal.Duration) {\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    -GetSlot(duration, YEARS),\n    -GetSlot(duration, MONTHS),\n    -GetSlot(duration, WEEKS),\n    -GetSlot(duration, DAYS),\n    -GetSlot(duration, HOURS),\n    -GetSlot(duration, MINUTES),\n    -GetSlot(duration, SECONDS),\n    -GetSlot(duration, MILLISECONDS),\n    -GetSlot(duration, MICROSECONDS),\n    -GetSlot(duration, NANOSECONDS)\n  );\n}\n\nexport function ConstrainToRange(value: number | undefined, min: number, max: number) {\n  // Math.Max accepts undefined values and returns NaN. Undefined values are\n  // used for optional params in the method below.\n  return Math.min(max, Math.max(min, value as number));\n}\nexport function ConstrainISODate(year: number, monthParam: number, dayParam?: number) {\n  const month = ConstrainToRange(monthParam, 1, 12);\n  const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n  return { year, month, day };\n}\n\nexport function RejectToRange(value: number, min: number, max: number) {\n  if (value < min || value > max) throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\n\nexport function RejectISODate(year: number, month: number, day: number) {\n  RejectToRange(month, 1, 12);\n  RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\n\nfunction RejectDateRange(isoDate: ISODate) {\n  // Noon avoids trouble at edges of DateTime range (excludes midnight)\n  RejectDateTimeRange(CombineISODateAndTimeRecord(isoDate, NoonTimeRecord()));\n}\n\nexport function RejectTime(\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectToRange(hour, 0, 23);\n  RejectToRange(minute, 0, 59);\n  RejectToRange(second, 0, 59);\n  RejectToRange(millisecond, 0, 999);\n  RejectToRange(microsecond, 0, 999);\n  RejectToRange(nanosecond, 0, 999);\n}\n\nexport function RejectDateTime(\n  year: number,\n  month: number,\n  day: number,\n  hour: number,\n  minute: number,\n  second: number,\n  millisecond: number,\n  microsecond: number,\n  nanosecond: number\n) {\n  RejectISODate(year, month, day);\n  RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nexport function RejectDateTimeRange(isoDateTime: ISODateTime) {\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\n  if (JSBI.lessThan(ns, DATETIME_NS_MIN) || JSBI.greaterThan(ns, DATETIME_NS_MAX)) {\n    // Because PlainDateTime's range is wider than Instant's range, the line\n    // below will always throw. Calling `ValidateEpochNanoseconds` avoids\n    // repeating the same error message twice.\n    ValidateEpochNanoseconds(ns);\n  }\n}\n\n// Same as above, but throws a different, non-user-facing error\nfunction AssertISODateTimeWithinLimits(isoDateTime: ISODateTime) {\n  const ns = GetUTCEpochNanoseconds(isoDateTime);\n  assert(\n    JSBI.greaterThanOrEqual(ns, DATETIME_NS_MIN) && JSBI.lessThanOrEqual(ns, DATETIME_NS_MAX),\n    `${ISODateTimeToString(isoDateTime, 'iso8601', 'auto')} is outside the representable range`\n  );\n}\n\n// In the spec, IsValidEpochNanoseconds returns a boolean and call sites are\n// responsible for throwing. In the polyfill, ValidateEpochNanoseconds takes its\n// place so that we can DRY the throwing code.\nfunction ValidateEpochNanoseconds(epochNanoseconds: JSBI) {\n  if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n    throw new RangeError('date/time value is outside of supported range');\n  }\n}\n\nfunction RejectYearMonthRange({ year, month }: Omit<ISODate, 'day'>) {\n  RejectToRange(year, YEAR_MIN, YEAR_MAX);\n  if (year === YEAR_MIN) {\n    RejectToRange(month, 4, 12);\n  } else if (year === YEAR_MAX) {\n    RejectToRange(month, 1, 9);\n  }\n}\n\nexport function RejectDuration(\n  y: number,\n  mon: number,\n  w: number,\n  d: number,\n  h: number,\n  min: number,\n  s: number,\n  ms: number,\n  µs: number,\n  ns: number\n) {\n  let sign: -1 | 0 | 1 = 0;\n  const fields = [y, mon, w, d, h, min, s, ms, µs, ns];\n  for (let index = 0; index < fields.length; index++) {\n    const prop = fields[index];\n    if (prop === Infinity || prop === -Infinity) throw new RangeError('infinite values not allowed as duration fields');\n    if (prop !== 0) {\n      const propSign = prop < 0 ? -1 : 1;\n      if (sign !== 0 && propSign !== sign) throw new RangeError('mixed-sign values not allowed as duration fields');\n      sign = propSign;\n    }\n  }\n  if (Math.abs(y) >= 2 ** 32 || Math.abs(mon) >= 2 ** 32 || Math.abs(w) >= 2 ** 32) {\n    throw new RangeError('years, months, and weeks must be < 2³²');\n  }\n  const msResult = TruncatingDivModByPowerOf10(ms, 3);\n  const µsResult = TruncatingDivModByPowerOf10(µs, 6);\n  const nsResult = TruncatingDivModByPowerOf10(ns, 9);\n  const remainderSec = TruncatingDivModByPowerOf10(msResult.mod * 1e6 + µsResult.mod * 1e3 + nsResult.mod, 9).div;\n  const totalSec = d * 86400 + h * 3600 + min * 60 + s + msResult.div + µsResult.div + nsResult.div + remainderSec;\n  if (!Number.isSafeInteger(totalSec)) {\n    throw new RangeError('total of duration time units cannot exceed 9007199254740991.999999999 s');\n  }\n}\n\nexport function ToInternalDurationRecord(duration: Temporal.Duration) {\n  const date = {\n    years: GetSlot(duration, YEARS),\n    months: GetSlot(duration, MONTHS),\n    weeks: GetSlot(duration, WEEKS),\n    days: GetSlot(duration, DAYS)\n  };\n  const time = TimeDuration.fromComponents(\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  );\n  return { date, time };\n}\n\nexport function ToInternalDurationRecordWith24HourDays(duration: Temporal.Duration) {\n  const time = TimeDuration.fromComponents(\n    GetSlot(duration, HOURS),\n    GetSlot(duration, MINUTES),\n    GetSlot(duration, SECONDS),\n    GetSlot(duration, MILLISECONDS),\n    GetSlot(duration, MICROSECONDS),\n    GetSlot(duration, NANOSECONDS)\n  ).add24HourDays(GetSlot(duration, DAYS));\n  const date = {\n    years: GetSlot(duration, YEARS),\n    months: GetSlot(duration, MONTHS),\n    weeks: GetSlot(duration, WEEKS),\n    days: 0\n  };\n  return { date, time };\n}\n\nfunction ToDateDurationRecordWithoutTime(duration: Temporal.Duration) {\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const days = Math.trunc(internalDuration.time.sec / 86400);\n  RejectDuration(\n    internalDuration.date.years,\n    internalDuration.date.months,\n    internalDuration.date.weeks,\n    days,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n  );\n  return { ...internalDuration.date, days };\n}\n\nexport function TemporalDurationFromInternal(internalDuration: InternalDuration, largestUnit: Temporal.DateTimeUnit) {\n  const sign = internalDuration.time.sign();\n  let nanoseconds = internalDuration.time.abs().subsec;\n  let microseconds = 0;\n  let milliseconds = 0;\n  let seconds = internalDuration.time.abs().sec;\n  let minutes = 0;\n  let hours = 0;\n  let days = 0;\n\n  switch (largestUnit) {\n    case 'year':\n    case 'month':\n    case 'week':\n    case 'day':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      hours = Math.trunc(minutes / 60);\n      minutes %= 60;\n      days = Math.trunc(hours / 24);\n      hours %= 24;\n      break;\n    case 'hour':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      hours = Math.trunc(minutes / 60);\n      minutes %= 60;\n      break;\n    case 'minute':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      minutes = Math.trunc(seconds / 60);\n      seconds %= 60;\n      break;\n    case 'second':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = Math.trunc(microseconds / 1000);\n      microseconds %= 1000;\n      seconds += Math.trunc(milliseconds / 1000);\n      milliseconds %= 1000;\n      break;\n    case 'millisecond':\n      microseconds = Math.trunc(nanoseconds / 1000);\n      nanoseconds %= 1000;\n      milliseconds = FMAPowerOf10(seconds, 3, Math.trunc(microseconds / 1000));\n      microseconds %= 1000;\n      seconds = 0;\n      break;\n    case 'microsecond':\n      microseconds = FMAPowerOf10(seconds, 6, Math.trunc(nanoseconds / 1000));\n      nanoseconds %= 1000;\n      seconds = 0;\n      break;\n    case 'nanosecond':\n      nanoseconds = FMAPowerOf10(seconds, 9, nanoseconds);\n      seconds = 0;\n      break;\n    default:\n      /* c8 ignore next */ assertNotReached();\n  }\n\n  const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n  return new TemporalDuration(\n    internalDuration.date.years,\n    internalDuration.date.months,\n    internalDuration.date.weeks,\n    internalDuration.date.days + sign * days,\n    sign * hours,\n    sign * minutes,\n    sign * seconds,\n    sign * milliseconds,\n    sign * microseconds,\n    sign * nanoseconds\n  );\n}\n\nexport function CombineDateAndTimeDuration(dateDuration: DateDuration, timeDuration: TimeDuration) {\n  const dateSign = DateDurationSign(dateDuration);\n  const timeSign = timeDuration.sign();\n  assert(\n    dateSign === 0 || timeSign === 0 || dateSign === timeSign,\n    'should not be able to create mixed sign duration fields here'\n  );\n  return { date: dateDuration, time: timeDuration };\n}\n\n// Caution: month is 0-based\nexport function ISODateToEpochDays(year: number, month: number, day: number) {\n  return (\n    GetUTCEpochMilliseconds({\n      isoDate: { year, month: month + 1, day },\n      time: { hour: 0, minute: 0, second: 0, millisecond: 0 }\n    }) / DAY_MS\n  );\n}\n\n// This is needed before calling GetUTCEpochNanoseconds, because it uses MakeDay\n// which is ill-defined in how it handles large year numbers. If the issue\n// https://github.com/tc39/ecma262/issues/1087 is fixed, this can be removed\n// with no observable changes.\nfunction CheckISODaysRange({ year, month, day }: ISODate) {\n  if (Math.abs(ISODateToEpochDays(year, month - 1, day)) > 1e8) {\n    throw new RangeError('date/time value is outside the supported range');\n  }\n}\n\nfunction DifferenceTime(time1: TimeRecord, time2: TimeRecord) {\n  const hours = time2.hour - time1.hour;\n  const minutes = time2.minute - time1.minute;\n  const seconds = time2.second - time1.second;\n  const milliseconds = time2.millisecond - time1.millisecond;\n  const microseconds = time2.microsecond - time1.microsecond;\n  const nanoseconds = time2.nanosecond - time1.nanosecond;\n  const timeDuration = TimeDuration.fromComponents(hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  assert(timeDuration.abs().sec < 86400, '_bt_.[[Days]] should be 0');\n  return timeDuration;\n}\n\nfunction DifferenceInstant(\n  ns1: JSBI,\n  ns2: JSBI,\n  increment: number,\n  smallestUnit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let timeDuration = TimeDuration.fromEpochNsDiff(ns2, ns1);\n  timeDuration = RoundTimeDuration(timeDuration, increment, smallestUnit, roundingMode);\n  return CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\n}\n\nfunction DifferenceISODateTime(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit\n) {\n  AssertISODateTimeWithinLimits(isoDateTime1);\n  AssertISODateTimeWithinLimits(isoDateTime2);\n  let timeDuration = DifferenceTime(isoDateTime1.time, isoDateTime2.time);\n\n  const timeSign = timeDuration.sign();\n  const dateSign = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\n\n  // back-off a day from date2 so that the signs of the date and time diff match\n  let adjustedDate = isoDateTime2.isoDate;\n  if (dateSign === timeSign) {\n    adjustedDate = BalanceISODate(adjustedDate.year, adjustedDate.month, adjustedDate.day + timeSign);\n    timeDuration = timeDuration.add24HourDays(-timeSign);\n  }\n\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n  const dateDifference = CalendarDateUntil(calendar, isoDateTime1.isoDate, adjustedDate, dateLargestUnit);\n  if (largestUnit !== dateLargestUnit) {\n    // largestUnit < days, so add the days in to the internal duration\n    timeDuration = timeDuration.add24HourDays(dateDifference.days);\n    dateDifference.days = 0;\n  }\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\n}\n\nfunction DifferenceZonedDateTime(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit\n) {\n  const nsDiff = JSBI.subtract(ns2, ns1);\n  if (JSBI.equal(nsDiff, ZERO)) return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\n  const sign = JSBI.lessThan(nsDiff, ZERO) ? -1 : 1;\n\n  // Convert start/end instants to datetimes\n  const isoDtStart = GetISODateTimeFor(timeZone, ns1);\n  const isoDtEnd = GetISODateTimeFor(timeZone, ns2);\n\n  // Simulate moving ns1 as many years/months/weeks/days as possible without\n  // surpassing ns2. This value is stored in intermediateDateTime/intermediateInstant/intermediateNs.\n  // We do not literally move years/months/weeks/days with calendar arithmetic,\n  // but rather assume intermediateDateTime will have the same time-parts as\n  // dtStart and the date-parts from dtEnd, and move backward from there.\n  // The number of days we move backward is stored in dayCorrection.\n  // Credit to Adam Shaw for devising this algorithm.\n  let dayCorrection = 0;\n  let intermediateDateTime: ISODateTime | undefined;\n\n  // The max number of allowed day corrections depends on the direction of travel.\n  // Both directions allow for 1 day correction due to an ISO wall-clock overshoot (see below).\n  // Only the forward direction allows for an additional 1 day correction caused by a push-forward\n  // 'compatible' DST transition causing the wall-clock to overshoot again.\n  // This max value is inclusive.\n  let maxDayCorrection = sign === 1 ? 2 : 1;\n\n  // Detect ISO wall-clock overshoot.\n  // If the diff of the ISO wall-clock times is opposite to the overall diff's sign,\n  // we are guaranteed to need at least one day correction.\n  let timeDuration = DifferenceTime(isoDtStart.time, isoDtEnd.time);\n  if (timeDuration.sign() === -sign) {\n    dayCorrection++;\n  }\n\n  for (; dayCorrection <= maxDayCorrection; dayCorrection++) {\n    const intermediateDate = BalanceISODate(\n      isoDtEnd.isoDate.year,\n      isoDtEnd.isoDate.month,\n      isoDtEnd.isoDate.day - dayCorrection * sign\n    );\n\n    // Incorporate time parts from dtStart\n    intermediateDateTime = CombineISODateAndTimeRecord(intermediateDate, isoDtStart.time);\n\n    // Convert intermediate datetime to epoch-nanoseconds (may disambiguate)\n    const intermediateNs = GetEpochNanosecondsFor(timeZone, intermediateDateTime, 'compatible');\n\n    // Compute the nanosecond diff between the intermediate instant and the final destination\n    timeDuration = TimeDuration.fromEpochNsDiff(ns2, intermediateNs);\n\n    // Did intermediateNs NOT surpass ns2?\n    // If so, exit the loop with success (without incrementing dayCorrection past maxDayCorrection)\n    if (timeDuration.sign() !== -sign) {\n      break;\n    }\n  }\n\n  assert(dayCorrection <= maxDayCorrection, `more than ${maxDayCorrection} day correction needed`);\n\n  // Output of the above loop\n  assertExists(intermediateDateTime);\n\n  // Similar to what happens in DifferenceISODateTime with date parts only:\n  const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit) as Temporal.DateUnit;\n  const dateDifference = CalendarDateUntil(calendar, isoDtStart.isoDate, intermediateDateTime.isoDate, dateLargestUnit);\n  return CombineDateAndTimeDuration(dateDifference, timeDuration);\n}\n\n// Epoch-nanosecond bounding technique where the start/end of the calendar-unit\n// interval are converted to epoch-nanosecond times and destEpochNs is nudged to\n// either one.\nfunction NudgeToCalendarUnit(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  increment: number,\n  unit: Temporal.DateUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be day, week, month, or year\n  // timeZone may be undefined\n  let duration = durationParam;\n\n  // Create a duration with smallestUnit trunc'd towards zero\n  // Create a separate duration that incorporates roundingIncrement\n  let r1, r2, startDuration, endDuration;\n  switch (unit) {\n    case 'year': {\n      const years = RoundNumberToIncrement(duration.date.years, increment, 'trunc');\n      r1 = years;\n      r2 = years + increment * sign;\n      startDuration = { years: r1, months: 0, weeks: 0, days: 0 };\n      endDuration = { ...startDuration, years: r2 };\n      break;\n    }\n    case 'month': {\n      const months = RoundNumberToIncrement(duration.date.months, increment, 'trunc');\n      r1 = months;\n      r2 = months + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, 0, 0, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, 0, 0, r2);\n      break;\n    }\n    case 'week': {\n      const yearsMonths = AdjustDateDurationRecord(duration.date, 0, 0);\n      const weeksStart = CalendarDateAdd(calendar, isoDateTime.isoDate, yearsMonths, 'constrain');\n      const weeksEnd = BalanceISODate(weeksStart.year, weeksStart.month, weeksStart.day + duration.date.days);\n      const untilResult = CalendarDateUntil(calendar, weeksStart, weeksEnd, 'week');\n      const weeks = RoundNumberToIncrement(duration.date.weeks + untilResult.weeks, increment, 'trunc');\n      r1 = weeks;\n      r2 = weeks + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, 0, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, 0, r2);\n      break;\n    }\n    case 'day': {\n      const days = RoundNumberToIncrement(duration.date.days, increment, 'trunc');\n      r1 = days;\n      r2 = days + increment * sign;\n      startDuration = AdjustDateDurationRecord(duration.date, r1);\n      endDuration = AdjustDateDurationRecord(duration.date, r2);\n      break;\n    }\n    default:\n      /* c8 ignore next */ assertNotReached();\n  }\n\n  if (sign === 1) assert(r1 >= 0 && r1 < r2, `positive ordering of r1, r2: 0 ≤ ${r1} < ${r2}`);\n  if (sign === -1) assert(r1 <= 0 && r1 > r2, `negative ordering of r1, r2: 0 ≥ ${r1} > ${r2}`);\n\n  // Apply to origin, output PlainDateTimes\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, startDuration, 'constrain');\n  const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\n\n  // Convert to epoch-nanoseconds\n  let startEpochNs, endEpochNs;\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\n  const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\n  if (timeZone) {\n    startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\n    endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n  } else {\n    startEpochNs = GetUTCEpochNanoseconds(startDateTime);\n    endEpochNs = GetUTCEpochNanoseconds(endDateTime);\n  }\n\n  // Round the smallestUnit within the epoch-nanosecond span\n  if (sign === 1) {\n    assert(\n      JSBI.lessThanOrEqual(startEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, endEpochNs),\n      `${unit} was 0 days long`\n    );\n  }\n  if (sign === -1) {\n    assert(\n      JSBI.lessThanOrEqual(endEpochNs, destEpochNs) && JSBI.lessThanOrEqual(destEpochNs, startEpochNs),\n      `${unit} was 0 days long`\n    );\n  }\n  assert(!JSBI.equal(endEpochNs, startEpochNs), 'startEpochNs must ≠ endEpochNs');\n  const numerator = TimeDuration.fromEpochNsDiff(destEpochNs, startEpochNs);\n  const denominator = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\n  const unsignedRoundingMode = GetUnsignedRoundingMode(roundingMode, sign < 0 ? 'negative' : 'positive');\n  const cmp = numerator.add(numerator).abs().subtract(denominator.abs()).sign();\n  const even = (Math.abs(r1) / increment) % 2 === 0;\n  // prettier-ignore\n  const roundedUnit = numerator.isZero()\n    ? Math.abs(r1)\n    : !numerator.cmp(denominator) // equal?\n      ? Math.abs(r2)\n      : ApplyUnsignedRoundingMode(Math.abs(r1), Math.abs(r2), cmp, even, unsignedRoundingMode);\n\n  // Trick to minimize rounding error, due to the lack of fma() in JS\n  const fakeNumerator = new TimeDuration(\n    JSBI.add(\n      JSBI.multiply(denominator.totalNs, JSBI.BigInt(r1)),\n      JSBI.multiply(numerator.totalNs, JSBI.BigInt(increment * sign))\n    )\n  );\n  const total = fakeNumerator.fdiv(denominator.totalNs);\n  assert(Math.abs(r1) <= Math.abs(total) && Math.abs(total) <= Math.abs(r2), 'r1 ≤ total ≤ r2');\n\n  // Determine whether expanded or contracted\n  const didExpandCalendarUnit = roundedUnit === Math.abs(r2);\n  duration = { date: didExpandCalendarUnit ? endDuration : startDuration, time: TimeDuration.ZERO };\n\n  const nudgeResult = {\n    duration,\n    nudgedEpochNs: didExpandCalendarUnit ? endEpochNs : startEpochNs,\n    didExpandCalendarUnit\n  };\n  return { nudgeResult, total };\n}\n\n// Attempts rounding of time units within a time zone's day, but if the rounding\n// causes time to exceed the total time within the day, rerun rounding in next\n// day.\nfunction NudgeToZonedTime(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  isoDateTime: ISODateTime,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  increment: number,\n  unit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be hour or smaller\n  let duration = durationParam;\n\n  // Apply to origin, output start/end of the day as PlainDateTimes\n  const start = CalendarDateAdd(calendar, isoDateTime.isoDate, duration.date, 'constrain');\n  const startDateTime = CombineISODateAndTimeRecord(start, isoDateTime.time);\n  const endDate = BalanceISODate(start.year, start.month, start.day + sign);\n  const endDateTime = CombineISODateAndTimeRecord(endDate, isoDateTime.time);\n\n  // Compute the epoch-nanosecond start/end of the final whole-day interval\n  // If duration has negative sign, startEpochNs will be after endEpochNs\n  const startEpochNs = GetEpochNanosecondsFor(timeZone, startDateTime, 'compatible');\n  const endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n\n  // The signed amount of time from the start of the whole-day interval to the end\n  const daySpan = TimeDuration.fromEpochNsDiff(endEpochNs, startEpochNs);\n  if (daySpan.sign() !== sign) throw new RangeError('time zone returned inconsistent Instants');\n\n  // Compute time parts of the duration to nanoseconds and round\n  // Result could be negative\n  const unitIncrement = JSBI.BigInt(NS_PER_TIME_UNIT[unit] * increment);\n  let roundedTimeDuration = duration.time.round(unitIncrement, roundingMode);\n\n  // Does the rounded time exceed the time-in-day?\n  const beyondDaySpan = roundedTimeDuration.subtract(daySpan);\n  const didRoundBeyondDay = beyondDaySpan.sign() !== -sign;\n\n  let dayDelta, nudgedEpochNs;\n  if (didRoundBeyondDay) {\n    // If rounded into next day, use the day-end as the local origin and rerun\n    // the rounding\n    dayDelta = sign;\n    roundedTimeDuration = beyondDaySpan.round(unitIncrement, roundingMode);\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(endEpochNs);\n  } else {\n    // Otherwise, if time not rounded beyond day, use the day-start as the local\n    // origin\n    dayDelta = 0;\n    nudgedEpochNs = roundedTimeDuration.addToEpochNs(startEpochNs);\n  }\n\n  const dateDuration = AdjustDateDurationRecord(duration.date, duration.date.days + dayDelta);\n  const resultDuration = CombineDateAndTimeDuration(dateDuration, roundedTimeDuration);\n  return {\n    duration: resultDuration,\n    nudgedEpochNs,\n    didExpandCalendarUnit: didRoundBeyondDay\n  };\n}\n\n// Converts all fields to nanoseconds and does integer rounding.\nfunction NudgeToDayOrTime(\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  largestUnit: Temporal.DateTimeUnit,\n  increment: number,\n  smallestUnit: Temporal.TimeUnit | 'day',\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be day or smaller\n  let duration = durationParam;\n\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\n  // Convert to nanoseconds and round\n  const roundedTime = timeDuration.round(JSBI.BigInt(increment * NS_PER_TIME_UNIT[smallestUnit]), roundingMode);\n  const diffTime = roundedTime.subtract(timeDuration);\n\n  // Determine if whole days expanded\n  const { quotient: wholeDays } = timeDuration.divmod(DAY_NANOS);\n  const { quotient: roundedWholeDays } = roundedTime.divmod(DAY_NANOS);\n  const didExpandDays = Math.sign(roundedWholeDays - wholeDays) === timeDuration.sign();\n\n  const nudgedEpochNs = diffTime.addToEpochNs(destEpochNs);\n\n  let days = 0;\n  let remainder = roundedTime;\n  if (TemporalUnitCategory(largestUnit) === 'date') {\n    days = roundedWholeDays;\n    remainder = roundedTime.add(TimeDuration.fromComponents(-roundedWholeDays * 24, 0, 0, 0, 0, 0));\n  }\n\n  const dateDuration = AdjustDateDurationRecord(duration.date, days);\n  return {\n    duration: { date: dateDuration, time: remainder },\n    nudgedEpochNs,\n    didExpandCalendarUnit: didExpandDays\n  };\n}\n\n// Given a potentially bottom-heavy duration, bubble up smaller units to larger\n// units. Any units smaller than smallestUnit are already zeroed-out.\nfunction BubbleRelativeDuration(\n  sign: -1 | 1,\n  durationParam: InternalDuration,\n  nudgedEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateUnit,\n  smallestUnit: Temporal.DateUnit\n) {\n  // smallestUnit is day or larger\n  let duration = durationParam;\n\n  if (smallestUnit === largestUnit) return duration;\n\n  // Check to see if nudgedEpochNs has hit the boundary of any units higher than\n  // smallestUnit, in which case increment the higher unit and clear smaller\n  // units.\n  const largestUnitIndex = UNITS_DESCENDING.indexOf(largestUnit);\n  const smallestUnitIndex = UNITS_DESCENDING.indexOf(smallestUnit);\n  for (let unitIndex = smallestUnitIndex - 1; unitIndex >= largestUnitIndex; unitIndex--) {\n    // The only situation where days and smaller bubble-up into weeks is when\n    // largestUnit is 'week' (not to be confused with the situation where\n    // smallestUnit is 'week', in which case days and smaller are ROUNDED-up\n    // into weeks, but that has already happened by the time this function\n    // executes)\n    // So, if days and smaller are NOT bubbled-up into weeks, and the current\n    // unit is weeks, skip.\n    const unit = UNITS_DESCENDING[unitIndex];\n    if (unit === 'week' && largestUnit !== 'week') {\n      continue;\n    }\n\n    let endDuration;\n    switch (unit) {\n      case 'year': {\n        const years = duration.date.years + sign;\n        endDuration = { years, months: 0, weeks: 0, days: 0 };\n        break;\n      }\n      case 'month': {\n        const months = duration.date.months + sign;\n        endDuration = AdjustDateDurationRecord(duration.date, 0, 0, months);\n        break;\n      }\n      case 'week': {\n        const weeks = duration.date.weeks + sign;\n        endDuration = AdjustDateDurationRecord(duration.date, 0, weeks);\n        break;\n      }\n      default:\n        /* c8 ignore next */ assertNotReached();\n    }\n\n    // Compute end-of-unit in epoch-nanoseconds\n    const end = CalendarDateAdd(calendar, isoDateTime.isoDate, endDuration, 'constrain');\n    const endDateTime = CombineISODateAndTimeRecord(end, isoDateTime.time);\n    let endEpochNs;\n    if (timeZone) {\n      endEpochNs = GetEpochNanosecondsFor(timeZone, endDateTime, 'compatible');\n    } else {\n      endEpochNs = GetUTCEpochNanoseconds(endDateTime);\n    }\n\n    const didExpandToEnd = compare(nudgedEpochNs, endEpochNs) !== -sign;\n\n    // Is nudgedEpochNs at the end-of-unit? This means it should bubble-up to\n    // the next highest unit (and possibly further...)\n    if (didExpandToEnd) {\n      duration = { date: endDuration, time: TimeDuration.ZERO };\n    } else {\n      // NOT at end-of-unit. Stop looking for bubbling\n      break;\n    }\n  }\n\n  return duration;\n}\n\nfunction RoundRelativeDuration(\n  durationParam: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  largestUnitParam: Temporal.DateTimeUnit,\n  increment: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  let duration = durationParam;\n  // The duration must already be balanced. This should be achieved by calling\n  // one of the non-rounding since/until internal methods prior. It's okay to\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\n  // >24 hours in its timezone. (should automatically end up like this if using\n  // non-rounding since/until internal methods prior)\n  const irregularLengthUnit = IsCalendarUnit(smallestUnit) || (timeZone && smallestUnit === 'day');\n  const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\n\n  let nudgeResult;\n  if (irregularLengthUnit) {\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\n    ({ nudgeResult } = NudgeToCalendarUnit(\n      sign,\n      duration,\n      destEpochNs,\n      isoDateTime,\n      timeZone,\n      calendar,\n      increment,\n      smallestUnit,\n      roundingMode\n    ));\n  } else if (timeZone) {\n    // Special-case for rounding time units within a zoned day\n    uncheckedAssertNarrowedType<Temporal.TimeUnit>(\n      smallestUnit,\n      'other values handled in irregularLengthUnit clause above'\n    );\n    nudgeResult = NudgeToZonedTime(\n      sign,\n      duration,\n      isoDateTime,\n      timeZone,\n      calendar,\n      increment,\n      smallestUnit,\n      roundingMode\n    );\n  } else {\n    // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\n    // math. years/months/weeks unchanged\n    nudgeResult = NudgeToDayOrTime(duration, destEpochNs, largestUnitParam, increment, smallestUnit, roundingMode);\n  }\n\n  duration = nudgeResult.duration;\n  // Did nudging cause the duration to expand to the next day or larger?\n  // Bubble-up smaller calendar units into higher ones, except for weeks, which\n  // don't balance up into months\n  if (nudgeResult.didExpandCalendarUnit && smallestUnit !== 'week') {\n    uncheckedAssertNarrowedType<Temporal.DateUnit>(\n      largestUnitParam,\n      'if we expanded to a calendar unit, then largestUnit is a calendar unit'\n    );\n    duration = BubbleRelativeDuration(\n      sign,\n      duration,\n      nudgeResult.nudgedEpochNs, // The destEpochNs after expanding/contracting\n      isoDateTime,\n      timeZone,\n      calendar,\n      largestUnitParam, // where to STOP bubbling\n      LargerOfTwoTemporalUnits(smallestUnit, 'day') as Temporal.DateUnit // where to START bubbling-up from\n    );\n  }\n\n  return duration;\n}\n\nfunction TotalRelativeDuration(\n  duration: InternalDuration,\n  destEpochNs: JSBI,\n  isoDateTime: ISODateTime,\n  timeZone: string | null,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  // The duration must already be balanced. This should be achieved by calling\n  // one of the non-rounding since/until internal methods prior. It's okay to\n  // have a bottom-heavy weeks because weeks don't bubble-up into months. It's\n  // okay to have >24 hour day assuming the final day of relativeTo+duration has\n  // >24 hours in its timezone. (should automatically end up like this if using\n  // non-rounding since/until internal methods prior)\n  if (IsCalendarUnit(unit) || (timeZone && unit === 'day')) {\n    // Rounding an irregular-length unit? Use epoch-nanosecond-bounding technique\n    const sign = InternalDurationSign(duration) < 0 ? -1 : 1;\n    return NudgeToCalendarUnit(sign, duration, destEpochNs, isoDateTime, timeZone, calendar, 1, unit, 'trunc').total;\n  }\n  // Rounding uniform-length days/hours/minutes/etc units. Simple nanosecond\n  // math. years/months/weeks unchanged\n  const timeDuration = duration.time.add24HourDays(duration.date.days);\n  return TotalTimeDuration(timeDuration, unit);\n}\n\nexport function DifferencePlainDateTimeWithRounding(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit,\n  roundingIncrement: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) {\n    return { date: ZeroDateDuration(), time: TimeDuration.ZERO };\n  }\n\n  RejectDateTimeRange(isoDateTime1);\n  RejectDateTimeRange(isoDateTime2);\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, largestUnit);\n\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\n\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\n  return RoundRelativeDuration(\n    duration,\n    destEpochNs,\n    isoDateTime1,\n    null,\n    calendar,\n    largestUnit,\n    roundingIncrement,\n    smallestUnit,\n    roundingMode\n  );\n}\n\nexport function DifferencePlainDateTimeWithTotal(\n  isoDateTime1: ISODateTime,\n  isoDateTime2: ISODateTime,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) == 0) return 0;\n\n  RejectDateTimeRange(isoDateTime1);\n  RejectDateTimeRange(isoDateTime2);\n  const duration = DifferenceISODateTime(isoDateTime1, isoDateTime2, calendar, unit);\n\n  if (unit === 'nanosecond') return JSBI.toNumber(duration.time.totalNs);\n\n  const destEpochNs = GetUTCEpochNanoseconds(isoDateTime2);\n  return TotalRelativeDuration(duration, destEpochNs, isoDateTime1, null, calendar, unit);\n}\n\nexport function DifferenceZonedDateTimeWithRounding(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  largestUnit: Temporal.DateTimeUnit,\n  roundingIncrement: number,\n  smallestUnit: Temporal.DateTimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  if (TemporalUnitCategory(largestUnit) === 'time') {\n    // The user is only asking for a time difference, so return difference of instants.\n    return DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit as Temporal.TimeUnit, roundingMode);\n  }\n\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit);\n\n  if (smallestUnit === 'nanosecond' && roundingIncrement === 1) return duration;\n\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\n  return RoundRelativeDuration(\n    duration,\n    ns2,\n    dateTime,\n    timeZone,\n    calendar,\n    largestUnit,\n    roundingIncrement,\n    smallestUnit,\n    roundingMode\n  );\n}\n\nexport function DifferenceZonedDateTimeWithTotal(\n  ns1: JSBI,\n  ns2: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  unit: Temporal.DateTimeUnit\n) {\n  if (TemporalUnitCategory(unit) === 'time') {\n    // The user is only asking for a time difference, so return difference of instants.\n    return TotalTimeDuration(TimeDuration.fromEpochNsDiff(ns2, ns1), unit as Temporal.TimeUnit);\n  }\n\n  const duration = DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, unit);\n  const dateTime = GetISODateTimeFor(timeZone, ns1);\n  return TotalRelativeDuration(duration, ns2, dateTime, timeZone, calendar, unit);\n}\n\ntype DifferenceOperation = 'since' | 'until';\n\nfunction GetDifferenceSettings<T extends Temporal.DateTimeUnit>(\n  op: DifferenceOperation,\n  options: Temporal.DifferenceOptions<T>,\n  group: 'datetime' | 'date' | 'time',\n  disallowed: (Temporal.DateTimeUnit | 'auto')[],\n  fallbackSmallest: T,\n  smallestLargestDefaultUnit: T\n) {\n  const ALLOWED_UNITS = TEMPORAL_UNITS.reduce((allowed, unitInfo) => {\n    const p = unitInfo[0];\n    const s = unitInfo[1];\n    const c = unitInfo[2];\n    if ((group === 'datetime' || c === group) && !disallowed.includes(s)) {\n      allowed.push(s, p);\n    }\n    return allowed;\n  }, [] as (Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit>)[]);\n\n  let largestUnit = GetTemporalUnitValuedOption(options, 'largestUnit', group, 'auto');\n  if (disallowed.includes(largestUnit)) {\n    throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n  }\n\n  const roundingIncrement = GetTemporalRoundingIncrementOption(options);\n\n  let roundingMode = GetRoundingModeOption(options, 'trunc');\n  if (op === 'since') roundingMode = NegateRoundingMode(roundingMode);\n\n  const smallestUnit = GetTemporalUnitValuedOption(options, 'smallestUnit', group, fallbackSmallest);\n  if (disallowed.includes(smallestUnit)) {\n    throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n  }\n\n  const defaultLargestUnit = LargerOfTwoTemporalUnits(smallestLargestDefaultUnit, smallestUnit);\n  if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n  if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n    throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n  }\n  const MAX_DIFFERENCE_INCREMENTS: { [k in Temporal.DateTimeUnit]?: number } = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n  };\n  const maximum = MAX_DIFFERENCE_INCREMENTS[smallestUnit];\n  if (maximum !== undefined) ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n\n  return { largestUnit: largestUnit as T, roundingIncrement, roundingMode, smallestUnit: smallestUnit as T };\n}\n\nexport function DifferenceTemporalInstant(\n  operation: DifferenceOperation,\n  instant: Temporal.Instant,\n  otherParam: InstantParams['until'][0],\n  options: InstantParams['until'][1]\n) {\n  const other = ToTemporalInstant(otherParam);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'second');\n\n  const onens = GetSlot(instant, EPOCHNANOSECONDS);\n  const twons = GetSlot(other, EPOCHNANOSECONDS);\n  const duration = DifferenceInstant(\n    onens,\n    twons,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainDate(\n  operation: DifferenceOperation,\n  plainDate: Temporal.PlainDate,\n  otherParam: PlainDateParams['until'][0],\n  options: PlainDateParams['until'][1]\n) {\n  const other = ToTemporalDate(otherParam);\n  const calendar = GetSlot(plainDate, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', [], 'day', 'day');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  const isoDate = GetSlot(plainDate, ISO_DATE);\n  const isoOther = GetSlot(other, ISO_DATE);\n  if (CompareISODate(isoDate, isoOther) === 0) return new Duration();\n\n  const dateDifference = CalendarDateUntil(calendar, isoDate, isoOther, settings.largestUnit);\n\n  let duration = { date: dateDifference, time: TimeDuration.ZERO };\n  const roundingIsNoop = settings.smallestUnit === 'day' && settings.roundingIncrement === 1;\n  if (!roundingIsNoop) {\n    const isoDateTime = CombineISODateAndTimeRecord(isoDate, MidnightTimeRecord());\n    const isoDateTimeOther = CombineISODateAndTimeRecord(isoOther, MidnightTimeRecord());\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\n    duration = RoundRelativeDuration(\n      duration,\n      destEpochNs,\n      isoDateTime,\n      null,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n  }\n\n  let result = TemporalDurationFromInternal(duration, 'day');\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainDateTime(\n  operation: DifferenceOperation,\n  plainDateTime: Temporal.PlainDateTime,\n  otherParam: PlainDateTimeParams['until'][0],\n  options: PlainDateTimeParams['until'][1]\n) {\n  const other = ToTemporalDateTime(otherParam);\n  const calendar = GetSlot(plainDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'day');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  const isoDateTime1 = GetSlot(plainDateTime, ISO_DATE_TIME);\n  const isoDateTime2 = GetSlot(other, ISO_DATE_TIME);\n  if (CompareISODateTime(isoDateTime1, isoDateTime2) === 0) return new Duration();\n\n  const duration = DifferencePlainDateTimeWithRounding(\n    isoDateTime1,\n    isoDateTime2,\n    calendar,\n    settings.largestUnit,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainTime(\n  operation: DifferenceOperation,\n  plainTime: Temporal.PlainTime,\n  otherParam: PlainTimeParams['until'][0],\n  options: PlainTimeParams['until'][1]\n) {\n  const other = ToTemporalTime(otherParam);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'time', [], 'nanosecond', 'hour');\n\n  let timeDuration = DifferenceTime(GetSlot(plainTime, TIME), GetSlot(other, TIME));\n  timeDuration = RoundTimeDuration(\n    timeDuration,\n    settings.roundingIncrement,\n    settings.smallestUnit,\n    settings.roundingMode\n  );\n  const duration = CombineDateAndTimeDuration(ZeroDateDuration(), timeDuration);\n\n  let result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalPlainYearMonth(\n  operation: DifferenceOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  otherParam: PlainYearMonthParams['until'][0],\n  options: PlainYearMonthParams['until'][1]\n) {\n  const other = ToTemporalYearMonth(otherParam);\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between months of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'date', ['week', 'day'], 'month', 'year');\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n  if (CompareISODate(GetSlot(yearMonth, ISO_DATE), GetSlot(other, ISO_DATE)) == 0) {\n    return new Duration();\n  }\n\n  const thisFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\n  thisFields.day = 1;\n  const thisDate = CalendarDateFromFields(calendar, thisFields, 'constrain');\n  const otherFields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(other, ISO_DATE), 'year-month');\n  otherFields.day = 1;\n  const otherDate = CalendarDateFromFields(calendar, otherFields, 'constrain');\n\n  const dateDifference = CalendarDateUntil(calendar, thisDate, otherDate, settings.largestUnit);\n  let duration = { date: AdjustDateDurationRecord(dateDifference, 0, 0), time: TimeDuration.ZERO };\n  if (settings.smallestUnit !== 'month' || settings.roundingIncrement !== 1) {\n    const isoDateTime = CombineISODateAndTimeRecord(thisDate, MidnightTimeRecord());\n    const isoDateTimeOther = CombineISODateAndTimeRecord(otherDate, MidnightTimeRecord());\n    const destEpochNs = GetUTCEpochNanoseconds(isoDateTimeOther);\n    duration = RoundRelativeDuration(\n      duration,\n      destEpochNs,\n      isoDateTime,\n      null,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n  }\n\n  let result = TemporalDurationFromInternal(duration, 'day');\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function DifferenceTemporalZonedDateTime(\n  operation: DifferenceOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  otherParam: ZonedDateTimeParams['until'][0],\n  options: ZonedDateTimeParams['until'][1]\n) {\n  const other = ToTemporalZonedDateTime(otherParam);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const otherCalendar = GetSlot(other, CALENDAR);\n  if (!CalendarEquals(calendar, otherCalendar)) {\n    throw new RangeError(`cannot compute difference between dates of ${calendar} and ${otherCalendar} calendars`);\n  }\n\n  const resolvedOptions = GetOptionsObject(options);\n  const settings = GetDifferenceSettings(operation, resolvedOptions, 'datetime', [], 'nanosecond', 'hour');\n\n  const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n  const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n\n  const Duration = GetIntrinsic('%Temporal.Duration%');\n\n  let result;\n  if (TemporalUnitCategory(settings.largestUnit) !== 'date') {\n    // The user is only asking for a time difference, so return difference of instants.\n    const duration = DifferenceInstant(\n      ns1,\n      ns2,\n      settings.roundingIncrement,\n      settings.smallestUnit as Temporal.TimeUnit,\n      settings.roundingMode\n    );\n    result = TemporalDurationFromInternal(duration, settings.largestUnit);\n  } else {\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n      throw new RangeError(\n        \"When calculating difference between time zones, largestUnit must be 'hours' \" +\n          'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.'\n      );\n    }\n\n    if (JSBI.equal(ns1, ns2)) return new Duration();\n\n    const duration = DifferenceZonedDateTimeWithRounding(\n      ns1,\n      ns2,\n      timeZone,\n      calendar,\n      settings.largestUnit,\n      settings.roundingIncrement,\n      settings.smallestUnit,\n      settings.roundingMode\n    );\n    result = TemporalDurationFromInternal(duration, 'hour');\n  }\n\n  if (operation === 'since') result = CreateNegatedTemporalDuration(result);\n  return result;\n}\n\nexport function AddTime(\n  { hour, minute, second: secondParam, millisecond, microsecond, nanosecond: nanosecondParam }: TimeRecord,\n  timeDuration: TimeDuration\n) {\n  let second = secondParam;\n  let nanosecond = nanosecondParam;\n\n  second += timeDuration.sec;\n  nanosecond += timeDuration.subsec;\n  return BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\n\nfunction AddInstant(epochNanoseconds: JSBI, timeDuration: TimeDuration) {\n  const result = timeDuration.addToEpochNs(epochNanoseconds);\n  ValidateEpochNanoseconds(result);\n  return result;\n}\n\nexport function AddZonedDateTime(\n  epochNs: JSBI,\n  timeZone: string,\n  calendar: BuiltinCalendarId,\n  duration: InternalDuration,\n  overflow: Overflow = 'constrain'\n) {\n  // If only time is to be added, then use Instant math. It's not OK to fall\n  // through to the date/time code below because compatible disambiguation in\n  // the PlainDateTime=>Instant conversion will change the offset of any\n  // ZonedDateTime in the repeated clock time after a backwards transition.\n  // When adding/subtracting time units and not dates, this disambiguation is\n  // not expected and so is avoided below via a fast path for time-only\n  // arithmetic.\n  // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n  if (DateDurationSign(duration.date) === 0) return AddInstant(epochNs, duration.time);\n\n  // RFC 5545 requires the date portion to be added in calendar days and the\n  // time portion to be added in exact time.\n  const dt = GetISODateTimeFor(timeZone, epochNs);\n  const addedDate = CalendarDateAdd(calendar, dt.isoDate, duration.date, overflow);\n  const dtIntermediate = CombineISODateAndTimeRecord(addedDate, dt.time);\n\n  // Note that 'compatible' is used below because this disambiguation behavior\n  // is required by RFC 5545.\n  const intermediateNs = GetEpochNanosecondsFor(timeZone, dtIntermediate, 'compatible');\n  return AddInstant(intermediateNs, duration.time);\n}\n\ntype AddSubtractOperation = 'add' | 'subtract';\n\nexport function AddDurations(\n  operation: AddSubtractOperation,\n  duration: Temporal.Duration,\n  otherParam: DurationParams['add'][0]\n) {\n  let other = ToTemporalDuration(otherParam);\n  if (operation === 'subtract') other = CreateNegatedTemporalDuration(other);\n\n  const largestUnit1 = DefaultTemporalLargestUnit(duration);\n  const largestUnit2 = DefaultTemporalLargestUnit(other);\n  const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n  if (IsCalendarUnit(largestUnit)) {\n    throw new RangeError('For years, months, or weeks arithmetic, use date arithmetic relative to a starting point');\n  }\n\n  const d1 = ToInternalDurationRecordWith24HourDays(duration);\n  const d2 = ToInternalDurationRecordWith24HourDays(other);\n  const result = CombineDateAndTimeDuration(ZeroDateDuration(), d1.time.add(d2.time));\n  return TemporalDurationFromInternal(result, largestUnit);\n}\n\nexport function AddDurationToInstant(\n  operation: AddSubtractOperation,\n  instant: Temporal.Instant,\n  durationLike: InstantParams['add'][0]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const largestUnit = DefaultTemporalLargestUnit(duration);\n  if (TemporalUnitCategory(largestUnit) === 'date') {\n    throw new RangeError(\n      `Duration field ${largestUnit} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`\n    );\n  }\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), internalDuration.time);\n  return CreateTemporalInstant(ns);\n}\n\nexport function AddDurationToDate(\n  operation: AddSubtractOperation,\n  plainDate: Temporal.PlainDate,\n  durationLike: PlainDateParams['add'][0],\n  options: PlainDateParams['add'][1]\n) {\n  const calendar = GetSlot(plainDate, CALENDAR);\n\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const dateDuration = ToDateDurationRecordWithoutTime(duration);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n\n  const addedDate = CalendarDateAdd(calendar, GetSlot(plainDate, ISO_DATE), dateDuration, overflow);\n  return CreateTemporalDate(addedDate, calendar);\n}\n\nexport function AddDurationToDateTime(\n  operation: AddSubtractOperation,\n  dateTime: Temporal.PlainDateTime,\n  durationLike: PlainDateTimeParams['add'][0],\n  options: PlainDateTimeParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n\n  const calendar = GetSlot(dateTime, CALENDAR);\n\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n\n  // Add the time part\n  const isoDateTime = GetSlot(dateTime, ISO_DATE_TIME);\n  const timeResult = AddTime(isoDateTime.time, internalDuration.time);\n  const dateDuration = AdjustDateDurationRecord(internalDuration.date, timeResult.deltaDays);\n\n  // Delegate the date part addition to the calendar\n  RejectDuration(dateDuration.years, dateDuration.months, dateDuration.weeks, dateDuration.days, 0, 0, 0, 0, 0, 0);\n  const addedDate = CalendarDateAdd(calendar, isoDateTime.isoDate, dateDuration, overflow);\n\n  const result = CombineISODateAndTimeRecord(addedDate, timeResult);\n  return CreateTemporalDateTime(result, calendar);\n}\n\nexport function AddDurationToTime(\n  operation: AddSubtractOperation,\n  temporalTime: Temporal.PlainTime,\n  durationLike: PlainTimeParams['add'][0]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const internalDuration = ToInternalDurationRecordWith24HourDays(duration);\n  const { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(\n    GetSlot(temporalTime, TIME),\n    internalDuration.time\n  );\n  const time = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject');\n  return CreateTemporalTime(time);\n}\n\nexport function AddDurationToYearMonth(\n  operation: AddSubtractOperation,\n  yearMonth: Temporal.PlainYearMonth,\n  durationLike: PlainYearMonthParams['add'][0],\n  options: PlainYearMonthParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n  const sign = DurationSign(duration);\n\n  const calendar = GetSlot(yearMonth, CALENDAR);\n  const fields: CalendarFieldsRecord = ISODateToFields(calendar, GetSlot(yearMonth, ISO_DATE), 'year-month');\n  fields.day = 1;\n  let startDate = CalendarDateFromFields(calendar, fields, 'constrain');\n  if (sign < 0) {\n    const nextMonth = CalendarDateAdd(calendar, startDate, { months: 1 }, 'constrain');\n    startDate = BalanceISODate(nextMonth.year, nextMonth.month, nextMonth.day - 1);\n  }\n  const durationToAdd = ToDateDurationRecordWithoutTime(duration);\n  RejectDateRange(startDate);\n  const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, overflow);\n  const addedDateFields = ISODateToFields(calendar, addedDate, 'year-month');\n\n  const isoDate = CalendarYearMonthFromFields(calendar, addedDateFields, overflow);\n  return CreateTemporalYearMonth(isoDate, calendar);\n}\n\nexport function AddDurationToZonedDateTime(\n  operation: AddSubtractOperation,\n  zonedDateTime: Temporal.ZonedDateTime,\n  durationLike: ZonedDateTimeParams['add'][0],\n  options: ZonedDateTimeParams['add'][1]\n) {\n  let duration = ToTemporalDuration(durationLike);\n  if (operation === 'subtract') duration = CreateNegatedTemporalDuration(duration);\n\n  const resolvedOptions = GetOptionsObject(options);\n  const overflow = GetTemporalOverflowOption(resolvedOptions);\n  const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n  const calendar = GetSlot(zonedDateTime, CALENDAR);\n  const internalDuration = ToInternalDurationRecord(duration);\n  const epochNanoseconds = AddZonedDateTime(\n    GetSlot(zonedDateTime, EPOCHNANOSECONDS),\n    timeZone,\n    calendar,\n    internalDuration,\n    overflow\n  );\n  return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function RoundNumberToIncrement(quantity: number, increment: number, mode: Temporal.RoundingMode) {\n  const quotient = Math.trunc(quantity / increment);\n  const remainder = quantity % increment;\n  const sign = quantity < 0 ? 'negative' : 'positive';\n  const r1 = Math.abs(quotient);\n  const r2 = r1 + 1;\n  const cmp = ComparisonResult(Math.abs(remainder * 2) - increment);\n  const even = r1 % 2 === 0;\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, sign);\n  const rounded = remainder === 0 ? r1 : ApplyUnsignedRoundingMode(r1, r2, cmp, even, unsignedRoundingMode);\n  return increment * (sign === 'positive' ? rounded : -rounded);\n}\n\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function RoundNumberToIncrementAsIfPositive(\n  quantityParam: JSBI | bigint,\n  incrementParam: JSBI | bigint,\n  mode: Temporal.RoundingMode\n) {\n  const quantity = ensureJSBI(quantityParam);\n  const increment = ensureJSBI(incrementParam);\n  const quotient = JSBI.divide(quantity, increment);\n  const remainder = JSBI.remainder(quantity, increment);\n  const unsignedRoundingMode = GetUnsignedRoundingMode(mode, 'positive');\n  let r1: JSBI, r2: JSBI;\n  if (JSBI.lessThan(quantity, ZERO)) {\n    r1 = JSBI.subtract(quotient, ONE);\n    r2 = quotient;\n  } else {\n    r1 = quotient;\n    r2 = JSBI.add(quotient, ONE);\n  }\n  // Similar to the comparison in RoundNumberToIncrement, but multiplied by an\n  // extra sign to make sure we treat it as positive\n  const cmp = (compare(abs(JSBI.multiply(remainder, TWO)), increment) * (JSBI.lessThan(quantity, ZERO) ? -1 : 1) +\n    0) as -1 | 0 | 1;\n  const rounded = JSBI.equal(remainder, ZERO)\n    ? quotient\n    : ApplyUnsignedRoundingMode(r1, r2, cmp, isEven(r1), unsignedRoundingMode);\n  return JSBI.multiply(rounded, increment);\n}\n\nexport function RoundTemporalInstant(\n  epochNs: JSBI,\n  increment: number,\n  unit: TimeUnitOrDay,\n  roundingMode: Temporal.RoundingMode\n) {\n  const incrementNs = NS_PER_TIME_UNIT[unit] * increment;\n  return RoundNumberToIncrementAsIfPositive(epochNs, JSBI.BigInt(incrementNs), roundingMode);\n}\n\nexport function RoundISODateTime(\n  isoDateTime: ISODateTime,\n  increment: number,\n  unit: UnitSmallerThanOrEqualTo<'day'>,\n  roundingMode: Temporal.RoundingMode\n) {\n  AssertISODateTimeWithinLimits(isoDateTime);\n  const { year, month, day } = isoDateTime.isoDate;\n  const time = RoundTime(isoDateTime.time, increment, unit, roundingMode);\n  const isoDate = BalanceISODate(year, month, day + time.deltaDays);\n  return CombineISODateAndTimeRecord(isoDate, time);\n}\n\nexport function RoundTime(\n  { hour, minute, second, millisecond, microsecond, nanosecond }: TimeRecord,\n  increment: number,\n  unit: TimeUnitOrDay,\n  roundingMode: Temporal.RoundingMode\n) {\n  let quantity;\n  switch (unit) {\n    case 'day':\n    case 'hour':\n      quantity = ((((hour * 60 + minute) * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'minute':\n      quantity = (((minute * 60 + second) * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'second':\n      quantity = ((second * 1000 + millisecond) * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'millisecond':\n      quantity = (millisecond * 1000 + microsecond) * 1000 + nanosecond;\n      break;\n    case 'microsecond':\n      quantity = microsecond * 1000 + nanosecond;\n      break;\n    case 'nanosecond':\n      quantity = nanosecond;\n  }\n  const nsPerUnit = NS_PER_TIME_UNIT[unit];\n  const result = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode) / nsPerUnit;\n  switch (unit) {\n    case 'day':\n      return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n    case 'hour':\n      return BalanceTime(result, 0, 0, 0, 0, 0);\n    case 'minute':\n      return BalanceTime(hour, result, 0, 0, 0, 0);\n    case 'second':\n      return BalanceTime(hour, minute, result, 0, 0, 0);\n    case 'millisecond':\n      return BalanceTime(hour, minute, second, result, 0, 0);\n    case 'microsecond':\n      return BalanceTime(hour, minute, second, millisecond, result, 0);\n    case 'nanosecond':\n      return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n    default:\n      throw new Error(`Invalid unit ${unit}`);\n  }\n}\n\nexport function RoundTimeDuration(\n  timeDuration: TimeDuration,\n  increment: number,\n  unit: Temporal.TimeUnit,\n  roundingMode: Temporal.RoundingMode\n) {\n  // unit must be a time unit\n  const divisor = NS_PER_TIME_UNIT[unit];\n  return timeDuration.round(JSBI.BigInt(divisor * increment), roundingMode);\n}\n\nexport function TotalTimeDuration(timeDuration: TimeDuration, unit: TimeUnitOrDay) {\n  const divisor = NS_PER_TIME_UNIT[unit];\n  return timeDuration.fdiv(JSBI.BigInt(divisor));\n}\n\nexport function CompareISODate(isoDate1: ISODate, isoDate2: ISODate) {\n  if (isoDate1.year !== isoDate2.year) return ComparisonResult(isoDate1.year - isoDate2.year);\n  if (isoDate1.month !== isoDate2.month) return ComparisonResult(isoDate1.month - isoDate2.month);\n  if (isoDate1.day !== isoDate2.day) return ComparisonResult(isoDate1.day - isoDate2.day);\n  return 0;\n}\n\nexport function CompareTimeRecord(time1: TimeRecord, time2: TimeRecord) {\n  if (time1.hour !== time2.hour) return ComparisonResult(time1.hour - time2.hour);\n  if (time1.minute !== time2.minute) return ComparisonResult(time1.minute - time2.minute);\n  if (time1.second !== time2.second) return ComparisonResult(time1.second - time2.second);\n  if (time1.millisecond !== time2.millisecond) return ComparisonResult(time1.millisecond - time2.millisecond);\n  if (time1.microsecond !== time2.microsecond) return ComparisonResult(time1.microsecond - time2.microsecond);\n  if (time1.nanosecond !== time2.nanosecond) return ComparisonResult(time1.nanosecond - time2.nanosecond);\n  return 0;\n}\n\nexport function CompareISODateTime(isoDateTime1: ISODateTime, isoDateTime2: ISODateTime) {\n  const dateResult = CompareISODate(isoDateTime1.isoDate, isoDateTime2.isoDate);\n  if (dateResult !== 0) return dateResult;\n  return CompareTimeRecord(isoDateTime1.time, isoDateTime2.time);\n}\n\n// Defaults to native bigint, or something \"native bigint-like\".\n// For users of Temporal that are running in environments without native BigInt,\n// the only guarantee we should give is that the returned object's toString will\n// return a string containing an accurate base 10 value of this bigint. This\n// form factor should correctly interop with other bigint compat libraries\n// easily.\ntype ExternalBigInt = bigint;\n\nexport function ToBigIntExternal(arg: unknown): ExternalBigInt {\n  const jsbiBI = ToBigInt(arg);\n  if (typeof (globalThis as any).BigInt !== 'undefined') return (globalThis as any).BigInt(jsbiBI.toString(10));\n  return jsbiBI as unknown as ExternalBigInt;\n}\n\n// rounding modes supported: floor, ceil, trunc\nexport function epochNsToMs(epochNanosecondsParam: JSBI | bigint, mode: 'floor' | 'ceil' | 'trunc') {\n  const epochNanoseconds = ensureJSBI(epochNanosecondsParam);\n  const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n  let epochMilliseconds = JSBI.toNumber(quotient);\n  if (mode === 'floor' && JSBI.toNumber(remainder) < 0) epochMilliseconds -= 1;\n  if (mode === 'ceil' && JSBI.toNumber(remainder) > 0) epochMilliseconds += 1;\n  return epochMilliseconds;\n}\n\nexport function epochMsToNs(epochMilliseconds: number) {\n  if (!Number.isInteger(epochMilliseconds)) throw new RangeError('epoch milliseconds must be an integer');\n  return JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n}\n\nexport function ToBigInt(arg: unknown): JSBI {\n  let prim = arg;\n  if (typeof arg === 'object') {\n    const toPrimFn = (arg as { [Symbol.toPrimitive]: unknown })[Symbol.toPrimitive];\n    if (toPrimFn && typeof toPrimFn === 'function') {\n      prim = toPrimFn.call(arg, 'number');\n    }\n  }\n\n  // The AO ToBigInt throws on numbers because it does not allow implicit\n  // conversion between number and bigint (unlike the bigint constructor).\n  if (typeof prim === 'number') {\n    throw new TypeError('cannot convert number to bigint');\n  }\n  if (typeof prim === 'bigint') {\n    // JSBI doesn't know anything about the bigint type, and intentionally\n    // assumes it doesn't exist. Passing one to the BigInt function will throw\n    // an error.\n    return JSBI.BigInt(prim.toString(10));\n  }\n  // JSBI will properly coerce types into a BigInt the same as the native BigInt\n  // constructor will, with the exception of native bigint which is handled\n  // above.\n  // As of 2023-04-07, the only runtime type that neither of those can handle is\n  // 'symbol', and both native bigint and the JSBI.BigInt function will throw an\n  // error if they are given a Symbol.\n  return JSBI.BigInt(prim as string | boolean | object);\n}\n\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds: () => JSBI = (() => {\n  let ns = JSBI.BigInt(Date.now() % 1e6);\n  return () => {\n    const now = Date.now();\n    const ms = JSBI.BigInt(now);\n    const result = JSBI.add(epochMsToNs(now), ns);\n    ns = JSBI.remainder(ms, MILLION);\n    if (JSBI.greaterThan(result, NS_MAX)) return NS_MAX;\n    if (JSBI.lessThan(result, NS_MIN)) return NS_MIN;\n    return result;\n  };\n})();\n\nexport function DefaultTimeZone() {\n  return new Intl.DateTimeFormat().resolvedOptions().timeZone;\n}\n\nexport function ComparisonResult(value: number) {\n  return value < 0 ? -1 : value > 0 ? 1 : (value as 0);\n}\n\nexport function GetOptionsObject<T>(options: T) {\n  if (options === undefined) return Object.create(null) as NonNullable<T>;\n  if (IsObject(options) && options !== null) return options;\n  throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\n\nexport function CreateOnePropObject<K extends string, V>(propName: K, propValue: V): { [k in K]: V } {\n  const o = Object.create(null);\n  o[propName] = propValue;\n  return o;\n}\n\ntype StringlyTypedKeys<T> = Exclude<keyof T, symbol | number>;\nfunction GetOption<P extends StringlyTypedKeys<O>, O extends Partial<Record<P, unknown>>>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: undefined\n): O[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | typeof REQUIRED | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: Fallback\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P];\nfunction GetOption<\n  P extends StringlyTypedKeys<O>,\n  O extends Partial<Record<P, unknown>>,\n  Fallback extends Required<O>[P] | undefined\n>(\n  options: O,\n  property: P,\n  allowedValues: ReadonlyArray<O[P]>,\n  fallback: O[P]\n): Fallback extends undefined ? O[P] | undefined : Required<O>[P] {\n  let value = options[property];\n  if (value !== undefined) {\n    value = ToString(value) as O[P];\n    if (!allowedValues.includes(value)) {\n      throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n    }\n    return value;\n  }\n  if (fallback === REQUIRED) throw new RangeError(`${property} option is required`);\n  return fallback;\n}\n\n// This is a temporary implementation. Ideally we'd rely on Intl.DateTimeFormat\n// here, to provide the latest CLDR alias data, when implementations catch up to\n// the ECMA-402 change. The aliases below are taken from\n// https://github.com/unicode-org/cldr/blob/main/common/bcp47/calendar.xml\nexport function CanonicalizeCalendar(idParam: string): BuiltinCalendarId {\n  const id = ASCIILowercase(idParam);\n\n  if (!BUILTIN_CALENDAR_IDS.includes(ASCIILowercase(id))) {\n    throw new RangeError(`invalid calendar identifier ${id}`);\n  }\n  uncheckedAssertNarrowedType<BuiltinCalendarId>(id, 'above code throws out any non-calendar IDs');\n\n  switch (id) {\n    case 'ethiopic-amete-alem':\n      // May need to be removed in the future.\n      // See https://github.com/tc39/ecma402/issues/285\n      return 'ethioaa';\n    // case 'gregorian':\n    // (Skip 'gregorian'. It isn't a valid identifier as it's a single\n    // subcomponent longer than 8 letters. It can only be used with the old\n    // @key=value syntax.)\n    case 'islamicc':\n      return 'islamic-civil';\n  }\n  return id;\n}\n\nfunction ASCIILowercase<T extends string>(str: T): T {\n  // The spec defines this operation distinct from String.prototype.lowercase,\n  // so we'll follow the spec here. Note that nasty security issues that can\n  // happen for some use cases if you're comparing case-modified non-ASCII\n  // values. For example, Turkish's \"I\" character was the source of a security\n  // issue involving \"file://\" URLs. See\n  // https://haacked.com/archive/2012/07/05/turkish-i-problem-and-why-you-should-care.aspx/.\n  let lowercase = '';\n  for (let ix = 0; ix < str.length; ix++) {\n    const code = str.charCodeAt(ix);\n    if (code >= 0x41 && code <= 0x5a) {\n      lowercase += String.fromCharCode(code + 0x20);\n    } else {\n      lowercase += String.fromCharCode(code);\n    }\n  }\n  return lowercase as T;\n}\n\n// This function isn't in the spec, but we put it in the polyfill to avoid\n// repeating the same (long) error message in many files.\nexport function ValueOfThrows(constructorName: string): never {\n  const compareCode =\n    constructorName === 'PlainMonthDay'\n      ? 'Temporal.PlainDate.compare(obj1.toPlainDate(year), obj2.toPlainDate(year))'\n      : `Temporal.${constructorName}.compare(obj1, obj2)`;\n\n  throw new TypeError(\n    'Do not use built-in arithmetic operators with Temporal objects. ' +\n      `When comparing, use ${compareCode}, not obj1 > obj2. ` +\n      \"When coercing to strings, use `${obj}` or String(obj), not '' + obj. \" +\n      'When coercing to numbers, use properties or methods of the object, not `+obj`. ' +\n      'When concatenating with strings, use `${str}${obj}` or str.concat(obj), not str + obj. ' +\n      'In React, coerce to a string before rendering a Temporal object.'\n  );\n}\n\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\nconst OFFSET_WITH_PARTS = new RegExp(`^${PARSE.offsetWithParts.source}$`);\n\nfunction bisect(\n  getState: (epochMs: number) => number,\n  leftParam: number,\n  rightParam: number,\n  lstateParam = getState(leftParam),\n  rstateParam = getState(rightParam)\n) {\n  let left = leftParam;\n  let right = rightParam;\n  let lstate = lstateParam;\n  let rstate = rstateParam;\n  while (right - left > 1) {\n    let middle = Math.trunc((left + right) / 2);\n    const mstate = getState(middle);\n    if (mstate === lstate) {\n      left = middle;\n      lstate = mstate;\n    } else if (mstate === rstate) {\n      right = middle;\n      rstate = mstate;\n    } else {\n      /* c8 ignore next */ assertNotReached(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n    }\n  }\n  return right;\n}\n","import * as ES from './ecmascript';\nimport { DefineIntrinsic } from './intrinsicclass';\nimport type { Temporal } from '..';\nimport type {\n  BuiltinCalendarId,\n  CalendarDateRecord,\n  CalendarFieldsRecord,\n  CalendarYMD,\n  DateDuration,\n  FieldKey,\n  ISODate,\n  ISODateToFieldsType,\n  MonthDayFromFieldsObject,\n  Overflow,\n  Resolve\n} from './internaltypes';\n\nfunction arrayFromSet<T>(src: Set<T>): T[] {\n  return [...src];\n}\n\nfunction calendarDateWeekOfYear(id: BuiltinCalendarId, isoDate: ISODate): { week: number; year: number } | undefined {\n  // Supports only Gregorian and ISO8601 calendar; can be updated to add support for other calendars.\n  // Returns undefined for calendars without a well-defined week calendar system.\n  // eslint-disable-next-line max-len\n  // Also see: https://github.com/unicode-org/icu/blob/ab72ab1d4a3c3f9beeb7d92b0c7817ca93dfdb04/icu4c/source/i18n/calendar.cpp#L1606\n  if (id !== 'gregory' && id !== 'iso8601') return undefined;\n  const calendar = impl[id];\n  let yow = isoDate.year;\n  const { dayOfWeek, dayOfYear, daysInYear } = calendar.isoToDate(isoDate, {\n    dayOfWeek: true,\n    dayOfYear: true,\n    daysInYear: true\n  });\n  const fdow = calendar.getFirstDayOfWeek();\n  const mdow = calendar.getMinimalDaysInFirstWeek();\n  ES.uncheckedAssertNarrowedType<number>(fdow, 'guaranteed to exist for iso8601/gregory');\n  ES.uncheckedAssertNarrowedType<number>(mdow, 'guaranteed to exist for iso8601/gregory');\n\n  // For both the input date and the first day of its calendar year, calculate the day of week\n  // relative to first day of week in the relevant calendar (e.g., in iso8601, relative to Monday).\n  let relDow = (dayOfWeek + 7 - fdow) % 7;\n  // Assuming the year length is less than 7000 days.\n  let relDowJan1 = (dayOfWeek - dayOfYear + 7001 - fdow) % 7;\n\n  let woy = Math.floor((dayOfYear - 1 + relDowJan1) / 7);\n  if (7 - relDowJan1 >= mdow) {\n    ++woy;\n  }\n\n  // Adjust for weeks at the year end that overlap into the previous or next calendar year.\n  if (woy == 0) {\n    // Check for last week of previous year; if true, handle the case for\n    // first week of next year\n    const prevYearCalendar = calendar.isoToDate(calendar.dateAdd(isoDate, { years: -1 }, 'constrain'), {\n      daysInYear: true\n    });\n    let prevDoy = dayOfYear + prevYearCalendar.daysInYear;\n    woy = weekNumber(fdow, mdow, prevDoy, dayOfWeek);\n    yow--;\n  } else {\n    // For it to be week 1 of the next year, dayOfYear must be >= lastDoy - 5\n    //          L-5                  L\n    // doy: 359 360 361 362 363 364 365 001\n    // dow:      1   2   3   4   5   6   7\n    let lastDoy = daysInYear;\n    if (dayOfYear >= lastDoy - 5) {\n      let lastRelDow = (relDow + lastDoy - dayOfYear) % 7;\n      if (lastRelDow < 0) {\n        lastRelDow += 7;\n      }\n      if (6 - lastRelDow >= mdow && dayOfYear + 7 - relDow > lastDoy) {\n        woy = 1;\n        yow++;\n      }\n    }\n  }\n  return { week: woy, year: yow };\n}\n\nfunction ISODateSurpasses(sign: -1 | 0 | 1, y1: number, m1: number, d1: number, isoDate2: ISODate) {\n  if (y1 !== isoDate2.year) {\n    if (sign * (y1 - isoDate2.year) > 0) return true;\n  } else if (m1 !== isoDate2.month) {\n    if (sign * (m1 - isoDate2.month) > 0) return true;\n  } else if (d1 !== isoDate2.day) {\n    if (sign * (d1 - isoDate2.day) > 0) return true;\n  }\n  return false;\n}\n\ntype ResolveFieldsReturn<Type extends ISODateToFieldsType> = Resolve<\n  CalendarFieldsRecord & {\n    year: Type extends 'date' ? number : never;\n    month: number;\n    monthCode: string;\n    day: number;\n  }\n>;\n\n/**\n * Shape of internal implementation of each built-in calendar. Note that\n * parameter types are simpler than CalendarProtocol because the `Calendar`\n * class performs validation and parameter normalization before handing control\n * over to CalendarImpl.\n *\n * There are two instances of this interface: one for the ISO calendar and\n * another that handles logic that's the same across all non-ISO calendars. The\n * latter is cloned for each non-ISO calendar at the end of this file.\n */\nexport interface CalendarImpl {\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >(\n    isoDate: ISODate,\n    requestedFields: Request\n  ): T;\n  getFirstDayOfWeek(): number | undefined;\n  getMinimalDaysInFirstWeek(): number | undefined;\n  resolveFields<Type extends ISODateToFieldsType>(\n    fields: CalendarFieldsRecord,\n    type: Type\n  ): asserts fields is ResolveFieldsReturn<Type>;\n  dateToISO(fields: ResolveFieldsReturn<'date'>, overflow: Overflow): ISODate;\n  monthDayToISOReferenceDate(fields: ResolveFieldsReturn<'month-day'>, overflow: Overflow): ISODate;\n  dateAdd(date: ISODate, duration: Partial<DateDuration>, overflow: Overflow): ISODate;\n  dateUntil(one: ISODate, two: ISODate, largestUnit: 'year' | 'month' | 'week' | 'day'): DateDuration;\n  extraFields(fields: FieldKey[]): FieldKey[];\n  fieldKeysToIgnore(keys: FieldKey[]): FieldKey[];\n}\n\ntype CalendarImplementations = {\n  [k in BuiltinCalendarId]: CalendarImpl;\n};\n\n/**\n * Implementations for each calendar.\n * Registration for each of these calendars happens throughout this file. The ISO and non-ISO calendars are registered\n * separately - look for 'iso8601' for the ISO calendar registration, and all non-ISO calendar registrations happens\n * at the bottom of the file.\n */\nconst impl: CalendarImplementations = {} as unknown as CalendarImplementations;\n\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n  resolveFields(fields, type) {\n    if ((type === 'date' || type === 'year-month') && fields.year === undefined) {\n      throw new TypeError('year is required');\n    }\n    if ((type === 'date' || type === 'month-day') && fields.day === undefined) {\n      throw new TypeError('day is required');\n    }\n    Object.assign(fields, resolveNonLunisolarMonth(fields));\n  },\n  dateToISO(fields, overflow) {\n    return ES.RegulateISODate(fields.year, fields.month, fields.day, overflow);\n  },\n  monthDayToISOReferenceDate(fields, overflow) {\n    const referenceISOYear = 1972;\n    const { month, day } = ES.RegulateISODate(fields.year ?? referenceISOYear, fields.month, fields.day, overflow);\n    return { month, day, year: referenceISOYear };\n  },\n  extraFields() {\n    return [];\n  },\n  fieldKeysToIgnore(keys) {\n    const result = new Set<FieldKey>();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      result.add(key);\n      if (key === 'month') {\n        result.add('monthCode');\n      } else if (key === 'monthCode') {\n        result.add('month');\n      }\n    }\n    return arrayFromSet(result);\n  },\n  dateAdd(isoDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow) {\n    let { year, month, day } = isoDate;\n    year += years;\n    month += months;\n    ({ year, month } = ES.BalanceISOYearMonth(year, month));\n    ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n    day += days + 7 * weeks;\n    return ES.BalanceISODate(year, month, day);\n  },\n  dateUntil(one, two, largestUnit) {\n    const sign = -ES.CompareISODate(one, two);\n    if (sign === 0) return { years: 0, months: 0, weeks: 0, days: 0 };\n    ES.uncheckedAssertNarrowedType<-1 | 1>(sign, \"the - operator's return type is number\");\n\n    let years = 0;\n    let months = 0;\n    let intermediate;\n    if (largestUnit === 'year' || largestUnit === 'month') {\n      // We can skip right to the neighbourhood of the correct number of years,\n      // it'll be at least one less than two.year - one.year (unless it's zero)\n      let candidateYears = two.year - one.year;\n      if (candidateYears !== 0) candidateYears -= sign;\n      // loops at most twice\n      while (!ISODateSurpasses(sign, one.year + candidateYears, one.month, one.day, two)) {\n        years = candidateYears;\n        candidateYears += sign;\n      }\n\n      let candidateMonths = sign;\n      intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + candidateMonths);\n      // loops at most 12 times\n      while (!ISODateSurpasses(sign, intermediate.year, intermediate.month, one.day, two)) {\n        months = candidateMonths;\n        candidateMonths += sign;\n        intermediate = ES.BalanceISOYearMonth(intermediate.year, intermediate.month + sign);\n      }\n\n      if (largestUnit === 'month') {\n        months += years * 12;\n        years = 0;\n      }\n    }\n\n    intermediate = ES.BalanceISOYearMonth(one.year + years, one.month + months);\n    const constrained = ES.ConstrainISODate(intermediate.year, intermediate.month, one.day);\n\n    let weeks = 0;\n    let days =\n      ES.ISODateToEpochDays(two.year, two.month - 1, two.day) -\n      ES.ISODateToEpochDays(constrained.year, constrained.month - 1, constrained.day);\n\n    if (largestUnit === 'week') {\n      weeks = Math.trunc(days / 7);\n      days %= 7;\n    }\n\n    return { years, months, weeks, days };\n  },\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >({ year, month, day }: ISODate, requestedFields: Request): T {\n    // requestedFields parameter is not part of the spec text. It's an\n    // illustration of one way implementations may choose to optimize this\n    // operation.\n    const date: Partial<CalendarDateRecord> = {\n      era: undefined,\n      eraYear: undefined,\n      year,\n      month,\n      day,\n      daysInWeek: 7,\n      monthsInYear: 12\n    };\n    if (requestedFields.monthCode) date.monthCode = buildMonthCode(month);\n    if (requestedFields.dayOfWeek) {\n      // https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Disparate_variation\n      const shiftedMonth = month + (month < 3 ? 10 : -2);\n      const shiftedYear = year - (month < 3 ? 1 : 0);\n\n      const century = Math.floor(shiftedYear / 100);\n      const yearInCentury = shiftedYear - century * 100;\n\n      const monthTerm = Math.floor(2.6 * shiftedMonth - 0.2);\n      const yearTerm = yearInCentury + Math.floor(yearInCentury / 4);\n      const centuryTerm = Math.floor(century / 4) - 2 * century;\n\n      const dow = (day + monthTerm + yearTerm + centuryTerm) % 7;\n\n      date.dayOfWeek = dow + (dow <= 0 ? 7 : 0);\n    }\n    if (requestedFields.dayOfYear) {\n      let days = day;\n      for (let m = month - 1; m > 0; m--) {\n        days += ES.ISODaysInMonth(year, m);\n      }\n      date.dayOfYear = days;\n    }\n    if (requestedFields.weekOfYear) date.weekOfYear = calendarDateWeekOfYear('iso8601', { year, month, day });\n    if (requestedFields.daysInMonth) date.daysInMonth = ES.ISODaysInMonth(year, month);\n    if (requestedFields.daysInYear || requestedFields.inLeapYear) {\n      date.inLeapYear = ES.LeapYear(year);\n      date.daysInYear = date.inLeapYear ? 366 : 365;\n    }\n    return date as T;\n  },\n  getFirstDayOfWeek() {\n    return 1;\n  },\n  getMinimalDaysInFirstWeek() {\n    return 4;\n  }\n};\n\n// Note: Built-in calendars other than iso8601 are not part of the Temporal\n// proposal for ECMA-262. These calendars will be standardized as part of\n// ECMA-402. Code below here includes an implementation of these calendars to\n// validate the Temporal API and to get feedback. However, native non-ISO\n// calendar behavior is at least somewhat implementation-defined, so may not\n// match this polyfill's output exactly.\n//\n// Some ES implementations don't include ECMA-402. For this reason, it's helpful\n// to ensure a clean separation between the ISO calendar implementation which is\n// a part of ECMA-262 and the non-ISO calendar implementation which requires\n// ECMA-402.\n//\n// To ensure this separation, the implementation is split. A `CalendarImpl`\n// interface defines the common operations between both ISO and non-ISO\n// calendars.\n\n/**\n * This type is passed through from CalendarImpl#dateFromFields().\n * `monthExtra` is additional information used internally to identify lunisolar leap months.\n */\ntype CalendarDateFields = CalendarFieldsRecord & { monthExtra?: string };\n\n/**\n * This is a \"fully populated\" calendar date record. It's only lacking\n * `era`/`eraYear` (which may not be present in all calendars) and `monthExtra`\n * which is only used in some cases.\n */\ntype FullCalendarDate = {\n  era?: string;\n  eraYear?: number;\n  year: number;\n  month: number;\n  monthCode: string;\n  day: number;\n  monthExtra?: string;\n};\n\n// The types below are various subsets of calendar dates\ntype CalendarYM = { year: number; month: number };\ntype CalendarYearOnly = { year: number };\ntype EraAndEraYear = { era: string; eraYear: number };\n\nfunction nonLeapMonthCodeNumberPart(monthCode: string) {\n  if (!monthCode.startsWith('M')) {\n    throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n  }\n  const month = +monthCode.slice(1);\n  if (Number.isNaN(month)) throw new RangeError(`Invalid month code: ${monthCode}`);\n  return month;\n}\n\nfunction buildMonthCode(month: number, leap = false) {\n  const digitPart = `${month}`.padStart(2, '0');\n  const leapMarker = leap ? 'L' : '';\n  return `M${digitPart}${leapMarker}`;\n}\n\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth<T extends { monthCode?: string; month?: number }>(\n  calendarDate: T,\n  overflow: Overflow | undefined = undefined,\n  monthsPerYear = 12\n) {\n  let { month, monthCode } = calendarDate;\n  if (monthCode === undefined) {\n    if (month === undefined) throw new TypeError('Either month or monthCode are required');\n    // The ISO calendar uses the default (undefined) value because it does\n    // constrain/reject after this method returns. Non-ISO calendars, however,\n    // rely on this function to constrain/reject out-of-range `month` values.\n    if (overflow === 'reject') ES.RejectToRange(month, 1, monthsPerYear);\n    if (overflow === 'constrain') month = ES.ConstrainToRange(month, 1, monthsPerYear);\n    monthCode = buildMonthCode(month);\n  } else {\n    const numberPart = nonLeapMonthCodeNumberPart(monthCode);\n    if (monthCode !== buildMonthCode(numberPart)) {\n      throw new RangeError(`Invalid month code: ${monthCode}`);\n    }\n    if (month !== undefined && month !== numberPart) {\n      throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n    }\n    month = numberPart;\n    if (month < 1 || month > monthsPerYear) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n  }\n  return { ...calendarDate, month, monthCode };\n}\n\nfunction weekNumber(firstDayOfWeek: number, minimalDaysInFirstWeek: number, desiredDay: number, dayOfWeek: number) {\n  let periodStartDayOfWeek = (dayOfWeek - firstDayOfWeek - desiredDay + 1) % 7;\n  if (periodStartDayOfWeek < 0) periodStartDayOfWeek += 7;\n  let weekNo = Math.floor((desiredDay + periodStartDayOfWeek - 1) / 7);\n  if (7 - periodStartDayOfWeek >= minimalDaysInFirstWeek) {\n    ++weekNo;\n  }\n  return weekNo;\n}\n\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n  map = new Map();\n  calls = 0;\n  // now = OneObjectCache.monotonicTimestamp();\n  hits = 0;\n  misses = 0;\n\n  // static monotonicTimestamp() {\n  //   return performance?.now() ?? Date.now();\n  // }\n\n  constructor(cacheToClone?: OneObjectCache) {\n    if (cacheToClone !== undefined) {\n      let i = 0;\n      for (const entry of cacheToClone.map.entries()) {\n        if (++i > OneObjectCache.MAX_CACHE_ENTRIES) break;\n        this.map.set(...entry);\n      }\n    }\n  }\n  get(key: string) {\n    const result = this.map.get(key);\n    if (result) {\n      this.hits++;\n      this.report();\n    }\n    this.calls++;\n    return result;\n  }\n  set(key: string, value: unknown) {\n    this.map.set(key, value);\n    this.misses++;\n    this.report();\n  }\n  report() {\n    // if (this.calls === 0) return;\n    // const ms = OneObjectCache.monotonicTimestamp() - this.now;\n    // const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n    // const t = `${ms.toFixed(2)}ms`;\n    // // eslint-disable-next-line no-console\n    // console.log(`${this.calls} calls in ${t}. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n  }\n  setObject(obj: ISODate) {\n    if (OneObjectCache.objectMap.get(obj)) throw new RangeError('object already cached');\n    OneObjectCache.objectMap.set(obj, this);\n    this.report();\n  }\n\n  static objectMap = new WeakMap();\n  static MAX_CACHE_ENTRIES = 1000;\n\n  /**\n   * Returns a WeakMap-backed cache that's used to store expensive results\n   * that are associated with a particular Temporal object instance.\n   *\n   * @param obj - object to associate with the cache\n   */\n  static getCacheForObject(obj: ISODate) {\n    let cache = OneObjectCache.objectMap.get(obj);\n    if (!cache) {\n      cache = new OneObjectCache();\n      OneObjectCache.objectMap.set(obj, cache);\n    }\n    return cache;\n  }\n}\n\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }: { isoYear: number; isoMonth: number; isoDay: number }) {\n  const yearString = ES.ISOYearString(isoYear);\n  const monthString = ES.ISODateTimePartString(isoMonth);\n  const dayString = ES.ISODateTimePartString(isoDay);\n  return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\n\nfunction simpleDateDiff(one: CalendarYMD, two: CalendarYMD) {\n  return {\n    years: one.year - two.year,\n    months: one.month - two.month,\n    days: one.day - two.day\n  };\n}\n\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nabstract class HelperBase {\n  abstract id: BuiltinCalendarId;\n  abstract monthsInYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): number;\n  abstract maximumMonthLength(calendarDate?: CalendarYM): number;\n  abstract minimumMonthLength(calendarDate?: CalendarYM): number;\n  abstract maxLengthOfMonthCodeInAnyYear(monthCode: string): number;\n  abstract estimateIsoDate(calendarDate: CalendarYMD): ISODate;\n  abstract inLeapYear(calendarDate: CalendarYearOnly, cache?: OneObjectCache): boolean;\n  abstract calendarType: 'solar' | 'lunar' | 'lunisolar';\n  reviseIntlEra?<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T;\n  eras: Era[] = [];\n  checkIcuBugs?(isoDate: ISODate): void;\n  private formatter?: globalThis.Intl.DateTimeFormat;\n  getFormatter() {\n    // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n    // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n    // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n    // calendars that are used. Note that the HelperBase class is extended to\n    // create each calendar's implementation before any cache is created, so\n    // each calendar gets its own separate cached formatter.\n    if (typeof this.formatter === 'undefined') {\n      this.formatter = new Intl.DateTimeFormat(`en-US-u-ca-${this.id}`, {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n        era: 'short',\n        timeZone: 'UTC'\n      });\n    }\n    return this.formatter;\n  }\n  getCalendarParts(isoString: string) {\n    let dateTimeFormat = this.getFormatter();\n    let legacyDate = new Date(isoString);\n\n    // PlainDate's minimum date -271821-04-19 is one day beyond legacy Date's\n    // minimum -271821-04-20, because of accommodating all Instants in all time\n    // zones. If we have -271821-04-19, instead format -271821-04-20 in a time\n    // zone that pushes the result into the previous day. This is a slow path\n    // because we create a new Intl.DateTimeFormat.\n    if (isoString === '-271821-04-19T00:00Z') {\n      const options = dateTimeFormat.resolvedOptions();\n      dateTimeFormat = new Intl.DateTimeFormat(options.locale, {\n        ...(options as Intl.DateTimeFormatOptions),\n        timeZone: 'Etc/GMT+1'\n      });\n      legacyDate = new Date('-271821-04-20T00:00Z');\n    }\n\n    try {\n      return dateTimeFormat.formatToParts(legacyDate);\n    } catch (e) {\n      throw new RangeError(`Invalid ISO date: ${isoString}`);\n    }\n  }\n  isoToCalendarDate(isoDate: ISODate, cache: OneObjectCache): FullCalendarDate {\n    const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n    const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n\n    const isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n    const parts = this.getCalendarParts(isoString);\n    const result: Partial<FullCalendarDate> = {};\n    for (let i = 0; i < parts.length; i++) {\n      const { type, value } = parts[i];\n      // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n      if (type === 'year' || type === ('relatedYear' as Intl.DateTimeFormatPartTypes)) {\n        if (this.hasEra) {\n          result.eraYear = +value;\n        } else {\n          result.year = +value;\n        }\n      }\n      if (type === 'month') {\n        const matches = /^([0-9]*)(.*?)$/.exec(value);\n        if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n          throw new RangeError(`Unexpected month: ${value}`);\n        }\n        // If the month has no numeric part (should only see this for the Hebrew\n        // calendar with newer FF / Chromium versions; see\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n        // placeholder month index of `1` and rely on the derived class to\n        // calculate the correct month index from the month name stored in\n        // `monthExtra`.\n        result.month = matches[1] ? +matches[1] : 1;\n        if (result.month < 1) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)'\n          );\n        }\n        if (result.month > 13) {\n          throw new RangeError(\n            `Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n              ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n          );\n        }\n\n        // The ICU formats for the Hebrew calendar no longer support a numeric\n        // month format. So we'll rely on the derived class to interpret it.\n        // `monthExtra` is also used on the Chinese calendar to handle a suffix\n        // \"bis\" indicating a leap month.\n        if (matches[2]) result.monthExtra = matches[2];\n      }\n      if (type === 'day') result.day = +value;\n      if (this.hasEra && type === 'era' && value != null && value !== '') {\n        // The convention for Temporal era values is lowercase, so following\n        // that convention in this prototype. Punctuation is removed, accented\n        // letters are normalized, and spaces are replaced with dashes.\n        // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n        // The call to normalize() and the replacement regex deals with era\n        // names that contain non-ASCII characters like Japanese eras. Also\n        // ignore extra content in parentheses like JPN era date ranges.\n        result.era = value\n          .split(' (')[0]\n          .normalize('NFD')\n          .replace(/[^-0-9 \\p{L}]/gu, '')\n          .replace(/ /g, '-')\n          .toLowerCase();\n      }\n    }\n    if (this.hasEra && result.eraYear === undefined) {\n      // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n      // output of Intl.DateTimeFormat.formatToParts.\n      throw new RangeError(\n        `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n      );\n    }\n    // Translate old ICU era codes \"ERA0\" etc. into canonical era names.\n    if (this.hasEra) {\n      const replacement = this.eras.find((e) => result.era === e.genericName);\n      if (replacement) result.era = replacement.code;\n    }\n    // Translate eras that may be handled differently by Temporal vs. by Intl\n    // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n    if (this.reviseIntlEra) {\n      const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n      result.era = era;\n      result.eraYear = eraYear;\n    }\n    if (this.checkIcuBugs) this.checkIcuBugs(isoDate);\n\n    const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n    if (calendarDate.year === undefined) throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n    if (calendarDate.month === undefined) {\n      throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n    }\n    if (calendarDate.day === undefined) throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n    cache.set(key, calendarDate);\n    // Also cache the reverse mapping\n    const cacheReverse = (overflow: Overflow) => {\n      const keyReverse = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: calendarDate.year,\n        month: calendarDate.month,\n        day: calendarDate.day,\n        overflow,\n        id: this.id\n      });\n      cache.set(keyReverse, isoDate);\n    };\n    (['constrain', 'reject'] as const).forEach(cacheReverse);\n    return calendarDate;\n  }\n  validateCalendarDate(calendarDate: Partial<FullCalendarDate>): asserts calendarDate is FullCalendarDate {\n    const { month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n    // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n    // the derived class must deal with it.\n    if (monthExtra !== undefined) throw new RangeError('Unexpected `monthExtra` value');\n    if (year === undefined && eraYear === undefined) throw new TypeError('year or eraYear is required');\n    if (month === undefined && monthCode === undefined) throw new TypeError('month or monthCode is required');\n    if (day === undefined) throw new RangeError('Missing day');\n    if (monthCode !== undefined) {\n      if (typeof monthCode !== 'string') {\n        throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n      }\n      if (!/^M([01]?\\d)(L?)$/.test(monthCode)) {\n        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n      }\n    }\n    if (this.hasEra) {\n      if ((calendarDate['era'] === undefined) !== (calendarDate['eraYear'] === undefined)) {\n        throw new TypeError('properties era and eraYear must be provided together');\n      }\n    }\n  }\n  /**\n   * Allows derived calendars to add additional fields and/or to make\n   * adjustments e.g. to set the era based on the date or to revise the month\n   * number in lunisolar calendars per\n   * https://github.com/tc39/proposal-temporal/issues/1203.\n   *\n   * The base implementation fills in missing values by assuming the simplest\n   * possible calendar:\n   * - no eras\n   * - non-lunisolar calendar (no leap months)\n   * */\n  adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache: OneObjectCache | undefined = undefined,\n    overflow: Overflow = 'constrain',\n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    if (this.calendarType === 'lunisolar') throw new RangeError('Override required for lunisolar calendars');\n    let calendarDate = calendarDateParam;\n    this.validateCalendarDate(calendarDate);\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, monthCode } = calendarDate;\n\n    ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n    return { ...(calendarDate as typeof calendarDate & CalendarYMD), month, monthCode };\n  }\n  regulateMonthDayNaive(calendarDate: FullCalendarDate, overflow: Overflow, cache: OneObjectCache): FullCalendarDate {\n    const largestMonth = this.monthsInYear(calendarDate, cache);\n    let { month, day } = calendarDate;\n    if (overflow === 'reject') {\n      ES.RejectToRange(month, 1, largestMonth);\n      ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n    } else {\n      month = ES.ConstrainToRange(month, 1, largestMonth);\n      day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n    }\n    return { ...calendarDate, month, day };\n  }\n  calendarToIsoDate(dateParam: CalendarDateFields, overflow: Overflow = 'constrain', cache: OneObjectCache): ISODate {\n    const originalDate = dateParam as Partial<FullCalendarDate>;\n    // First, normalize the calendar date to ensure that (year, month, day)\n    // are all present, converting monthCode and eraYear if needed.\n    let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n\n    // Fix obviously out-of-bounds values. Values that are valid generally, but\n    // not in this particular year, may not be caught here for some calendars.\n    // If so, these will be handled lower below.\n    date = this.regulateMonthDayNaive(date, overflow, cache);\n\n    const { year, month, day } = date;\n    const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n    let cached = cache.get(key);\n    if (cached) return cached;\n    // If YMD are present in the input but the input has been constrained\n    // already, then cache both the original value and the constrained value.\n    let keyOriginal;\n    if (\n      originalDate.year !== undefined &&\n      originalDate.month !== undefined &&\n      originalDate.day !== undefined &&\n      (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)\n    ) {\n      keyOriginal = JSON.stringify({\n        func: 'calendarToIsoDate',\n        year: originalDate.year,\n        month: originalDate.month,\n        day: originalDate.day,\n        overflow,\n        id: this.id\n      });\n      cached = cache.get(keyOriginal);\n      if (cached) return cached;\n    }\n\n    // First, try to roughly guess the result\n    let isoEstimate = this.estimateIsoDate({ year, month, day });\n    const calculateSameMonthResult = (diffDays: number) => {\n      // If the estimate is in the same year & month as the target, then we can\n      // calculate the result exactly and short-circuit any additional logic.\n      // This optimization assumes that months are continuous. It would break if\n      // a calendar skipped days, like the Julian->Gregorian switchover. But\n      // current ICU calendars only skip days (japanese/roc/buddhist) because of\n      // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n      // that's currently worked around by a custom calendarToIsoDate\n      // implementation in those calendars. So this optimization should be safe\n      // for all ICU calendars.\n      let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n      if (date.day > this.minimumMonthLength(date)) {\n        // There's a chance that the calendar date is out of range. Throw or\n        // constrain if so.\n        let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n          if (overflow === 'reject') {\n            throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n          }\n          // Back up a day at a time until we're not hanging over the month end\n          testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n          testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n        }\n      }\n      return testIsoEstimate;\n    };\n    let sign = 0;\n    let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n    let diff = simpleDateDiff(date, roundtripEstimate);\n    if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n      const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n      isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      diff = simpleDateDiff(date, roundtripEstimate);\n      if (diff.years === 0 && diff.months === 0) {\n        isoEstimate = calculateSameMonthResult(diff.days);\n      } else {\n        sign = this.compareCalendarDates(date, roundtripEstimate);\n      }\n    }\n    // If the initial guess is not in the same month, then bisect the\n    // distance to the target, starting with 8 days per step.\n    let increment = 8;\n    while (sign) {\n      isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n      const oldRoundtripEstimate = roundtripEstimate;\n      roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n      const oldSign = sign;\n      sign = this.compareCalendarDates(date, roundtripEstimate);\n      if (sign) {\n        diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years === 0 && diff.months === 0) {\n          isoEstimate = calculateSameMonthResult(diff.days);\n          // Signal the loop condition that there's a match.\n          sign = 0;\n        } else if (oldSign && sign !== oldSign) {\n          if (increment > 1) {\n            // If the estimate overshot the target, try again with a smaller increment\n            // in the reverse direction.\n            increment /= 2;\n          } else {\n            // Increment is 1, and neither the previous estimate nor the new\n            // estimate is correct. The only way that can happen is if the\n            // original date was an invalid value that will be constrained or\n            // rejected here.\n            if (overflow === 'reject') {\n              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n            } else {\n              // To constrain, pick the earliest value\n              const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n              // If current value is larger, then back up to the previous value.\n              if (order > 0) isoEstimate = this.addDaysIso(isoEstimate, -1);\n              sign = 0;\n            }\n          }\n        }\n      }\n    }\n    cache.set(key, isoEstimate);\n    if (keyOriginal) cache.set(keyOriginal, isoEstimate);\n    if (\n      date.year === undefined ||\n      date.month === undefined ||\n      date.day === undefined ||\n      date.monthCode === undefined ||\n      (this.hasEra && (date.era === undefined || date.eraYear === undefined))\n    ) {\n      throw new RangeError('Unexpected missing property');\n    }\n    return isoEstimate;\n  }\n  compareCalendarDates(date1: CalendarYMD, date2: CalendarYMD) {\n    if (date1.year !== date2.year) return ES.ComparisonResult(date1.year - date2.year);\n    if (date1.month !== date2.month) return ES.ComparisonResult(date1.month - date2.month);\n    if (date1.day !== date2.day) return ES.ComparisonResult(date1.day - date2.day);\n    return 0;\n  }\n  /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n  regulateDate(calendarDate: CalendarYMD, overflow: Overflow = 'constrain', cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n    return this.isoToCalendarDate(isoDate, cache);\n  }\n  addDaysIso(isoDate: ISODate, days: number): ISODate {\n    const added = ES.BalanceISODate(isoDate.year, isoDate.month, isoDate.day + days);\n    return added;\n  }\n  addDaysCalendar(calendarDate: CalendarYMD, days: number, cache: OneObjectCache): FullCalendarDate {\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIso = this.addDaysIso(isoDate, days);\n    const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n    return addedCalendar;\n  }\n  addMonthsCalendar(\n    calendarDateParam: CalendarYMD,\n    months: number,\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): CalendarYMD {\n    let calendarDate = calendarDateParam;\n    const { day } = calendarDate;\n    for (let i = 0, absMonths = Math.abs(months); i < absMonths; i++) {\n      const { month } = calendarDate;\n      const oldCalendarDate = calendarDate;\n      const days =\n        months < 0\n          ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n          : this.daysInMonth(calendarDate, cache);\n      const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n      let addedIso = this.addDaysIso(isoDate, days);\n      calendarDate = this.isoToCalendarDate(addedIso, cache);\n\n      // Normally, we can advance one month by adding the number of days in the\n      // current month. However, if we're at the end of the current month and\n      // the next month has fewer days, then we rolled over to the after-next\n      // month. Below we detect this condition and back up until we're back in\n      // the desired month.\n      if (months > 0) {\n        const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n        while (calendarDate.month - 1 !== month % monthsInOldYear) {\n          addedIso = this.addDaysIso(addedIso, -1);\n          calendarDate = this.isoToCalendarDate(addedIso, cache);\n        }\n      }\n\n      if (calendarDate.day !== day) {\n        // try to retain the original day-of-month, if possible\n        calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n      }\n    }\n    if (overflow === 'reject' && calendarDate.day !== day) {\n      throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n    }\n    return calendarDate;\n  }\n  addCalendar(\n    calendarDate: CalendarYMD & { monthCode: string },\n    { years = 0, months = 0, weeks = 0, days = 0 },\n    overflow: Overflow,\n    cache: OneObjectCache\n  ): FullCalendarDate {\n    const { year, day, monthCode } = calendarDate;\n    const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n    const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n    const initialDays = days + weeks * 7;\n    const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n    return addedDays;\n  }\n  untilCalendar(\n    calendarOne: FullCalendarDate,\n    calendarTwo: FullCalendarDate,\n    largestUnit: Temporal.DateUnit,\n    cache: OneObjectCache\n  ): { years: number; months: number; weeks: number; days: number } {\n    let days = 0;\n    let weeks = 0;\n    let months = 0;\n    let years = 0;\n    switch (largestUnit) {\n      case 'day':\n        days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        break;\n      case 'week': {\n        const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n        days = totalDays % 7;\n        weeks = (totalDays - days) / 7;\n        break;\n      }\n      case 'month':\n      case 'year': {\n        const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n        if (!sign) {\n          return { years: 0, months: 0, weeks: 0, days: 0 };\n        }\n        const diffYears = calendarTwo.year - calendarOne.year;\n        const diffDays = calendarTwo.day - calendarOne.day;\n        if (largestUnit === 'year' && diffYears) {\n          let diffInYearSign = 0;\n          if (calendarTwo.monthCode > calendarOne.monthCode) diffInYearSign = 1;\n          if (calendarTwo.monthCode < calendarOne.monthCode) diffInYearSign = -1;\n          if (!diffInYearSign) diffInYearSign = Math.sign(diffDays);\n          const isOneFurtherInYear = diffInYearSign * sign < 0;\n          years = isOneFurtherInYear ? diffYears - sign : diffYears;\n        }\n        const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n        // Now we have less than one year remaining. Add one month at a time\n        // until we go over the target, then back up one month and calculate\n        // remaining days and weeks.\n        let current;\n        let next: CalendarYMD = yearsAdded;\n        do {\n          months += sign;\n          current = next;\n          next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n          if (next.day !== calendarOne.day) {\n            // In case the day was constrained down, try to un-constrain it\n            next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n          }\n        } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n        months -= sign; // correct for loop above which overshoots by 1\n        const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n        days = remainingDays;\n        break;\n      }\n    }\n    return { years, months, weeks, days };\n  }\n  daysInMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    // Add enough days to roll over to the next month. One we're in the next\n    // month, we can calculate the length of the current month. NOTE: This\n    // algorithm assumes that months are continuous. It would break if a\n    // calendar skipped days, like the Julian->Gregorian switchover. But current\n    // ICU calendars only skip days (japanese/roc/buddhist) because of a bug\n    // (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158) that's\n    // currently worked around by a custom calendarToIsoDate implementation in\n    // those calendars. So this code should be safe for all ICU calendars.\n    const { day } = calendarDate;\n    const max = this.maximumMonthLength(calendarDate);\n    const min = this.minimumMonthLength(calendarDate);\n    // easiest case: we already know the month length if min and max are the same.\n    if (min === max) return min;\n\n    // Add enough days to get into the next month, without skipping it\n    const increment = day <= max - min ? max : min;\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const addedIsoDate = this.addDaysIso(isoDate, increment);\n    const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n\n    // Now back up to the last day of the original month\n    const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n    const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n    return endOfMonthCalendar.day;\n  }\n  daysInPreviousMonth(calendarDate: CalendarYMD, cache: OneObjectCache): number {\n    const { day, month, year } = calendarDate;\n\n    // Check to see if we already know the month length, and return it if so\n    const previousMonthYear = month > 1 ? year : year - 1;\n    let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n    const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n    previousMonthDate = { ...previousMonthDate, month: previousMonth };\n    const min = this.minimumMonthLength(previousMonthDate);\n    const max = this.maximumMonthLength(previousMonthDate);\n    if (min === max) return max;\n\n    const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n    const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n    const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n    return lastDayOfPreviousMonthCalendar.day;\n  }\n  startOfCalendarYear(calendarDate: CalendarYearOnly): CalendarYMD & { monthCode: string } {\n    return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n  }\n  startOfCalendarMonth(calendarDate: CalendarYM): CalendarYMD {\n    return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n  }\n  calendarDaysUntil(calendarOne: CalendarYMD, calendarTwo: CalendarYMD, cache: OneObjectCache): number {\n    const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n    const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n    return (\n      ES.ISODateToEpochDays(twoIso.year, twoIso.month - 1, twoIso.day) -\n      ES.ISODateToEpochDays(oneIso.year, oneIso.month - 1, oneIso.day)\n    );\n  }\n  // Override if calendar uses eras\n  hasEra = false;\n  // See https://github.com/tc39/proposal-temporal/issues/1784\n  erasBeginMidYear = false;\n  // Override this to shortcut the search space if certain month codes only\n  // occur long in the past\n  monthDaySearchStartYear(monthCode: string, day: number) {\n    void monthCode, day;\n    return 1972;\n  }\n  monthDayFromFields(fields: MonthDayFromFieldsObject, overflow: Overflow, cache: OneObjectCache): ISODate {\n    let { era, eraYear, year, month, monthCode, day } = fields;\n    if (month !== undefined && year === undefined && (!this.hasEra || era === undefined || eraYear === undefined)) {\n      throw new TypeError('when month is present, year (or era and eraYear) are required');\n    }\n    if (monthCode === undefined || year !== undefined || (this.hasEra && eraYear !== undefined)) {\n      // Apply overflow behaviour to year/month/day, to get correct monthCode/day\n      ({ monthCode, day } = this.isoToCalendarDate(this.calendarToIsoDate(fields, overflow, cache), cache));\n    }\n\n    let isoYear, isoMonth, isoDay;\n    let closestCalendar, closestIso;\n    // Look backwards starting from one of the calendar years spanning ISO year\n    // 1972, up to 20 calendar years prior, to find a year that has this month\n    // and day. Normal months and days will match immediately, but for leap days\n    // and leap months we may have to look for a while. For searches longer than\n    // 20 years, override the start date in monthDaySearchStartYear.\n    const startDateIso = {\n      year: this.monthDaySearchStartYear(monthCode, day),\n      month: 12,\n      day: 31\n    };\n    const calendarOfStartDateIso = this.isoToCalendarDate(startDateIso, cache);\n    // Note: relies on lexicographical ordering of monthCodes\n    const calendarYear =\n      calendarOfStartDateIso.monthCode > monthCode ||\n      (calendarOfStartDateIso.monthCode === monthCode && calendarOfStartDateIso.day >= day)\n        ? calendarOfStartDateIso.year\n        : calendarOfStartDateIso.year - 1;\n    for (let i = 0; i < 20; i++) {\n      const testCalendarDate: FullCalendarDate = this.adjustCalendarDate(\n        { day, monthCode, year: calendarYear - i },\n        cache\n      );\n      const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n      const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n      ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n      if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n        return { month: isoMonth, day: isoDay, year: isoYear };\n      } else if (overflow === 'constrain') {\n        // If the requested day is never present in any instance of this month\n        // code, and the round trip date is an instance of this month code with\n        // the most possible days, we are as close as we can get.\n        const maxDayForMonthCode = this.maxLengthOfMonthCodeInAnyYear(roundTripCalendarDate.monthCode);\n        if (\n          roundTripCalendarDate.monthCode === monthCode &&\n          roundTripCalendarDate.day === maxDayForMonthCode &&\n          day > maxDayForMonthCode\n        ) {\n          return { month: isoMonth, day: isoDay, year: isoYear };\n        }\n        // non-ISO constrain algorithm tries to find the closest date in a matching month\n        if (\n          closestCalendar === undefined ||\n          (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n            roundTripCalendarDate.day > closestCalendar.day)\n        ) {\n          closestCalendar = roundTripCalendarDate;\n          closestIso = isoDate;\n        }\n      }\n    }\n    if (overflow === 'constrain' && closestIso !== undefined) return closestIso;\n    throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n  }\n  getFirstDayOfWeek(): number | undefined {\n    return undefined;\n  }\n  getMinimalDaysInFirstWeek(): number | undefined {\n    return undefined;\n  }\n}\n\ninterface HebrewMonthInfo {\n  [m: string]: (\n    | {\n        leap: undefined;\n        regular: number;\n      }\n    | {\n        leap: number;\n        regular: undefined;\n      }\n    | {\n        leap: number;\n        regular: number;\n      }\n  ) & {\n    monthCode: string;\n    days:\n      | number\n      | {\n          min: number;\n          max: number;\n        };\n  };\n}\n\nclass HebrewHelper extends HelperBase {\n  id = 'hebrew' as const;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = calendarDate;\n    // FYI: In addition to adding a month in leap years, the Hebrew calendar\n    // also has per-year changes to the number of days of Heshvan and Kislev.\n    // Given that these can be calculated by counting the number of days in\n    // those months, I assume that these DO NOT need to be exposed as\n    // Hebrew-only prototype fields or methods.\n    return (7 * year + 1) % 19 < 7;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly) {\n    return this.inLeapYear(calendarDate) ? 13 : 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'min');\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minMaxMonthLength(calendarDate, 'max');\n  }\n  minMaxMonthLength(calendarDate: CalendarYM, minOrMax: 'min' | 'max') {\n    const { month, year } = calendarDate;\n    const monthCode = this.getMonthCode(year, month);\n    const monthInfo = Object.entries(this.months).find((m) => m[1].monthCode === monthCode);\n    if (monthInfo === undefined) throw new RangeError(`unmatched Hebrew month: ${month}`);\n    const daysInMonth = monthInfo[1].days;\n    return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    return ['M04', 'M06', 'M08', 'M10', 'M12'].includes(monthCode) ? 29 : 30;\n  }\n  /** Take a guess at what ISO date a particular calendar date corresponds to */\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = calendarDate;\n    return { year: year - 3760, month: 1, day: 1 };\n  }\n  months: HebrewMonthInfo = {\n    Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n    Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n    Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n    Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n    Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n    Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n    'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n    'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n    Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n    Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n    Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n    Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n    Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n    Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n  };\n  getMonthCode(year: number, month: number) {\n    if (this.inLeapYear({ year })) {\n      return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n    } else {\n      return buildMonthCode(month);\n    }\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthCode, day, monthExtra } = calendarDate as Omit<typeof calendarDate, 'day'> & {\n      day: number;\n    };\n    if (year === undefined) throw new TypeError('Missing property: year');\n    if (fromLegacyDate) {\n      // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n      // output returns the numeric equivalent of `month` as a string, meaning\n      // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n      // means Adar. In this case, `month` will already be correct and no action\n      // is needed. However, in Node 14 and later formatToParts returns the name\n      // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n      // correct `month` using the string name as a key.\n      if (monthExtra) {\n        const monthInfo = this.months[monthExtra];\n        if (!monthInfo) throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n        month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n      }\n      // Because we're getting data from legacy Date, then `month` will always be present\n      monthCode = this.getMonthCode(year, month as number);\n      return { year, month: month as number, day, monthCode };\n    } else {\n      // When called without input coming from legacy Date output, simply ensure\n      // that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        if (monthCode.endsWith('L')) {\n          if (monthCode !== 'M05L') {\n            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n          }\n          month = 6;\n          if (!this.inLeapYear({ year })) {\n            if (overflow === 'reject') {\n              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n            } else {\n              // constrain to same day of next month (Adar)\n              month = 6;\n              monthCode = 'M06';\n            }\n          }\n        } else {\n          month = nonLeapMonthCodeNumberPart(monthCode);\n          // if leap month is before this one, the month index is one more than the month code\n          if (this.inLeapYear({ year }) && month >= 6) month++;\n          const largestMonth = this.monthsInYear({ year });\n          if (month < 1 || month > largestMonth) throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n      } else {\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n          ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n        } else {\n          month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n        }\n        if (monthCode === undefined) {\n          monthCode = this.getMonthCode(year, month);\n        } else {\n          const calculatedMonthCode = this.getMonthCode(year, month);\n          if (calculatedMonthCode !== monthCode) {\n            throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n          }\n        }\n      }\n      return { ...calendarDate, day, month, monthCode, year };\n    }\n  }\n}\n\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nabstract class IslamicBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const startOfYearCalendar = { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n    const startOfNextYearCalendar = { year: calendarDate.year + 1, month: 1, monthCode: 'M01', day: 1 };\n    const result = this.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    return result === 355;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(/* monthCode */) {\n    return 30;\n  }\n  DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n  DAYS_PER_ISO_YEAR = 365.2425;\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: Math.floor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n  }\n}\n\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n  id = 'islamic' as const;\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n  id = 'islamic-umalqura' as const;\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n  id = 'islamic-tbla' as const;\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n  id = 'islamic-civil' as const;\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n  id = 'islamic-rgsa' as const;\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n  id = 'islamicc' as const;\n}\n\nclass PersianHelper extends HelperBase {\n  id = 'persian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    // If the last month has 30 days, it's a leap year.\n    return this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache) === 30;\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 29;\n    return month <= 6 ? 31 : 30;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    if (month === 12) return 30;\n    return month <= 6 ? 31 : 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return month <= 6 ? 31 : 30;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year } = this.adjustCalendarDate(calendarDate);\n    return { year: year + 621, month: 1, day: 1 };\n  }\n}\n\ninterface IndianMonthInfo {\n  [month: number]: {\n    length: number;\n    month: number;\n    day: number;\n    leap?: {\n      length: number;\n      month: number;\n      day: number;\n    };\n    nextYear?: true | undefined;\n  };\n}\n\nclass IndianHelper extends HelperBase {\n  id = 'indian' as const;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n    // Years are counted in the Saka era, which starts its year 0 in the year 78\n    // of the Common Era. To determine leap years, add 78 to the Saka year – if\n    // the result is a leap year in the Gregorian calendar, then the Saka year\n    // is a leap year as well.\n    return isGregorianLeapYear(calendarDate.year + 78);\n  }\n  monthsInYear(/* calendarYear, cache */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.getMonthInfo(calendarDate).length;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    let monthInfo = this.months[month];\n    monthInfo = monthInfo.leap ?? monthInfo;\n    return monthInfo.length;\n  }\n  // Indian months always start at the same well-known Gregorian month and\n  // day. So this conversion is easy and fast. See\n  // https://en.wikipedia.org/wiki/Indian_national_calendar\n  months: IndianMonthInfo = {\n    1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n    2: { length: 31, month: 4, day: 21 },\n    3: { length: 31, month: 5, day: 22 },\n    4: { length: 31, month: 6, day: 22 },\n    5: { length: 31, month: 7, day: 23 },\n    6: { length: 31, month: 8, day: 23 },\n    7: { length: 30, month: 9, day: 23 },\n    8: { length: 30, month: 10, day: 23 },\n    9: { length: 30, month: 11, day: 22 },\n    10: { length: 30, month: 12, day: 22 },\n    11: { length: 30, month: 1, nextYear: true, day: 21 },\n    12: { length: 30, month: 2, nextYear: true, day: 20 }\n  };\n  getMonthInfo(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    let monthInfo = this.months[month];\n    if (monthInfo === undefined) throw new RangeError(`Invalid month: ${month}`);\n    if (this.inLeapYear(calendarDate) && monthInfo.leap) monthInfo = monthInfo.leap;\n    return monthInfo;\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n    // calendar fast!\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const monthInfo = this.getMonthInfo(calendarDate);\n    const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n    const isoMonth = monthInfo.month;\n    const isoDay = monthInfo.day;\n    const isoDate = ES.BalanceISODate(isoYear, isoMonth, isoDay + calendarDate.day - 1);\n    return isoDate;\n  }\n  // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n  // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n  // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n  // expected.\n  vulnerableToBceBug =\n    new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n  override checkIcuBugs(isoDate: ISODate) {\n    if (this.vulnerableToBceBug && isoDate.year < 1) {\n      throw new RangeError(\n        `calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n          ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)'\n      );\n    }\n  }\n}\n\n/**\n * Era metadata defined for each calendar.\n * TODO: instead of optional properties, this should really have rules\n * encoded in the type, e.g. isoEpoch is required unless reverseOf is present.\n *  */\ninterface InputEra {\n  /**\n   * Era code, used to populate the 'era' field of Temporal instances.\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   */\n  code: string;\n\n  /**\n   * Names are additionally accepted as alternate era codes on input, and the\n   * first name is also output in error messages (and may be the era code if\n   * desired.)\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   * If absent, this field defaults to a single element matching the code.\n   */\n  names?: string[];\n\n  /**\n   * Signed calendar year where this era begins.Will be\n   * 1 (or 0 for zero-based eras) for the anchor era assuming that `year`\n   * numbering starts at the beginning of the anchor era, which is true\n   * for all ICU calendars except Japanese. If an era starts mid-year\n   * then a calendar month and day are included. Otherwise\n   * `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch?: CalendarYearOnly | CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch?: { year: number; month: number; day: number };\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: string;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n/**\n * Transformation of the `InputEra` type with all fields filled in by\n * `adjustEras()`\n * */\ninterface Era {\n  /**\n   * Era code, used to populate the 'era' field of Temporal instances.\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   */\n  code: string;\n\n  /**\n   * Names are additionally accepted as alternate era codes on input, and the\n   * first name is also output in error messages (and may be the era code if\n   * desired.)\n   * See https://tc39.es/proposal-intl-era-monthcode/#table-eras\n   * If absent, this field defaults to a single element matching the code.\n   */\n  names: string[];\n\n  /**\n   * alternate name of the era used in old versions of ICU data\n   * format is `era{n}` where n is the zero-based index of the era\n   * with the oldest era being 0.\n   * */\n  genericName: string;\n\n  /**\n   * Signed calendar year where this era begins. Will be 1 (or 0 for zero-based\n   * eras) for the anchor era assuming that `year` numbering starts at the\n   * beginning of the anchor era, which is true for all ICU calendars except\n   * Japanese. For input, the month and day are optional. If an era starts\n   * mid-year then a calendar month and day are included.\n   * Otherwise `{ month: 1, day: 1 }` is assumed.\n   */\n  anchorEpoch: CalendarYMD;\n\n  /** ISO date of the first day of this era */\n  isoEpoch: ISODate;\n\n  /**\n   * If present, then this era counts years backwards like BC\n   * and this property points to the forward era. This must be\n   * the last (oldest) era in the array.\n   * */\n  reverseOf?: Era;\n\n  /**\n   * If true, the era's years are 0-based. If omitted or false,\n   * then the era's years are 1-based.\n   * */\n  hasYearZero?: boolean;\n\n  /**\n   * Override if this era is the anchor. Not normally used because\n   * anchor eras are inferred.\n   * */\n  isAnchor?: boolean;\n}\n\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam: InputEra[]): { eras: Era[]; anchorEra: Era } {\n  let eras: (InputEra | Era)[] = erasParam;\n  if (eras.length === 0) {\n    throw new RangeError('Invalid era data: eras are required');\n  }\n  if (eras.length === 1 && eras[0].reverseOf) {\n    throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n  }\n  if (eras.length === 1 && !eras[0].code) {\n    throw new RangeError('Invalid era data: at least one named era is required');\n  }\n  if (eras.filter((e) => e.reverseOf != null).length > 1) {\n    throw new RangeError('Invalid era data: only one era can count years backwards');\n  }\n\n  // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n  // eras can never be anchors. The era without an `anchorEpoch` property is the\n  // anchor.\n  let anchorEra: Era | InputEra | undefined;\n  eras.forEach((e) => {\n    if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n      if (anchorEra) throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n      anchorEra = e;\n      e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n    } else if (!e.code) {\n      throw new RangeError('If era name is blank, it must be the anchor era');\n    }\n  });\n\n  // If the era name is undefined, then it's an anchor that doesn't interact\n  // with eras at all. For example, Japanese `year` is always the same as ISO\n  // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n  // Strip it from the list that's returned.\n  eras = eras.filter((e) => e.code);\n\n  eras.forEach((e) => {\n    // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n    // Replace the string-valued \"reverseOf\" property with the actual era object\n    // that's reversed.\n    const { reverseOf } = e;\n    if (reverseOf) {\n      const reversedEra = eras.find((era) => era.code === reverseOf);\n      if (reversedEra === undefined) {\n        throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n      }\n      e.reverseOf = reversedEra as Era; // genericName property added later\n      e.anchorEpoch = reversedEra.anchorEpoch;\n      e.isoEpoch = reversedEra.isoEpoch;\n    }\n    type YMD = {\n      year: number;\n      month: number;\n      day: number;\n    };\n    if ((e.anchorEpoch as YMD).month === undefined) (e.anchorEpoch as YMD).month = 1;\n    if ((e.anchorEpoch as YMD).day === undefined) (e.anchorEpoch as YMD).day = 1;\n  });\n\n  // Ensure that the latest epoch is first in the array. This lets us try to\n  // match eras in index order, with the last era getting the remaining older\n  // years. Any reverse-signed era must be at the end.\n  eras.sort((e1, e2) => {\n    if (e1.reverseOf) return 1;\n    if (e2.reverseOf) return -1;\n    if (!e1.isoEpoch || !e2.isoEpoch) throw new RangeError('Invalid era data: missing ISO epoch');\n    return e2.isoEpoch.year - e1.isoEpoch.year;\n  });\n\n  // If there's a reversed era, then the one before it must be the era that's\n  // being reversed.\n  const lastEraReversed = eras[eras.length - 1].reverseOf;\n  if (lastEraReversed) {\n    if (lastEraReversed !== eras[eras.length - 2]) {\n      throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n  }\n\n  // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n  // zero-based index, with the oldest era being zero. This format is used by\n  // older versions of ICU data.\n  eras.forEach((e, i) => {\n    (e as Era).genericName = `era${eras.length - 1 - i}`;\n  });\n\n  return { eras: eras as Era[], anchorEra: (anchorEra || eras[0]) as Era };\n}\n\nfunction isGregorianLeapYear(year: number) {\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n/** Base for all Gregorian-like calendars. */\nabstract class GregorianBaseHelperFixedEpoch extends HelperBase {\n  id: BuiltinCalendarId;\n  isoEpoch: ISODate;\n\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\n    super();\n    this.id = id;\n    this.isoEpoch = isoEpoch;\n  }\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    return ES.RegulateISODate(\n      calendarDate.year + this.isoEpoch.year,\n      calendarDate.month + this.isoEpoch.month,\n      calendarDate.day + this.isoEpoch.day,\n      'constrain'\n    );\n  }\n}\n\n/** Base for Gregorian-like calendars with eras. */\nabstract class GregorianBaseHelper extends HelperBase {\n  id: BuiltinCalendarId;\n  anchorEra: Era;\n\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super();\n    this.id = id;\n    const { eras, anchorEra } = adjustEras(originalEras);\n    this.anchorEra = anchorEra;\n    this.eras = eras;\n  }\n  override hasEra = true;\n  calendarType = 'solar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Calendars that don't override this method use the same months and leap\n    // years as Gregorian. Once we know the ISO year corresponding to the\n    // calendar year, we'll know if it's a leap year or not.\n    const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n    return isGregorianLeapYear(year);\n  }\n  monthsInYear(/* calendarDate */) {\n    return 12;\n  }\n  minimumMonthLength(calendarDate: CalendarYM): number {\n    const { month } = calendarDate;\n    if (month === 2) return this.inLeapYear(calendarDate) ? 29 : 28;\n    return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n  }\n  maximumMonthLength(calendarDate: CalendarYM): number {\n    return this.minimumMonthLength(calendarDate);\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    const month = nonLeapMonthCodeNumberPart(monthCode);\n    return [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month - 1];\n  }\n  /** Fill in missing parts of the (year, era, eraYear) tuple */\n  completeEraYear(\n    calendarDate: FullCalendarDate\n  ): FullCalendarDate & Required<Pick<FullCalendarDate, 'era' | 'eraYear'>> {\n    const checkField = (property: keyof FullCalendarDate, value: string | number | undefined, names?: string[]) => {\n      const currentValue = calendarDate[property];\n      if (currentValue != null && currentValue != value && !((names || []) as unknown[]).includes(currentValue)) {\n        // Prefer displaying an era alias, instead of \"gregory-inverse\"\n        const preferredName = names?.[0];\n        const expected = preferredName ? `${value} (also called ${preferredName})` : value;\n        throw new RangeError(`Input ${property} ${currentValue} doesn't match calculated value ${expected}`);\n      }\n    };\n    const eraFromYear = (year: number) => {\n      let eraYear;\n      const adjustedCalendarDate = { ...calendarDate, year };\n      const matchingEra = this.eras.find((e, i) => {\n        if (i === this.eras.length - 1) {\n          if (e.reverseOf) {\n            // This is a reverse-sign era (like BCE) which must be the oldest\n            // era. Count years backwards.\n            if (year > 0) throw new RangeError(`Signed year ${year} is invalid for era ${e.code}`);\n            eraYear = e.anchorEpoch.year - year;\n            return true;\n          }\n          // last era always gets all \"leftover\" (older than epoch) years,\n          // so no need for a comparison like below.\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n        if (comparison >= 0) {\n          eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n          return true;\n        }\n        return false;\n      });\n      if (!matchingEra) throw new RangeError(`Year ${year} was not matched by any era`);\n      return { eraYear: eraYear as unknown as number, era: matchingEra.code, eraNames: matchingEra.names };\n    };\n\n    let { year, eraYear, era } = calendarDate;\n    if (year != null) {\n      const matchData = eraFromYear(year);\n      ({ eraYear, era } = matchData);\n      checkField('era', era, matchData?.eraNames);\n      checkField('eraYear', eraYear);\n    } else if (eraYear != null) {\n      if (era === undefined) throw new RangeError('era and eraYear must be provided together');\n      // TS limitation: https://github.com/microsoft/TypeScript/issues/11498\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const matchingEra = this.eras.find(({ code, names = [] }) => code === era || names.includes(era!));\n      if (!matchingEra) throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n      if (matchingEra.reverseOf) {\n        year = matchingEra.anchorEpoch.year - eraYear;\n      } else {\n        year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n      }\n      checkField('year', year);\n      // We'll accept dates where the month/day is earlier than the start of\n      // the era or after its end as long as it's in the same year. If that\n      // happens, we'll adjust the era/eraYear pair to be the correct era for\n      // the `year`.\n      ({ eraYear, era } = eraFromYear(year));\n    } else {\n      throw new RangeError('Either year or eraYear and era are required');\n    }\n    return { ...calendarDate, year, eraYear, era };\n  }\n  override adjustCalendarDate(\n    calendarDateParam: Partial<FullCalendarDate>,\n    cache?: OneObjectCache,\n    overflow: Overflow = 'constrain'\n  ): FullCalendarDate {\n    let calendarDate = calendarDateParam;\n    // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n    const { month, monthCode } = calendarDate;\n    if (month === undefined) calendarDate = { ...calendarDate, month: nonLeapMonthCodeNumberPart(monthCode as string) };\n    this.validateCalendarDate(calendarDate);\n    calendarDate = this.completeEraYear(calendarDate);\n    return super.adjustCalendarDate(calendarDate, cache, overflow);\n  }\n  estimateIsoDate(calendarDateParam: CalendarYMD) {\n    const calendarDate = this.adjustCalendarDate(calendarDateParam);\n    const { year, month, day } = calendarDate;\n    const { anchorEra } = this;\n    const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n    return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n  }\n}\n\n/**\n * Some calendars are identical to Gregorian except era and year. For these\n * calendars, we can avoid using Intl.DateTimeFormat and just calculate the\n * year, era, and eraYear. This is faster (because Intl.DateTimeFormat is slow\n * and uses a huge amount of RAM), and it avoids ICU bugs like\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n */\nabstract class SameMonthDayAsGregorianBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override isoToCalendarDate(isoDate: ISODate): FullCalendarDate {\n    // Month and day are same as ISO, so bypass Intl.DateTimeFormat and\n    // calculate the year, era, and eraYear here.\n    const { year: isoYear, month, day } = isoDate;\n    const monthCode = buildMonthCode(month);\n    const year = isoYear - this.anchorEra.isoEpoch.year + 1;\n    return this.completeEraYear({ year, month, monthCode, day });\n  }\n}\nconst OrthodoxOps = {\n  inLeapYear(calendarDate: CalendarYearOnly) {\n    // Leap years happen one year before the Julian leap year. Note that this\n    // calendar is based on the Julian calendar which has a leap year every 4\n    // years, unlike the Gregorian calendar which doesn't have leap years on\n    // years divisible by 100 except years divisible by 400.\n    //\n    // Note that we're assuming that leap years in before-epoch times match\n    // how leap years are defined now. This is probably not accurate but I'm\n    // not sure how better to do it.\n    const { year } = calendarDate;\n    return (year + 1) % 4 === 0;\n  },\n  monthsInYear(/* calendarDate */) {\n    return 13;\n  },\n  minimumMonthLength(calendarDate: CalendarYM) {\n    const { month } = calendarDate;\n    // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n    if (month === 13) return this.inLeapYear(calendarDate) ? 6 : 5;\n    return 30;\n  },\n  maximumMonthLength(calendarDate: CalendarYM) {\n    return this.minimumMonthLength(calendarDate);\n  },\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    return monthCode === 'M13' ? 6 : 30;\n  }\n};\nabstract class OrthodoxBaseHelperFixedEpoch extends GregorianBaseHelperFixedEpoch {\n  constructor(id: BuiltinCalendarId, isoEpoch: ISODate) {\n    super(id, isoEpoch);\n  }\n  override inLeapYear = OrthodoxOps.inLeapYear;\n  override monthsInYear = OrthodoxOps.monthsInYear;\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\n}\nabstract class OrthodoxBaseHelper extends GregorianBaseHelper {\n  constructor(id: BuiltinCalendarId, originalEras: InputEra[]) {\n    super(id, originalEras);\n  }\n  override inLeapYear = OrthodoxOps.inLeapYear;\n  override monthsInYear = OrthodoxOps.monthsInYear;\n  override minimumMonthLength = OrthodoxOps.minimumMonthLength;\n  override maximumMonthLength = OrthodoxOps.maximumMonthLength;\n  override maxLengthOfMonthCodeInAnyYear = OrthodoxOps.maxLengthOfMonthCodeInAnyYear;\n}\n\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelperFixedEpoch {\n  constructor() {\n    super('ethioaa', { year: -5492, month: 7, day: 17 });\n  }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('coptic', [\n      { code: 'coptic', isoEpoch: { year: 284, month: 8, day: 29 } },\n      { code: 'coptic-inverse', reverseOf: 'coptic' }\n    ]);\n  }\n}\n\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n  constructor() {\n    super('ethiopic', [\n      { code: 'ethioaa', names: ['ethiopic-amete-alem', 'mundi'], isoEpoch: { year: -5492, month: 7, day: 17 } },\n      { code: 'ethiopic', names: ['incar'], isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n    ]);\n  }\n}\n\nclass RocHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('roc', [\n      { code: 'roc', names: ['minguo'], isoEpoch: { year: 1912, month: 1, day: 1 } },\n      { code: 'roc-inverse', names: ['before-roc'], reverseOf: 'roc' }\n    ]);\n  }\n}\n\nclass BuddhistHelper extends GregorianBaseHelperFixedEpoch {\n  constructor() {\n    super('buddhist', { year: -543, month: 1, day: 1 });\n  }\n}\n\nclass GregoryHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('gregory', [\n      { code: 'gregory', names: ['ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\n      { code: 'gregory-inverse', names: ['be', 'bce'], reverseOf: 'gregory' }\n    ]);\n  }\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T /*, isoDate: IsoDate*/): T {\n    let { era, eraYear } = calendarDate;\n    // Firefox 96 introduced a bug where the `'short'` format of the era\n    // option mistakenly returns the one-letter (narrow) format instead. The\n    // code below handles either the correct or Firefox-buggy format. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n    if (era === 'b') era = 'gregory-inverse';\n    if (era === 'a') era = 'gregory';\n    return { era, eraYear } as T;\n  }\n  override getFirstDayOfWeek() {\n    return 1;\n  }\n  override getMinimalDaysInFirstWeek() {\n    return 1;\n  }\n}\n\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends SameMonthDayAsGregorianBaseHelper {\n  constructor() {\n    super('japanese', [\n      // The Japanese calendar `year` is just the ISO year, because (unlike other\n      // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n      { code: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n      { code: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n      { code: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n      { code: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n      { code: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n      { code: 'japanese', names: ['japanese', 'gregory', 'ad', 'ce'], isoEpoch: { year: 1, month: 1, day: 1 } },\n      { code: 'japanese-inverse', names: ['japanese-inverse', 'gregory-inverse', 'bc', 'bce'], reverseOf: 'japanese' }\n    ]);\n  }\n\n  override erasBeginMidYear = true;\n\n  override reviseIntlEra<T extends Partial<EraAndEraYear>>(calendarDate: T, isoDate: ISODate): T {\n    const { era, eraYear } = calendarDate;\n    const { year: isoYear } = isoDate;\n    if (this.eras.find((e) => e.code === era)) return { era, eraYear } as T;\n    return (\n      isoYear < 1 ? { era: 'japanese-inverse', eraYear: 1 - isoYear } : { era: 'japanese', eraYear: isoYear }\n    ) as T;\n  }\n}\n\ninterface ChineseMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth: number };\n}\ninterface ChineseDraftMonthInfo {\n  [key: string]: { monthIndex: number; daysInMonth?: number };\n}\n\nabstract class ChineseBaseHelper extends HelperBase {\n  abstract override id: BuiltinCalendarId;\n  calendarType = 'lunisolar' as const;\n  inLeapYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    const months = this.getMonthList(calendarDate.year, cache);\n    return Object.entries(months).length === 13;\n  }\n  monthsInYear(calendarDate: CalendarYearOnly, cache: OneObjectCache) {\n    return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n  }\n  minimumMonthLength(/* calendarDate */) {\n    return 29;\n  }\n  maximumMonthLength(/* calendarDate */) {\n    return 30;\n  }\n  maxLengthOfMonthCodeInAnyYear(monthCode: string) {\n    // See note below about ICU4C vs ICU4X. It is possible this override should\n    // always return 30.\n    return ['M01L', 'M09L', 'M10L', 'M11L', 'M12L'].includes(monthCode) ? 29 : 30;\n  }\n  override monthDaySearchStartYear(monthCode: string, day: number) {\n    // Note that ICU4C actually has _no_ years in which leap months M01L and\n    // M09L through M12L have 30 days. The values marked with (*) here are years\n    // in which the leap month occurs with 29 days. ICU4C disagrees with ICU4X\n    // here and it is not clear which is correct.\n    const monthMap: Record<string, [number, number]> = {\n      M01L: [1651, 1651], // *\n      M02L: [1947, 1765],\n      M03L: [1966, 1955],\n      M04L: [1963, 1944],\n      M05L: [1971, 1952],\n      M06L: [1960, 1941],\n      M07L: [1968, 1938],\n      M08L: [1957, 1718],\n      M09L: [1832, 1832], // *\n      M10L: [1870, 1870], // *\n      M11L: [1814, 1814], // *\n      M12L: [1890, 1890] // *\n    };\n    const years = monthMap[monthCode] ?? [1972, 1972];\n    return day < 30 ? years[0] : years[1];\n  }\n  getMonthList(calendarYear: number, cache: OneObjectCache): ChineseMonthInfo {\n    if (calendarYear === undefined) {\n      throw new TypeError('Missing year');\n    }\n    const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n    const cached = cache.get(key);\n    if (cached) return cached;\n    const dateTimeFormat = this.getFormatter();\n    const getCalendarDate = (isoYear: number, daysPastFeb1: number) => {\n      const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n      const legacyDate = new Date(isoStringFeb1);\n      // Now add the requested number of days, which may wrap to the next month.\n      legacyDate.setUTCDate(daysPastFeb1 + 1);\n      const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n      // The 'month' and 'day' parts are guaranteed to be present because the\n      // formatter was created with month and day options.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month')!.value;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const calendarDay = +newYearGuess.find((tv) => tv.type === 'day')!.value;\n      const calendarYearPartToVerify = newYearGuess.find((tv) => (tv.type as string) === 'relatedYear');\n      let calendarYearToVerify: number | undefined;\n      if (calendarYearPartToVerify !== undefined) {\n        calendarYearToVerify = +calendarYearPartToVerify.value;\n      } else {\n        // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n        // output of Intl.DateTimeFormat.formatToParts.\n        throw new RangeError(\n          `Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`\n        );\n      }\n      return { calendarMonthString, calendarDay, calendarYearToVerify };\n    };\n\n    // First, find a date close to Chinese New Year. Feb 17 will either be in\n    // the first month or near the end of the last month of the previous year.\n    let isoDaysDelta = 17;\n    let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n\n    // If we didn't guess the first month correctly, add (almost in some months)\n    // a lunar month\n    if (calendarMonthString !== '1') {\n      isoDaysDelta += 29;\n      ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n    }\n\n    // Now back up to near the start of the first month, but not too near that\n    // off-by-one issues matter.\n    isoDaysDelta -= calendarDay - 5;\n    const result = {} as ChineseDraftMonthInfo;\n    let monthIndex = 1;\n    let oldCalendarDay: number | undefined;\n    let oldMonthString: string | undefined;\n    let done = false;\n    do {\n      ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n      if (oldCalendarDay) {\n        result[oldMonthString as string].daysInMonth = oldCalendarDay + 30 - calendarDay;\n      }\n      if (calendarYearToVerify !== calendarYear) {\n        done = true;\n      } else {\n        result[calendarMonthString] = { monthIndex: monthIndex++ };\n        // Move to the next month. Because months are sometimes 29 days, the day of the\n        // calendar month will move forward slowly but not enough to flip over to a new\n        // month before the loop ends at 12-13 months.\n        isoDaysDelta += 30;\n      }\n      oldCalendarDay = calendarDay;\n      oldMonthString = calendarMonthString;\n    } while (!done);\n    result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n\n    cache.set(key, result);\n    return result as ChineseMonthInfo;\n  }\n  estimateIsoDate(calendarDate: CalendarYMD) {\n    const { year, month } = calendarDate;\n    return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n  }\n  override adjustCalendarDate(\n    calendarDate: Partial<FullCalendarDate>,\n    cache: OneObjectCache,\n    overflow: Overflow = 'constrain',\n    fromLegacyDate = false\n  ): FullCalendarDate {\n    let { year, month, monthExtra, day, monthCode } = calendarDate;\n    if (year === undefined) throw new TypeError('Missing property: year');\n    if (fromLegacyDate) {\n      // Legacy Date output returns a string that's an integer with an optional\n      // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n      // month. Below we'll normalize the output.\n      if (monthExtra && monthExtra !== 'bis') throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n      const monthCode = buildMonthCode(month as number, monthExtra !== undefined);\n      const monthString = `${month}${monthExtra || ''}`;\n      const months = this.getMonthList(year, cache);\n      const monthInfo = months[monthString];\n      if (monthInfo === undefined) throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n      month = monthInfo.monthIndex;\n      return { year, month, day: day as number, monthCode };\n    } else {\n      // When called without input coming from legacy Date output,\n      // simply ensure that all fields are present.\n      this.validateCalendarDate(calendarDate);\n      if (month === undefined) {\n        ES.assertExists(monthCode);\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        let monthInfo = months[numberPart];\n        month = monthInfo && monthInfo.monthIndex;\n\n        // If this leap month isn't present in this year, constrain to the same\n        // day of the previous month.\n        if (month === undefined && monthCode.endsWith('L') && monthCode != 'M13L' && overflow === 'constrain') {\n          const withoutML = +monthCode.replace(/^M0?|L$/g, '');\n          monthInfo = months[withoutML];\n          if (monthInfo) {\n            month = monthInfo.monthIndex;\n            monthCode = buildMonthCode(withoutML);\n          }\n        }\n        if (month === undefined) {\n          throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n        }\n      } else if (monthCode === undefined) {\n        const months = this.getMonthList(year, cache);\n        const monthEntries = Object.entries(months);\n        const largestMonth = monthEntries.length;\n        if (overflow === 'reject') {\n          ES.RejectToRange(month, 1, largestMonth);\n          ES.RejectToRange(day as number, 1, this.maximumMonthLength());\n        } else {\n          month = ES.ConstrainToRange(month, 1, largestMonth);\n          day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n        }\n        const matchingMonthEntry = monthEntries.find((entry) => entry[1].monthIndex === month);\n        if (matchingMonthEntry === undefined) {\n          throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n        }\n        monthCode = buildMonthCode(\n          +matchingMonthEntry[0].replace('bis', ''),\n          matchingMonthEntry[0].indexOf('bis') !== -1\n        );\n      } else {\n        // Both month and monthCode are present. Make sure they don't conflict.\n        const months = this.getMonthList(year, cache);\n        let numberPart = monthCode.replace(/^M|L$/g, (ch) => (ch === 'L' ? 'bis' : ''));\n        if (numberPart[0] === '0') numberPart = numberPart.slice(1);\n        const monthInfo = months[numberPart];\n        if (!monthInfo) throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n        if (month !== monthInfo.monthIndex) {\n          throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n        }\n      }\n      return { ...calendarDate, year, month, monthCode, day: day as number };\n    }\n  }\n}\n\nclass ChineseHelper extends ChineseBaseHelper {\n  id = 'chinese' as const;\n}\n\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n  id = 'dangi' as const;\n}\n\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nclass NonIsoCalendar implements CalendarImpl {\n  constructor(private readonly helper: HelperBase) {}\n  extraFields(fields: FieldKey[]): FieldKey[] {\n    if (this.helper.hasEra && fields.includes('year')) {\n      return ['era', 'eraYear'];\n    }\n    return [];\n  }\n  resolveFields(fields: CalendarFieldsRecord /* , type */) {\n    if (this.helper.calendarType !== 'lunisolar') {\n      const cache = new OneObjectCache();\n      const largestMonth = this.helper.monthsInYear({ year: fields.year ?? 1972 }, cache);\n      resolveNonLunisolarMonth(fields, undefined, largestMonth);\n    }\n  }\n  dateToISO(fields: CalendarDateFields, overflow: Overflow) {\n    const cache = new OneObjectCache();\n    const result = this.helper.calendarToIsoDate(fields, overflow, cache);\n    cache.setObject(result);\n    return result;\n  }\n  monthDayToISOReferenceDate(fields: MonthDayFromFieldsObject, overflow: Overflow) {\n    const cache = new OneObjectCache();\n    const result = this.helper.monthDayFromFields(fields, overflow, cache);\n    // result.year is a reference year where this month/day exists in this calendar\n    cache.setObject(result);\n    return result;\n  }\n  fieldKeysToIgnore(\n    keys: Exclude<keyof Temporal.PlainDateLike, 'calendar'>[]\n  ): Exclude<keyof Temporal.PlainDateLike, 'calendar'>[] {\n    const result = new Set<(typeof keys)[number]>();\n    for (let ix = 0; ix < keys.length; ix++) {\n      const key = keys[ix];\n      result.add(key);\n      switch (key) {\n        case 'era':\n          result.add('eraYear');\n          result.add('year');\n          break;\n        case 'eraYear':\n          result.add('era');\n          result.add('year');\n          break;\n        case 'year':\n          result.add('era');\n          result.add('eraYear');\n          break;\n        case 'month':\n          result.add('monthCode');\n          // See https://github.com/tc39/proposal-temporal/issues/1784\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n        case 'monthCode':\n          result.add('month');\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n        case 'day':\n          if (this.helper.erasBeginMidYear) {\n            result.add('era');\n            result.add('eraYear');\n          }\n          break;\n      }\n    }\n    return arrayFromSet(result);\n  }\n  dateAdd(isoDate: ISODate, { years, months, weeks, days }: DateDuration, overflow: Overflow) {\n    const cache = OneObjectCache.getCacheForObject(isoDate);\n    const calendarDate = this.helper.isoToCalendarDate(isoDate, cache);\n    const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n    const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n    // The new object's cache starts with the cache of the old object\n    if (!OneObjectCache.getCacheForObject(isoAdded)) {\n      const newCache = new OneObjectCache(cache);\n      newCache.setObject(isoAdded);\n    }\n    return isoAdded;\n  }\n  dateUntil(one: ISODate, two: ISODate, largestUnit: Temporal.DateUnit) {\n    const cacheOne = OneObjectCache.getCacheForObject(one);\n    const cacheTwo = OneObjectCache.getCacheForObject(two);\n    const calendarOne = this.helper.isoToCalendarDate(one, cacheOne);\n    const calendarTwo = this.helper.isoToCalendarDate(two, cacheTwo);\n    const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n    return result;\n  }\n  isoToDate<\n    Request extends Partial<Record<keyof CalendarDateRecord, true>>,\n    T extends {\n      [Field in keyof CalendarDateRecord]: Request extends { [K in Field]: true } ? CalendarDateRecord[Field] : never;\n    }\n  >(isoDate: ISODate, requestedFields: Request): T {\n    const cache = OneObjectCache.getCacheForObject(isoDate);\n    const calendarDate: Partial<CalendarDateRecord> & FullCalendarDate = this.helper.isoToCalendarDate(isoDate, cache);\n    if (requestedFields.dayOfWeek) {\n      calendarDate.dayOfWeek = impl['iso8601'].isoToDate(isoDate, { dayOfWeek: true }).dayOfWeek;\n    }\n    if (requestedFields.dayOfYear) {\n      const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n      const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n      calendarDate.dayOfYear = diffDays + 1;\n    }\n    if (requestedFields.weekOfYear) calendarDate.weekOfYear = calendarDateWeekOfYear(this.helper.id, isoDate);\n    calendarDate.daysInWeek = 7;\n    if (requestedFields.daysInMonth) calendarDate.daysInMonth = this.helper.daysInMonth(calendarDate, cache);\n    if (requestedFields.daysInYear) {\n      const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n      const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n      calendarDate.daysInYear = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n    }\n    if (requestedFields.monthsInYear) calendarDate.monthsInYear = this.helper.monthsInYear(calendarDate, cache);\n    if (requestedFields.inLeapYear) calendarDate.inLeapYear = this.helper.inLeapYear(calendarDate, cache);\n    return calendarDate as T;\n  }\n  getFirstDayOfWeek(): number | undefined {\n    return this.helper.getFirstDayOfWeek();\n  }\n  getMinimalDaysInFirstWeek(): number | undefined {\n    return this.helper.getMinimalDaysInFirstWeek();\n  }\n}\n\nfor (const Helper of [\n  HebrewHelper,\n  PersianHelper,\n  EthiopicHelper,\n  EthioaaHelper,\n  CopticHelper,\n  ChineseHelper,\n  DangiHelper,\n  RocHelper,\n  IndianHelper,\n  BuddhistHelper,\n  GregoryHelper,\n  JapaneseHelper,\n  IslamicHelper,\n  IslamicUmalquraHelper,\n  IslamicTblaHelper,\n  IslamicCivilHelper,\n  IslamicRgsaHelper,\n  IslamicCcHelper\n]) {\n  const helper = new Helper();\n  // Construct a new NonIsoCalendar instance with the given Helper implementation that contains\n  // per-calendar logic.\n  impl[helper.id] = new NonIsoCalendar(helper);\n}\n\nfunction calendarImpl(calendar: BuiltinCalendarId) {\n  return impl[calendar];\n}\n// Probably not what the intrinsics mechanism was intended for, but view this as\n// an export of calendarImpl while avoiding circular dependencies\nDefineIntrinsic('calendarImpl', calendarImpl);\n","import { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  CAL_ID,\n  CALENDAR,\n  CreateSlots,\n  DATE,\n  DATETIME,\n  DAYS,\n  EPOCHNANOSECONDS,\n  GetSlot,\n  HasSlot,\n  HOURS,\n  INST,\n  ISO_DATE,\n  ISO_DATE_TIME,\n  LOCALE,\n  MD,\n  MICROSECONDS,\n  MILLISECONDS,\n  MINUTES,\n  MONTHS,\n  NANOSECONDS,\n  OPTIONS,\n  ORIGINAL,\n  ResetSlot,\n  SECONDS,\n  SetSlot,\n  TIME,\n  TIME_FMT,\n  TZ_CANONICAL,\n  TZ_ORIGINAL,\n  WEEKS,\n  YEARS,\n  YM\n} from './slots';\nimport type { Temporal } from '..';\nimport type { DateTimeFormatParams as Params, DateTimeFormatReturn as Return } from './internaltypes';\n\n// Save the original Intl.DateTimeFormat, it will likely be overwritten\nconst OriginalIntlDateTimeFormat = Intl.DateTimeFormat;\n\ntype LazySlot = typeof DATE | typeof YM | typeof MD | typeof TIME_FMT | typeof DATETIME | typeof INST;\n\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getSlotLazy(obj: DateTimeFormatImpl, slot: LazySlot) {\n  let val = GetSlot(obj, slot);\n  if (typeof val === 'function') {\n    // If we get here, `val` is an \"amender function\". It will take the user's\n    // options and transform them into suitable options to be passed into the\n    // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n    // will vary depending on the Temporal type, so that's why we store separate\n    // formatters in separate props on the polyfill's DateTimeFormat instances.\n    // The efficiency happens because we don't create an (expensive) formatter\n    // until the user calls toLocaleString for that Temporal type.\n    val = new OriginalIntlDateTimeFormat(GetSlot(obj, LOCALE), val(GetSlot(obj, OPTIONS)));\n    ResetSlot(obj, slot, val);\n  }\n  return val;\n}\n\nfunction createDateTimeFormat(\n  dtf: DateTimeFormatImpl,\n  locale: Params['constructor'][0],\n  optionsParam: Params['constructor'][1]\n) {\n  const hasOptions = typeof optionsParam !== 'undefined';\n  let options: Intl.DateTimeFormatOptions;\n  if (hasOptions) {\n    // Read all the options in the expected order and copy them to a\n    // null-prototype object with which we can do further operations\n    // unobservably\n    const props: (keyof Intl.DateTimeFormatOptions)[] = [\n      'localeMatcher',\n      'calendar',\n      'numberingSystem',\n      'hour12',\n      'hourCycle',\n      'timeZone',\n      'weekday',\n      'era',\n      'year',\n      'month',\n      'day',\n      'dayPeriod',\n      'hour',\n      'minute',\n      'second',\n      'fractionalSecondDigits',\n      'timeZoneName',\n      'formatMatcher',\n      'dateStyle',\n      'timeStyle'\n    ];\n    options = ES.ToObject(optionsParam);\n    const newOptions = Object.create(null);\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (Object.prototype.hasOwnProperty.call(options, prop)) {\n        newOptions[prop] = options[prop];\n      }\n    }\n    options = newOptions;\n  } else {\n    options = Object.create(null);\n  }\n  const original = new OriginalIntlDateTimeFormat(locale, options);\n  const ro = original.resolvedOptions();\n\n  CreateSlots(dtf);\n\n  // DateTimeFormat instances are very expensive to create. Therefore, they will\n  // be lazily created only when needed, using the locale and options provided.\n  // But it's possible for callers to mutate those inputs before lazy creation\n  // happens. For this reason, we clone the inputs instead of caching the\n  // original objects. To avoid the complexity of deep cloning any inputs that\n  // are themselves objects (e.g. the locales array, or options property values\n  // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n  // coercion and cloning for us. Unfortunately, we can't just use the resolved\n  // options as-is because our options-amending logic adds additional fields if\n  // the user doesn't supply any unit fields like year, month, day, hour, etc.\n  // Therefore, we limit the properties in the clone to properties that were\n  // present in the original input.\n  if (hasOptions) {\n    const clonedResolved = Object.assign(Object.create(null), ro);\n    for (const prop in clonedResolved) {\n      if (!Object.prototype.hasOwnProperty.call(options, prop)) {\n        delete clonedResolved[prop as keyof typeof clonedResolved];\n      }\n    }\n    // hour12/hourCycle don't show up in resolvedOptions() unless the chosen\n    // format includes an hour component, so copy them explicitly in case they\n    // would otherwise be lost\n    clonedResolved.hour12 = options.hour12;\n    clonedResolved.hourCycle = options.hourCycle;\n    SetSlot(dtf, OPTIONS, clonedResolved);\n  } else {\n    SetSlot(dtf, OPTIONS, options);\n  }\n\n  SetSlot(dtf, LOCALE, ro.locale);\n  SetSlot(dtf, ORIGINAL, original);\n  SetSlot(dtf, TZ_CANONICAL, ro.timeZone);\n  SetSlot(dtf, CAL_ID, ro.calendar);\n  SetSlot(dtf, DATE, dateAmend);\n  SetSlot(dtf, YM, yearMonthAmend);\n  SetSlot(dtf, MD, monthDayAmend);\n  SetSlot(dtf, TIME_FMT, timeAmend);\n  SetSlot(dtf, DATETIME, datetimeAmend);\n  SetSlot(dtf, INST, instantAmend);\n\n  // Save the original time zone, for a few reasons:\n  // - Clearer error messages\n  // - More clearly follows the spec for InitializeDateTimeFormat\n  // - Because it follows the spec more closely, will make it easier to integrate\n  //   support of offset strings and other potential changes like proposal-canonical-tz.\n  const timeZoneOption = hasOptions ? options.timeZone : undefined;\n  if (timeZoneOption === undefined) {\n    SetSlot(dtf, TZ_ORIGINAL, ro.timeZone);\n  } else {\n    const id = ES.ToString(timeZoneOption);\n    if (id.startsWith('−')) {\n      // The initial (Node 23) implementation of offset time zones allowed use\n      // of the Unicode minus sign, which was disallowed by a later spec change.\n      throw new RangeError('Unicode minus (U+2212) is not supported in time zone offsets');\n    }\n    // store a normalized identifier\n    SetSlot(dtf, TZ_ORIGINAL, ES.ToTemporalTimeZoneIdentifier(id));\n  }\n  return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\n\nfunction IsPatchedDateTimeFormat(item: unknown): item is DateTimeFormatImpl {\n  return HasSlot(item, ORIGINAL);\n}\n\nclass DateTimeFormatImpl {\n  constructor(locales: Params['constructor'][0] = undefined, options: Params['constructor'][1] = undefined) {\n    createDateTimeFormat(this, locales, options);\n  }\n\n  get format() {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    const boundFormat = format.bind(this);\n    Object.defineProperties(boundFormat, {\n      length: { value: 1, enumerable: false, writable: false, configurable: true },\n      name: { value: '', enumerable: false, writable: false, configurable: true }\n    });\n    return boundFormat;\n  }\n\n  formatRange(a: Params['formatRange'][0], b: Params['formatRange'][1]): Return['formatRange'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatRange.call(this, a, b);\n  }\n\n  formatToParts?<P extends readonly unknown[]>(\n    datetime: Params['formatToParts'][0],\n    ...rest: P\n  ): Return['formatToParts'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatToParts.call(this, datetime, ...rest);\n  }\n\n  formatRangeToParts?(\n    a: Params['formatRangeToParts'][0],\n    b: Params['formatRangeToParts'][1]\n  ): Return['formatRangeToParts'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return formatRangeToParts.call(this, a, b);\n  }\n\n  resolvedOptions(): Return['resolvedOptions'] {\n    ES.CheckReceiver(this, IsPatchedDateTimeFormat);\n    return resolvedOptions.call(this);\n  }\n}\n\nif (!('formatToParts' in OriginalIntlDateTimeFormat.prototype)) {\n  delete DateTimeFormatImpl.prototype.formatToParts;\n}\n\nif (!('formatRangeToParts' in OriginalIntlDateTimeFormat.prototype)) {\n  delete DateTimeFormatImpl.prototype.formatRangeToParts;\n}\nexport type { DateTimeFormatImpl };\n\ninterface DateTimeFormatInterface {\n  (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\n  new (locales: Params['constructor'][0], options: Params['constructor'][1]): DateTimeFormatImpl;\n  supportedLocalesOf: typeof Intl.DateTimeFormat.supportedLocalesOf;\n}\n\n// A non-class constructor is needed because Intl.DateTimeFormat must be able to\n// be called without 'new'\nexport const DateTimeFormat = function (\n  locales: Params['constructor'][0] = undefined,\n  options: Params['constructor'][1] = undefined\n): DateTimeFormatImpl {\n  return new DateTimeFormatImpl(locales, options);\n} as unknown as DateTimeFormatInterface;\nDateTimeFormatImpl.prototype.constructor = DateTimeFormat;\n\nObject.defineProperty(DateTimeFormat, 'prototype', {\n  value: DateTimeFormatImpl.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nDateTimeFormat.supportedLocalesOf = OriginalIntlDateTimeFormat.supportedLocalesOf;\nMakeIntrinsicClass(DateTimeFormat as unknown as typeof Intl.DateTimeFormat, 'Intl.DateTimeFormat');\n\nfunction resolvedOptions(this: DateTimeFormatImpl): Return['resolvedOptions'] {\n  const resolved = GetSlot(this, ORIGINAL).resolvedOptions();\n  resolved.timeZone = GetSlot(this, TZ_ORIGINAL);\n  return resolved;\n}\n\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['format'][0],\n  ...rest: P\n): Return['format'] {\n  let overrides = extractOverrides(datetime, this);\n  let formatter, formatArgs: [Params['format'][0], ...unknown[]];\n  if (overrides.formatter) {\n    formatter = overrides.formatter;\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\n  } else {\n    formatter = GetSlot(this, ORIGINAL);\n    formatArgs = [datetime, ...rest];\n  }\n  return formatter.format(...(formatArgs as [number | Date | undefined]));\n}\n\nfunction formatToParts<P extends readonly unknown[]>(\n  this: DateTimeFormatImpl,\n  datetime: Params['formatToParts'][0],\n  ...rest: P\n): Return['formatToParts'] {\n  let overrides = extractOverrides(datetime, this);\n  let formatter, formatArgs;\n  if (overrides.formatter) {\n    formatter = overrides.formatter;\n    formatArgs = [ES.epochNsToMs(overrides.epochNs, 'floor')];\n  } else {\n    formatter = GetSlot(this, ORIGINAL);\n    formatArgs = [datetime, ...rest];\n  }\n  return formatter.formatToParts(...(formatArgs as [number | Date | undefined]));\n}\n\nfunction formatRange(this: DateTimeFormatImpl, aParam: Params['formatRange'][0], bParam: Params['formatRange'][1]) {\n  if (aParam === undefined || bParam === undefined) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\n  }\n  const a = toDateTimeFormattable(aParam);\n  const b = toDateTimeFormattable(bParam);\n  let formatArgs = [a, b] as const;\n  let formatter;\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n  }\n  if (isTemporalObject(a)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n    }\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aformatter) {\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\n      formatter = aformatter;\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\n    }\n  }\n  if (!formatter) {\n    formatter = GetSlot(this, ORIGINAL);\n  }\n  return formatter.formatRange(...(formatArgs as [number, number]));\n}\n\nfunction formatRangeToParts(\n  this: DateTimeFormatImpl,\n  aParam: Params['formatRangeToParts'][0],\n  bParam: Params['formatRangeToParts'][1]\n) {\n  if (aParam === undefined || bParam === undefined) {\n    throw new TypeError('Intl.DateTimeFormat.formatRange requires two values');\n  }\n  const a = toDateTimeFormattable(aParam);\n  const b = toDateTimeFormattable(bParam);\n  let formatArgs = [a, b] as const;\n  let formatter;\n  if (isTemporalObject(a) !== isTemporalObject(b)) {\n    throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n  }\n  if (isTemporalObject(a)) {\n    if (!sameTemporalType(a, b)) {\n      throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n    }\n    const { epochNs: aa, formatter: aformatter } = extractOverrides(a, this);\n    const { epochNs: bb, formatter: bformatter } = extractOverrides(b, this);\n    if (aformatter) {\n      assert(bformatter == aformatter, 'formatters for same Temporal type should be identical');\n      formatter = aformatter;\n      formatArgs = [ES.epochNsToMs(aa, 'floor'), ES.epochNsToMs(bb, 'floor')];\n    }\n  }\n  if (!formatter) {\n    formatter = GetSlot(this, ORIGINAL);\n  }\n  return formatter.formatRangeToParts(...(formatArgs as [number, number]));\n}\n\n// \"false\" is a signal to delete this option\ntype MaybeFalseOptions = {\n  [K in keyof Intl.DateTimeFormatOptions]?: Intl.DateTimeFormatOptions[K] | false;\n};\n\nfunction amend(optionsParam: Intl.DateTimeFormatOptions = {}, amended: MaybeFalseOptions = {}) {\n  const options = Object.assign({}, optionsParam);\n  const props = [\n    'year',\n    'month',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'weekday',\n    'dayPeriod',\n    'timeZoneName',\n    'dateStyle',\n    'timeStyle'\n  ] as const;\n  for (let i = 0; i < props.length; i++) {\n    const opt = props[i];\n    // TODO: can this be typed more cleanly?\n    type OptionMaybeFalse = (typeof options)[typeof opt] | false;\n    (options[opt] as OptionMaybeFalse) = opt in amended ? amended[opt] : options[opt];\n    if ((options[opt] as OptionMaybeFalse) === false || options[opt] === undefined) delete options[opt];\n  }\n  return options;\n}\n\ntype OptionsType<T extends TypesWithToLocaleString> = NonNullable<Parameters<T['toLocaleString']>[1]>;\n\nfunction timeAmend(originalOptions: OptionsType<Temporal.PlainTime>) {\n  const options = amend(originalOptions, {\n    year: false,\n    month: false,\n    day: false,\n    weekday: false,\n    timeZoneName: false,\n    dateStyle: false\n  });\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\n    // Try to fake what timeStyle should do if not printing the time zone name\n    delete options.timeStyle;\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\n  }\n  if (!hasTimeOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format Temporal.PlainTime with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction yearMonthAmend(originalOptions: OptionsType<Temporal.PlainYearMonth>) {\n  // Try to fake what dateStyle should do for dates without a day. This is not\n  // accurate for locales that always print the era\n  const dateStyleHacks = {\n    short: { year: '2-digit', month: 'numeric' },\n    medium: { year: 'numeric', month: 'short' },\n    long: { year: 'numeric', month: 'long' },\n    full: { year: 'numeric', month: 'long' }\n  };\n  const options = amend(originalOptions, {\n    day: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if ('dateStyle' in options && options.dateStyle) {\n    const style = options.dateStyle;\n    delete options.dateStyle;\n    Object.assign(options, dateStyleHacks[style]);\n  }\n  if (!('year' in options || 'month' in options || 'era' in options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainYearMonth with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, { year: 'numeric', month: 'numeric' });\n  }\n  return options;\n}\n\nfunction monthDayAmend(originalOptions: OptionsType<Temporal.PlainMonthDay>) {\n  // Try to fake what dateStyle should do for dates without a day\n  const dateStyleHacks = {\n    short: { month: 'numeric', day: 'numeric' },\n    medium: { month: 'short', day: 'numeric' },\n    long: { month: 'long', day: 'numeric' },\n    full: { month: 'long', day: 'numeric' }\n  };\n  const options = amend(originalOptions, {\n    year: false,\n    hour: false,\n    minute: false,\n    second: false,\n    weekday: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if ('dateStyle' in options && options.dateStyle) {\n    const style = options.dateStyle;\n    delete options.dateStyle;\n    Object.assign(options, dateStyleHacks[style]);\n  }\n  if (!('month' in options || 'day' in options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainMonthDay with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, { month: 'numeric', day: 'numeric' });\n  }\n  return options;\n}\n\nfunction dateAmend(originalOptions: OptionsType<Temporal.PlainDate>) {\n  const options = amend(originalOptions, {\n    hour: false,\n    minute: false,\n    second: false,\n    dayPeriod: false,\n    timeZoneName: false,\n    timeStyle: false\n  });\n  if (!hasDateOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainDate with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction datetimeAmend(originalOptions: OptionsType<Temporal.PlainDateTime>) {\n  const options = amend(originalOptions, { timeZoneName: false });\n  if (options.timeStyle === 'long' || options.timeStyle === 'full') {\n    // Try to fake what timeStyle should do if not printing the time zone name\n    delete options.timeStyle;\n    Object.assign(options, { hour: 'numeric', minute: '2-digit', second: '2-digit' });\n\n    // If moving to a fake timeStyle while dateStyle is present, we also have to\n    // move to a fake dateStyle. dateStyle is mutually exclusive with hour etc.\n    if (options.dateStyle) {\n      const dateStyleHacks = {\n        short: { year: 'numeric', month: 'numeric', day: 'numeric' },\n        medium: { year: 'numeric', month: 'short', day: 'numeric' },\n        long: { year: 'numeric', month: 'long', day: 'numeric' },\n        full: { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' }\n      };\n      Object.assign(options, dateStyleHacks[options.dateStyle]);\n      delete options.dateStyle;\n    }\n  }\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    if (hasAnyDateTimeOptions(originalOptions)) {\n      throw new TypeError(`cannot format PlainDateTime with options [${Object.keys(originalOptions)}]`);\n    }\n    Object.assign(options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction instantAmend(optionsParam: OptionsType<Temporal.Instant>) {\n  let options = optionsParam;\n  if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n    options = Object.assign({}, options, {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric'\n    });\n  }\n  return options;\n}\n\nfunction hasDateOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'year' in options ||\n    'month' in options ||\n    'day' in options ||\n    'weekday' in options ||\n    'dateStyle' in options ||\n    'era' in options\n  );\n}\n\nfunction hasTimeOptions(options: OptionsType<TypesWithToLocaleString>) {\n  return (\n    'hour' in options ||\n    'minute' in options ||\n    'second' in options ||\n    'timeStyle' in options ||\n    'dayPeriod' in options ||\n    'fractionalSecondDigits' in options\n  );\n}\n\nfunction hasAnyDateTimeOptions(originalOptions: OptionsType<TypesWithToLocaleString>) {\n  return (\n    hasDateOptions(originalOptions) ||\n    hasTimeOptions(originalOptions) ||\n    'dateStyle' in originalOptions ||\n    'timeStyle' in originalOptions ||\n    'timeZoneName' in originalOptions\n  );\n}\n\nfunction isTemporalObject(\n  obj: unknown\n): obj is\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainDateTime\n  | Temporal.ZonedDateTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.Instant {\n  return (\n    ES.IsTemporalDate(obj) ||\n    ES.IsTemporalTime(obj) ||\n    ES.IsTemporalDateTime(obj) ||\n    ES.IsTemporalZonedDateTime(obj) ||\n    ES.IsTemporalYearMonth(obj) ||\n    ES.IsTemporalMonthDay(obj) ||\n    ES.IsTemporalInstant(obj)\n  );\n}\n\nfunction toDateTimeFormattable(value: unknown) {\n  if (isTemporalObject(value)) return value;\n  return ES.ToNumber(value);\n}\n\nfunction sameTemporalType(x: unknown, y: unknown) {\n  if (!isTemporalObject(x) || !isTemporalObject(y)) return false;\n  if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y)) return false;\n  if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y)) return false;\n  if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y)) return false;\n  if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y)) return false;\n  if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y)) return false;\n  if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y)) return false;\n  if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y)) return false;\n  return true;\n}\n\ntype TypesWithToLocaleString =\n  | Temporal.PlainDateTime\n  | Temporal.PlainDate\n  | Temporal.PlainTime\n  | Temporal.PlainYearMonth\n  | Temporal.PlainMonthDay\n  | Temporal.ZonedDateTime\n  | Temporal.Instant;\n\nfunction extractOverrides(temporalObj: Params['format'][0], main: DateTimeFormatImpl) {\n  if (ES.IsTemporalTime(temporalObj)) {\n    const isoDateTime = {\n      isoDate: { year: 1970, month: 1, day: 1 },\n      time: GetSlot(temporalObj, TIME)\n    };\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, TIME_FMT)\n    };\n  }\n\n  if (ES.IsTemporalYearMonth(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, YM)\n    };\n  }\n\n  if (ES.IsTemporalMonthDay(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, MD)\n    };\n  }\n\n  if (ES.IsTemporalDate(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\n      throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${mainCalendar}`);\n    }\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(temporalObj, ISO_DATE), ES.NoonTimeRecord());\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, DATE)\n    };\n  }\n\n  if (ES.IsTemporalDateTime(temporalObj)) {\n    const calendar = GetSlot(temporalObj, CALENDAR);\n    const mainCalendar = GetSlot(main, CAL_ID);\n    if (calendar !== 'iso8601' && calendar !== mainCalendar) {\n      throw new RangeError(\n        `cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${mainCalendar}`\n      );\n    }\n    const isoDateTime = GetSlot(temporalObj, ISO_DATE_TIME);\n    return {\n      epochNs: ES.GetEpochNanosecondsFor(GetSlot(main, TZ_CANONICAL), isoDateTime, 'compatible'),\n      formatter: getSlotLazy(main, DATETIME)\n    };\n  }\n\n  if (ES.IsTemporalZonedDateTime(temporalObj)) {\n    throw new TypeError(\n      'Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.'\n    );\n  }\n\n  if (ES.IsTemporalInstant(temporalObj)) {\n    return {\n      epochNs: GetSlot(temporalObj, EPOCHNANOSECONDS),\n      formatter: getSlotLazy(main, INST)\n    };\n  }\n\n  return {};\n}\n\nfunction temporalDurationToCompatibilityRecord(duration: Temporal.Duration) {\n  const record = Object.create(null);\n  record.years = GetSlot(duration, YEARS);\n  record.months = GetSlot(duration, MONTHS);\n  record.weeks = GetSlot(duration, WEEKS);\n  record.days = GetSlot(duration, DAYS);\n  record.hours = GetSlot(duration, HOURS);\n  record.minutes = GetSlot(duration, MINUTES);\n  record.seconds = GetSlot(duration, SECONDS);\n  record.milliseconds = GetSlot(duration, MILLISECONDS);\n  record.microseconds = GetSlot(duration, MICROSECONDS);\n  record.nanoseconds = GetSlot(duration, NANOSECONDS);\n  return record;\n}\n\nconst { format: IntlDurationFormatPrototypeFormat, formatToParts: IntlDurationFormatPrototypeFormatToParts } =\n  Intl.DurationFormat?.prototype ?? Object.create(null);\n\nexport function ModifiedIntlDurationFormatPrototypeFormat(\n  this: Intl.DurationFormat,\n  durationLike: Temporal.DurationLike\n) {\n  Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\n  const duration = ES.ToTemporalDuration(durationLike);\n  const record = temporalDurationToCompatibilityRecord(duration);\n  return IntlDurationFormatPrototypeFormat.call(this, record);\n}\n\nif (Intl.DurationFormat?.prototype) {\n  Intl.DurationFormat.prototype.format = ModifiedIntlDurationFormatPrototypeFormat;\n  Intl.DurationFormat.prototype.formatToParts = function formatToParts(durationLike: Temporal.DurationLike) {\n    Intl.DurationFormat.prototype.resolvedOptions.call(this); // brand check\n    const duration = ES.ToTemporalDuration(durationLike);\n    const record = temporalDurationToCompatibilityRecord(duration);\n    return IntlDurationFormatPrototypeFormatToParts.call(this, record);\n  };\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, GetSlot } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { InstantParams as Params, InstantReturn as Return } from './internaltypes';\n\nimport JSBI from 'jsbi';\n\nexport class Instant implements Temporal.Instant {\n  constructor(epochNanoseconds: bigint | JSBI) {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n\n    const ns = ES.ToBigInt(epochNanoseconds);\n    ES.CreateTemporalInstantSlots(this, ns);\n  }\n\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.epochNsToMs(value, 'floor');\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.AddDurationToInstant('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.AddDurationToInstant('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.DifferenceTemporalInstant('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.DifferenceTemporalInstant('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const maximumIncrements = {\n      hour: 24,\n      minute: 1440,\n      second: 86400,\n      millisecond: 86400e3,\n      microsecond: 86400e6,\n      nanosecond: 86400e9\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximumIncrements[smallestUnit], true);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundTemporalInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n    return ES.CreateTemporalInstant(roundedNs);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const other = ES.ToTemporalInstant(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    let timeZone = resolvedOptions.timeZone;\n    if (timeZone !== undefined) timeZone = ES.ToTemporalTimeZoneIdentifier(timeZone);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const ns = GetSlot(this, EPOCHNANOSECONDS);\n    const roundedNs = ES.RoundTemporalInstant(ns, increment, unit, roundingMode);\n    const roundedInstant = ES.CreateTemporalInstant(roundedNs);\n    return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\n  }\n  toJSON(): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return ES.TemporalInstantToString(this, undefined, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('Instant');\n  }\n  toZonedDateTimeISO(timeZoneParam: Params['toZonedDateTimeISO'][0]): Return['toZonedDateTimeISO'] {\n    ES.CheckReceiver(this, ES.IsTemporalInstant);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, 'iso8601');\n  }\n\n  static fromEpochMilliseconds(epochMilliseconds: Params['fromEpochMilliseconds'][0]): Return['fromEpochMilliseconds'] {\n    const epochNanoseconds = ES.epochMsToNs(ES.ToNumber(epochMilliseconds));\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n  static fromEpochNanoseconds(\n    epochNanosecondsParam: Params['fromEpochNanoseconds'][0]\n  ): Return['fromEpochNanoseconds'] {\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    return ES.ToTemporalInstant(item);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalInstant(oneParam);\n    const two = ES.ToTemporalInstant(twoParam);\n    const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n    const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(oneNs, twoNs)) return -1;\n    if (JSBI.greaterThan(oneNs, twoNs)) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.Instant';\n}\n\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE, TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainDateParams as Params, PlainDateReturn as Return } from './internaltypes';\n\nexport class PlainDate implements Temporal.PlainDate {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    isoDay: Params['constructor'][2],\n    calendarParam: Params['constructor'][3] = 'iso8601'\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    ES.RejectISODate(year, month, day);\n\n    ES.CreateTemporalDateSlots(this, { year, month, day }, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return GetSlot(this, CALENDAR);\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalDateLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    if (!ES.IsObject(temporalDateLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const partialDate = ES.PrepareCalendarFields(\n      calendar,\n      temporalDateLike,\n      ['year', 'month', 'monthCode', 'day'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialDate);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarDateFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.AddDurationToDate('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.AddDurationToDate('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.DifferenceTemporalPlainDate('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.DifferenceTemporalPlainDate('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const other = ES.ToTemporalDate(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalDateToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return ES.TemporalDateToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainDate');\n  }\n  toPlainDateTime(temporalTime: Params['toPlainDateTime'][0] = undefined): Return['toPlainDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE), time);\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n  }\n  toZonedDateTime(item: Params['toZonedDateTime'][0]): Return['toZonedDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n\n    let timeZone, temporalTime;\n    if (ES.IsObject(item)) {\n      const timeZoneLike = item.timeZone;\n      if (timeZoneLike === undefined) {\n        timeZone = ES.ToTemporalTimeZoneIdentifier(item);\n      } else {\n        timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneLike);\n        temporalTime = item.plainTime;\n      }\n    } else {\n      timeZone = ES.ToTemporalTimeZoneIdentifier(item);\n    }\n\n    const isoDate = GetSlot(this, ISO_DATE);\n    let epochNs;\n    if (temporalTime === undefined) {\n      epochNs = ES.GetStartOfDay(timeZone, isoDate);\n    } else {\n      temporalTime = ES.ToTemporalTime(temporalTime);\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoDate, GetSlot(temporalTime, TIME));\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, isoDateTime, 'compatible');\n    }\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainYearMonth(): Return['toPlainYearMonth'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = GetSlot(this, CALENDAR);\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, 'constrain');\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\n  }\n  toPlainMonthDay(): Return['toPlainMonthDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalDate);\n    const calendar = GetSlot(this, CALENDAR);\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE));\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, 'constrain');\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalDate(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDate(oneParam);\n    const two = ES.ToTemporalDate(twoParam);\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDate';\n}\n\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  date: Temporal.PlainDate,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(date, ES.IsTemporalDate);\n  const isoDate = GetSlot(date, ISO_DATE);\n  return ES.calendarImplForObj(date).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport { CALENDAR, GetSlot, ISO_DATE_TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainDateTimeParams as Params, PlainDateTimeReturn as Return } from './internaltypes';\n\nexport class PlainDateTime implements Temporal.PlainDateTime {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    isoDay: Params['constructor'][2],\n    hourParam: Params['constructor'][3] = 0,\n    minuteParam: Params['constructor'][4] = 0,\n    secondParam: Params['constructor'][5] = 0,\n    millisecondParam: Params['constructor'][6] = 0,\n    microsecondParam: Params['constructor'][7] = 0,\n    nanosecondParam: Params['constructor'][8] = 0,\n    calendarParam: Params['constructor'][9] = 'iso8601'\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const hour = hourParam === undefined ? 0 : ES.ToIntegerWithTruncation(hourParam);\n    const minute = minuteParam === undefined ? 0 : ES.ToIntegerWithTruncation(minuteParam);\n    const second = secondParam === undefined ? 0 : ES.ToIntegerWithTruncation(secondParam);\n    const millisecond = millisecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(millisecondParam);\n    const microsecond = microsecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(microsecondParam);\n    const nanosecond = nanosecondParam === undefined ? 0 : ES.ToIntegerWithTruncation(nanosecondParam);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n\n    ES.RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n\n    ES.CreateTemporalDateTimeSlots(\n      this,\n      { isoDate: { year, month, day }, time: { hour, minute, second, millisecond, microsecond, nanosecond } },\n      calendar\n    );\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return GetSlot(this, CALENDAR);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get hour(): Return['hour'] {\n    return getTimeProperty(this, 'hour');\n  }\n  get minute(): Return['minute'] {\n    return getTimeProperty(this, 'minute');\n  }\n  get second(): Return['second'] {\n    return getTimeProperty(this, 'second');\n  }\n  get millisecond(): Return['millisecond'] {\n    return getTimeProperty(this, 'millisecond');\n  }\n  get microsecond(): Return['microsecond'] {\n    return getTimeProperty(this, 'microsecond');\n  }\n  get nanosecond(): Return['nanosecond'] {\n    return getTimeProperty(this, 'nanosecond');\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    if (!ES.IsObject(temporalDateTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalDateTimeLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\n    let fields = {\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\n      ...isoDateTime.time\n    };\n    const partialDateTime = ES.PrepareCalendarFields(\n      calendar,\n      temporalDateTimeLike,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialDateTime);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\n    return ES.CreateTemporalDateTime(newDateTime, calendar);\n  }\n  withPlainTime(temporalTime: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const time = ES.ToTimeRecordOrMidnight(temporalTime);\n    const isoDateTime = ES.CombineISODateAndTimeRecord(GetSlot(this, ISO_DATE_TIME).isoDate, time);\n    return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalDateTime(GetSlot(this, ISO_DATE_TIME), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.AddDurationToDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.AddDurationToDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    const isoDateTime = GetSlot(this, ISO_DATE_TIME);\n    if (roundingIncrement === 1 && smallestUnit === 'nanosecond') {\n      return ES.CreateTemporalDateTime(isoDateTime, GetSlot(this, CALENDAR));\n    }\n    const result = ES.RoundISODateTime(isoDateTime, roundingIncrement, smallestUnit, roundingMode);\n\n    return ES.CreateTemporalDateTime(result, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const other = ES.ToTemporalDateTime(otherParam);\n    if (ES.CompareISODateTime(GetSlot(this, ISO_DATE_TIME), GetSlot(other, ISO_DATE_TIME)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const result = ES.RoundISODateTime(GetSlot(this, ISO_DATE_TIME), increment, unit, roundingMode);\n    ES.RejectDateTimeRange(result);\n    return ES.ISODateTimeToString(result, GetSlot(this, CALENDAR), precision, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.ISODateTimeToString(GetSlot(this, ISO_DATE_TIME), GetSlot(this, CALENDAR), 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainDateTime');\n  }\n\n  toZonedDateTime(\n    temporalTimeZoneLike: Params['toZonedDateTime'][0],\n    options: Params['toZonedDateTime'][1] = undefined\n  ): Return['toZonedDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\n    const epochNs = ES.GetEpochNanosecondsFor(timeZone, GetSlot(this, ISO_DATE_TIME), disambiguation);\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, GetSlot(this, CALENDAR));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.CreateTemporalDate(GetSlot(this, ISO_DATE_TIME).isoDate, GetSlot(this, CALENDAR));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalDateTime);\n    return ES.CreateTemporalTime(GetSlot(this, ISO_DATE_TIME).time);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalDateTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalDateTime(oneParam);\n    const two = ES.ToTemporalDateTime(twoParam);\n    return ES.CompareISODateTime(GetSlot(one, ISO_DATE_TIME), GetSlot(two, ISO_DATE_TIME));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainDateTime';\n}\n\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  dt: Temporal.PlainDateTime,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\n  const isoDate = GetSlot(dt, ISO_DATE_TIME).isoDate;\n  return ES.calendarImplForObj(dt).isoToDate(isoDate, { [prop]: true })[prop];\n}\n\nfunction getTimeProperty(dt: Temporal.PlainDateTime, prop: Temporal.TimeUnit) {\n  ES.CheckReceiver(dt, ES.IsTemporalDateTime);\n  return GetSlot(dt, ISO_DATE_TIME).time[prop];\n}\n","import { DEBUG } from './debug';\nimport { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { ModifiedIntlDurationFormatPrototypeFormat } from './intl';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport {\n  YEARS,\n  MONTHS,\n  WEEKS,\n  DAYS,\n  HOURS,\n  MINUTES,\n  SECONDS,\n  MILLISECONDS,\n  MICROSECONDS,\n  NANOSECONDS,\n  CALENDAR,\n  EPOCHNANOSECONDS,\n  CreateSlots,\n  GetSlot,\n  ISO_DATE,\n  SetSlot,\n  TIME_ZONE\n} from './slots';\nimport { TimeDuration } from './timeduration';\nimport type { Temporal } from '..';\nimport type { DurationParams as Params, DurationReturn as Return } from './internaltypes';\nimport JSBI from 'jsbi';\n\nexport class Duration implements Temporal.Duration {\n  constructor(\n    yearsParam: Params['constructor'][0] = 0,\n    monthsParam: Params['constructor'][1] = 0,\n    weeksParam: Params['constructor'][2] = 0,\n    daysParam: Params['constructor'][3] = 0,\n    hoursParam: Params['constructor'][4] = 0,\n    minutesParam: Params['constructor'][5] = 0,\n    secondsParam: Params['constructor'][6] = 0,\n    millisecondsParam: Params['constructor'][7] = 0,\n    microsecondsParam: Params['constructor'][8] = 0,\n    nanosecondsParam: Params['constructor'][9] = 0\n  ) {\n    const years = yearsParam === undefined ? 0 : ES.ToIntegerIfIntegral(yearsParam);\n    const months = monthsParam === undefined ? 0 : ES.ToIntegerIfIntegral(monthsParam);\n    const weeks = weeksParam === undefined ? 0 : ES.ToIntegerIfIntegral(weeksParam);\n    const days = daysParam === undefined ? 0 : ES.ToIntegerIfIntegral(daysParam);\n    const hours = hoursParam === undefined ? 0 : ES.ToIntegerIfIntegral(hoursParam);\n    const minutes = minutesParam === undefined ? 0 : ES.ToIntegerIfIntegral(minutesParam);\n    const seconds = secondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(secondsParam);\n    const milliseconds = millisecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(millisecondsParam);\n    const microseconds = microsecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(microsecondsParam);\n    const nanoseconds = nanosecondsParam === undefined ? 0 : ES.ToIntegerIfIntegral(nanosecondsParam);\n\n    ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n\n    CreateSlots(this);\n    SetSlot(this, YEARS, years);\n    SetSlot(this, MONTHS, months);\n    SetSlot(this, WEEKS, weeks);\n    SetSlot(this, DAYS, days);\n    SetSlot(this, HOURS, hours);\n    SetSlot(this, MINUTES, minutes);\n    SetSlot(this, SECONDS, seconds);\n    SetSlot(this, MILLISECONDS, milliseconds);\n    SetSlot(this, MICROSECONDS, microseconds);\n    SetSlot(this, NANOSECONDS, nanoseconds);\n\n    if (DEBUG) {\n      Object.defineProperty(this, '_repr_', {\n        value: `Temporal.Duration <${ES.TemporalDurationToString(this, 'auto')}>`,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n  get years(): Return['years'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, YEARS);\n  }\n  get months(): Return['months'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MONTHS);\n  }\n  get weeks(): Return['weeks'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, WEEKS);\n  }\n  get days(): Return['days'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, DAYS);\n  }\n  get hours(): Return['hours'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, HOURS);\n  }\n  get minutes(): Return['minutes'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MINUTES);\n  }\n  get seconds(): Return['seconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, SECONDS);\n  }\n  get milliseconds(): Return['milliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MILLISECONDS);\n  }\n  get microseconds(): Return['microseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, MICROSECONDS);\n  }\n  get nanoseconds(): Return['nanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return GetSlot(this, NANOSECONDS);\n  }\n  get sign(): Return['sign'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.DurationSign(this);\n  }\n  get blank(): Return['blank'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.DurationSign(this) === 0;\n  }\n  with(durationLike: Params['with'][0]): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    const partialDuration = ES.ToTemporalPartialDurationRecord(durationLike);\n    const {\n      years = GetSlot(this, YEARS),\n      months = GetSlot(this, MONTHS),\n      weeks = GetSlot(this, WEEKS),\n      days = GetSlot(this, DAYS),\n      hours = GetSlot(this, HOURS),\n      minutes = GetSlot(this, MINUTES),\n      seconds = GetSlot(this, SECONDS),\n      milliseconds = GetSlot(this, MILLISECONDS),\n      microseconds = GetSlot(this, MICROSECONDS),\n      nanoseconds = GetSlot(this, NANOSECONDS)\n    } = partialDuration;\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n  }\n  negated(): Return['negated'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.CreateNegatedTemporalDuration(this);\n  }\n  abs(): Return['abs'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return new Duration(\n      Math.abs(GetSlot(this, YEARS)),\n      Math.abs(GetSlot(this, MONTHS)),\n      Math.abs(GetSlot(this, WEEKS)),\n      Math.abs(GetSlot(this, DAYS)),\n      Math.abs(GetSlot(this, HOURS)),\n      Math.abs(GetSlot(this, MINUTES)),\n      Math.abs(GetSlot(this, SECONDS)),\n      Math.abs(GetSlot(this, MILLISECONDS)),\n      Math.abs(GetSlot(this, MICROSECONDS)),\n      Math.abs(GetSlot(this, NANOSECONDS))\n    );\n  }\n  add(other: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.AddDurations('add', this, other);\n  }\n  subtract(other: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.AddDurations('subtract', this, other);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n\n    const existingLargestUnit = ES.DefaultTemporalLargestUnit(this);\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n\n    let largestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'largestUnit', 'datetime', undefined, ['auto']);\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(roundTo);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    let smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'datetime', undefined);\n\n    let smallestUnitPresent = true;\n    if (!smallestUnit) {\n      smallestUnitPresent = false;\n      smallestUnit = 'nanosecond';\n    }\n    const defaultLargestUnit = ES.LargerOfTwoTemporalUnits(existingLargestUnit, smallestUnit);\n    let largestUnitPresent = true;\n    if (!largestUnit) {\n      largestUnitPresent = false;\n      largestUnit = defaultLargestUnit;\n    }\n    if (largestUnit === 'auto') largestUnit = defaultLargestUnit;\n    if (!smallestUnitPresent && !largestUnitPresent) {\n      throw new RangeError('at least one of smallestUnit or largestUnit is required');\n    }\n    if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n      throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n\n    const maximumIncrements = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    } as { [k in Temporal.DateTimeUnit]?: number };\n    const maximum = maximumIncrements[smallestUnit];\n    if (maximum !== undefined) ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, false);\n    if (roundingIncrement > 1 && ES.TemporalUnitCategory(smallestUnit) === 'date' && largestUnit !== smallestUnit) {\n      throw new RangeError('For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit');\n    }\n\n    if (zonedRelativeTo) {\n      let duration = ES.ToInternalDurationRecord(this);\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\n      duration = ES.DifferenceZonedDateTimeWithRounding(\n        relativeEpochNs,\n        targetEpochNs,\n        timeZone,\n        calendar,\n        largestUnit,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode\n      );\n      if (ES.TemporalUnitCategory(largestUnit) === 'date') largestUnit = 'hour';\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\n    }\n\n    if (plainRelativeTo) {\n      let duration = ES.ToInternalDurationRecordWith24HourDays(this);\n      const targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\n\n      // Delegate the date part addition to the calendar\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\n\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\n      duration = ES.DifferencePlainDateTimeWithRounding(\n        isoDateTime,\n        targetDateTime,\n        calendar,\n        largestUnit,\n        roundingIncrement,\n        smallestUnit,\n        roundingMode\n      );\n      return ES.TemporalDurationFromInternal(duration, largestUnit);\n    }\n\n    // No reference date to calculate difference relative to\n    if (ES.IsCalendarUnit(existingLargestUnit)) {\n      throw new RangeError(`a starting point is required for ${existingLargestUnit}s balancing`);\n    }\n    if (ES.IsCalendarUnit(largestUnit)) {\n      throw new RangeError(`a starting point is required for ${largestUnit}s balancing`);\n    }\n    assert(!ES.IsCalendarUnit(smallestUnit), 'smallestUnit was larger than largestUnit');\n    let internalDuration = ES.ToInternalDurationRecordWith24HourDays(this);\n    if (smallestUnit === 'day') {\n      // First convert time units up to days\n      const { quotient, remainder } = internalDuration.time.divmod(ES.DAY_NANOS);\n      let days = internalDuration.date.days + quotient + ES.TotalTimeDuration(remainder, 'day');\n      days = ES.RoundNumberToIncrement(days, roundingIncrement, roundingMode);\n      const dateDuration = { years: 0, months: 0, weeks: 0, days };\n      internalDuration = ES.CombineDateAndTimeDuration(dateDuration, TimeDuration.ZERO);\n    } else {\n      const timeDuration = ES.RoundTimeDuration(internalDuration.time, roundingIncrement, smallestUnit, roundingMode);\n      internalDuration = ES.CombineDateAndTimeDuration(ES.ZeroDateDuration(), timeDuration);\n    }\n    return ES.TemporalDurationFromInternal(internalDuration, largestUnit);\n  }\n  total(optionsParam: Params['total'][0]): Return['total'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n\n    if (optionsParam === undefined) throw new TypeError('options argument is required');\n    const options =\n      typeof optionsParam === 'string'\n        ? (ES.CreateOnePropObject('unit', optionsParam) as Exclude<typeof optionsParam, string>)\n        : ES.GetOptionsObject(optionsParam);\n    let { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(options);\n    const unit = ES.GetTemporalUnitValuedOption(options, 'unit', 'datetime', ES.REQUIRED);\n\n    if (zonedRelativeTo) {\n      const duration = ES.ToInternalDurationRecord(this);\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const relativeEpochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n      const targetEpochNs = ES.AddZonedDateTime(relativeEpochNs, timeZone, calendar, duration);\n      return ES.DifferenceZonedDateTimeWithTotal(relativeEpochNs, targetEpochNs, timeZone, calendar, unit);\n    }\n\n    if (plainRelativeTo) {\n      const duration = ES.ToInternalDurationRecordWith24HourDays(this);\n      let targetTime = ES.AddTime(ES.MidnightTimeRecord(), duration.time);\n\n      // Delegate the date part addition to the calendar\n      const isoRelativeToDate = GetSlot(plainRelativeTo, ISO_DATE);\n      const calendar = GetSlot(plainRelativeTo, CALENDAR);\n      const dateDuration = ES.AdjustDateDurationRecord(duration.date, targetTime.deltaDays);\n      const targetDate = ES.CalendarDateAdd(calendar, isoRelativeToDate, dateDuration, 'constrain');\n\n      const isoDateTime = ES.CombineISODateAndTimeRecord(isoRelativeToDate, ES.MidnightTimeRecord());\n      const targetDateTime = ES.CombineISODateAndTimeRecord(targetDate, targetTime);\n      return ES.DifferencePlainDateTimeWithTotal(isoDateTime, targetDateTime, calendar, unit);\n    }\n\n    // No reference date to calculate difference relative to\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\n    if (ES.IsCalendarUnit(largestUnit)) {\n      throw new RangeError(`a starting point is required for ${largestUnit}s total`);\n    }\n    if (ES.IsCalendarUnit(unit)) {\n      throw new RangeError(`a starting point is required for ${unit}s total`);\n    }\n    const duration = ES.ToInternalDurationRecordWith24HourDays(this);\n    return ES.TotalTimeDuration(duration.time, unit);\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour' || smallestUnit === 'minute') {\n      throw new RangeError('smallestUnit must be a time unit other than \"hours\" or \"minutes\"');\n    }\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    ES.uncheckedAssertNarrowedType<Exclude<typeof precision, 'minute'>>(\n      precision,\n      'Precision cannot be \"minute\" because of RangeError above'\n    );\n\n    if (unit === 'nanosecond' && increment === 1) return ES.TemporalDurationToString(this, precision);\n\n    const largestUnit = ES.DefaultTemporalLargestUnit(this);\n    let internalDuration = ES.ToInternalDurationRecord(this);\n    const timeDuration = ES.RoundTimeDuration(internalDuration.time, increment, unit, roundingMode);\n    internalDuration = ES.CombineDateAndTimeDuration(internalDuration.date, timeDuration);\n    const roundedDuration = ES.TemporalDurationFromInternal(\n      internalDuration,\n      ES.LargerOfTwoTemporalUnits(largestUnit, 'second')\n    );\n    return ES.TemporalDurationToString(roundedDuration, precision);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    return ES.TemporalDurationToString(this, 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalDuration);\n    if (typeof Intl.DurationFormat === 'function') {\n      const formatter = new Intl.DurationFormat(locales, options as Intl.DurationFormatOptions);\n      return ModifiedIntlDurationFormatPrototypeFormat.call(formatter, this);\n    }\n    console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n    return ES.TemporalDurationToString(this, 'auto');\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('Duration');\n  }\n  static from(item: Params['from'][0]): Return['from'] {\n    return ES.ToTemporalDuration(item);\n  }\n  static compare(\n    oneParam: Params['compare'][0],\n    twoParam: Params['compare'][1],\n    options: Params['compare'][2] = undefined\n  ): Return['compare'] {\n    const one = ES.ToTemporalDuration(oneParam);\n    const two = ES.ToTemporalDuration(twoParam);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const { plainRelativeTo, zonedRelativeTo } = ES.GetTemporalRelativeToOption(resolvedOptions);\n\n    if (\n      GetSlot(one, YEARS) === GetSlot(two, YEARS) &&\n      GetSlot(one, MONTHS) === GetSlot(two, MONTHS) &&\n      GetSlot(one, WEEKS) === GetSlot(two, WEEKS) &&\n      GetSlot(one, DAYS) === GetSlot(two, DAYS) &&\n      GetSlot(one, HOURS) === GetSlot(two, HOURS) &&\n      GetSlot(one, MINUTES) === GetSlot(two, MINUTES) &&\n      GetSlot(one, SECONDS) === GetSlot(two, SECONDS) &&\n      GetSlot(one, MILLISECONDS) === GetSlot(two, MILLISECONDS) &&\n      GetSlot(one, MICROSECONDS) === GetSlot(two, MICROSECONDS) &&\n      GetSlot(one, NANOSECONDS) === GetSlot(two, NANOSECONDS)\n    ) {\n      return 0;\n    }\n\n    const largestUnit1 = ES.DefaultTemporalLargestUnit(one);\n    const largestUnit2 = ES.DefaultTemporalLargestUnit(two);\n    const duration1 = ES.ToInternalDurationRecord(one);\n    const duration2 = ES.ToInternalDurationRecord(two);\n\n    if (\n      zonedRelativeTo &&\n      (ES.TemporalUnitCategory(largestUnit1) === 'date' || ES.TemporalUnitCategory(largestUnit2) === 'date')\n    ) {\n      const timeZone = GetSlot(zonedRelativeTo, TIME_ZONE);\n      const calendar = GetSlot(zonedRelativeTo, CALENDAR);\n      const epochNs = GetSlot(zonedRelativeTo, EPOCHNANOSECONDS);\n\n      const after1 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration1);\n      const after2 = ES.AddZonedDateTime(epochNs, timeZone, calendar, duration2);\n      return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(after1, after2)));\n    }\n\n    let d1 = duration1.date.days;\n    let d2 = duration2.date.days;\n    if (ES.IsCalendarUnit(largestUnit1) || ES.IsCalendarUnit(largestUnit2)) {\n      if (!plainRelativeTo) {\n        throw new RangeError('A starting point is required for years, months, or weeks comparison');\n      }\n      d1 = ES.DateDurationDays(duration1.date, plainRelativeTo);\n      d2 = ES.DateDurationDays(duration2.date, plainRelativeTo);\n    }\n    const timeDuration1 = duration1.time.add24HourDays(d1);\n    const timeDuration2 = duration2.time.add24HourDays(d2);\n    return timeDuration1.cmp(timeDuration2);\n  }\n  [Symbol.toStringTag]!: 'Temporal.Duration';\n}\n\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { CalendarDateRecord, PlainMonthDayParams as Params, PlainMonthDayReturn as Return } from './internaltypes';\n\nexport class PlainMonthDay implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonth: Params['constructor'][0],\n    isoDay: Params['constructor'][0],\n    calendarParam = 'iso8601',\n    referenceISOYear = 1972\n  ) {\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const day = ES.ToIntegerWithTruncation(isoDay);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    const year = ES.ToIntegerWithTruncation(referenceISOYear);\n\n    ES.RejectISODate(year, month, day);\n    ES.CreateTemporalMonthDaySlots(this, { year, month, day }, calendar);\n  }\n\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return GetSlot(this, CALENDAR);\n  }\n\n  with(temporalMonthDayLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    if (!ES.IsObject(temporalMonthDayLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalMonthDayLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\n    const partialMonthDay = ES.PrepareCalendarFields(\n      calendar,\n      temporalMonthDayLike,\n      ['year', 'month', 'monthCode', 'day'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialMonthDay);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarMonthDayFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalMonthDay(isoDate, calendar);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    const other = ES.ToTemporalMonthDay(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalMonthDayToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return ES.TemporalMonthDayToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainMonthDay');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalMonthDay);\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'month-day');\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['year'], [], []);\n    let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalMonthDay(item, options);\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainMonthDay';\n}\n\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  md: Temporal.PlainMonthDay,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(md, ES.IsTemporalMonthDay);\n  const isoDate = GetSlot(md, ISO_DATE);\n  return ES.calendarImplForObj(md).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import * as ES from './ecmascript';\nimport type { Temporal } from '..';\n\nfunction SystemDateTime(timeZone: string) {\n  return ES.GetISODateTimeFor(timeZone, ES.SystemUTCEpochNanoSeconds());\n}\n\nconst instant: (typeof Temporal.Now)['instant'] = () => {\n  return ES.CreateTemporalInstant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTimeISO: (typeof Temporal.Now)['plainDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalDateTime(isoDateTime, 'iso8601');\n};\nconst zonedDateTimeISO: (typeof Temporal.Now)['zonedDateTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), timeZone, 'iso8601');\n};\nconst plainDateISO: (typeof Temporal.Now)['plainDateISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalDate(isoDateTime.isoDate, 'iso8601');\n};\nconst plainTimeISO: (typeof Temporal.Now)['plainTimeISO'] = (temporalTimeZoneLike = ES.DefaultTimeZone()) => {\n  const timeZone = ES.ToTemporalTimeZoneIdentifier(temporalTimeZoneLike);\n  const isoDateTime = SystemDateTime(timeZone);\n  return ES.CreateTemporalTime(isoDateTime.time);\n};\nconst timeZoneId: (typeof Temporal.Now)['timeZoneId'] = () => {\n  return ES.DefaultTimeZone();\n};\n\nexport const Now: typeof Temporal.Now = {\n  instant,\n  plainDateTimeISO,\n  plainDateISO,\n  plainTimeISO,\n  timeZoneId,\n  zonedDateTimeISO,\n  [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n  value: 'Temporal.Now',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\n\nimport { GetSlot, TIME } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type { PlainTimeParams as Params, PlainTimeReturn as Return } from './internaltypes';\n\nexport class PlainTime implements Temporal.PlainTime {\n  constructor(isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) {\n    const hour = isoHour === undefined ? 0 : ES.ToIntegerWithTruncation(isoHour);\n    const minute = isoMinute === undefined ? 0 : ES.ToIntegerWithTruncation(isoMinute);\n    const second = isoSecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoSecond);\n    const millisecond = isoMillisecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMillisecond);\n    const microsecond = isoMicrosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoMicrosecond);\n    const nanosecond = isoNanosecond === undefined ? 0 : ES.ToIntegerWithTruncation(isoNanosecond);\n\n    ES.RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    const time = { hour, minute, second, millisecond, microsecond, nanosecond };\n\n    ES.CreateTemporalTimeSlots(this, time);\n  }\n\n  get hour(): Return['hour'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).hour;\n  }\n  get minute(): Return['minute'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).minute;\n  }\n  get second(): Return['second'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).second;\n  }\n  get millisecond(): Return['millisecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).millisecond;\n  }\n  get microsecond(): Return['microsecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).microsecond;\n  }\n  get nanosecond(): Return['nanosecond'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return GetSlot(this, TIME).nanosecond;\n  }\n\n  with(temporalTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    if (!ES.IsObject(temporalTimeLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalTimeLike);\n\n    const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n\n    const fields = ES.ToTemporalTimeRecord(this);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = Object.assign(fields, partialTime);\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(\n      hour,\n      minute,\n      second,\n      millisecond,\n      microsecond,\n      nanosecond,\n      overflow\n    ));\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n  }\n  add(temporalDurationLike: Params['add'][0]): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.AddDurationToTime('add', this, temporalDurationLike);\n  }\n  subtract(temporalDurationLike: Params['subtract'][0]): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.AddDurationToTime('subtract', this, temporalDurationLike);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.DifferenceTemporalPlainTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.DifferenceTemporalPlainTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED);\n    const MAX_INCREMENTS = {\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, MAX_INCREMENTS[smallestUnit], false);\n\n    const time = ES.RoundTime(GetSlot(this, TIME), roundingIncrement, smallestUnit, roundingMode);\n    return ES.CreateTemporalTime(time);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    const other = ES.ToTemporalTime(otherParam);\n    return ES.CompareTimeRecord(GetSlot(this, TIME), GetSlot(other, TIME)) === 0;\n  }\n\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    const time = ES.RoundTime(GetSlot(this, TIME), increment, unit, roundingMode);\n    return ES.TimeRecordToString(time, precision);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return ES.TimeRecordToString(GetSlot(this, TIME), 'auto');\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalTime);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainTime');\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalTime(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalTime(oneParam);\n    const two = ES.ToTemporalTime(twoParam);\n    return ES.CompareTimeRecord(GetSlot(one, TIME), GetSlot(two, TIME));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainTime';\n}\n\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, GetSlot, ISO_DATE } from './slots';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type {\n  CalendarDateRecord,\n  PlainYearMonthParams as Params,\n  PlainYearMonthReturn as Return\n} from './internaltypes';\n\nexport class PlainYearMonth implements Temporal.PlainYearMonth {\n  constructor(\n    isoYear: Params['constructor'][0],\n    isoMonth: Params['constructor'][1],\n    calendarParam: Params['constructor'][2] = 'iso8601',\n    referenceISODay: Params['constructor'][3] = 1\n  ) {\n    const year = ES.ToIntegerWithTruncation(isoYear);\n    const month = ES.ToIntegerWithTruncation(isoMonth);\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n    const day = ES.ToIntegerWithTruncation(referenceISODay);\n\n    ES.RejectISODate(year, month, day);\n    ES.CreateTemporalYearMonthSlots(this, { year, month, day }, calendar);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return GetSlot(this, CALENDAR);\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  with(temporalYearMonthLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    if (!ES.IsObject(temporalYearMonthLike)) {\n      throw new TypeError('invalid argument');\n    }\n    ES.RejectTemporalLikeObject(temporalYearMonthLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    let fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\n    const partialYearMonth = ES.PrepareCalendarFields(\n      calendar,\n      temporalYearMonthLike,\n      ['year', 'month', 'monthCode'],\n      [],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialYearMonth);\n\n    const overflow = ES.GetTemporalOverflowOption(ES.GetOptionsObject(options));\n    const isoDate = ES.CalendarYearMonthFromFields(calendar, fields, overflow);\n    return ES.CreateTemporalYearMonth(isoDate, calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.AddDurationToYearMonth('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.AddDurationToYearMonth('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    const other = ES.ToTemporalYearMonth(otherParam);\n    if (ES.CompareISODate(GetSlot(this, ISO_DATE), GetSlot(other, ISO_DATE)) !== 0) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    return ES.TemporalYearMonthToString(this, showCalendar);\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return ES.TemporalYearMonthToString(this);\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    return new DateTimeFormat(locales, options).format(this);\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('PlainYearMonth');\n  }\n  toPlainDate(item: Params['toPlainDate'][0]): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalYearMonth);\n    if (!ES.IsObject(item)) throw new TypeError('argument should be an object');\n    const calendar = GetSlot(this, CALENDAR);\n\n    const fields = ES.ISODateToFields(calendar, GetSlot(this, ISO_DATE), 'year-month');\n    const inputFields = ES.PrepareCalendarFields(calendar, item, ['day'], [], []);\n    const mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n    const isoDate = ES.CalendarDateFromFields(calendar, mergedFields, 'constrain');\n    return ES.CreateTemporalDate(isoDate, calendar);\n  }\n\n  static from(item: Params['from'][0], options: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalYearMonth(item, options);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalYearMonth(oneParam);\n    const two = ES.ToTemporalYearMonth(twoParam);\n    return ES.CompareISODate(GetSlot(one, ISO_DATE), GetSlot(two, ISO_DATE));\n  }\n  [Symbol.toStringTag]!: 'Temporal.PlainYearMonth';\n}\n\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  ym: Temporal.PlainYearMonth,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(ym, ES.IsTemporalYearMonth);\n  const isoDate = GetSlot(ym, ISO_DATE);\n  return ES.calendarImplForObj(ym).isoToDate(isoDate, { [prop]: true })[prop];\n}\n","import { assert } from './assert';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, EPOCHNANOSECONDS, TIME, TIME_ZONE, GetSlot } from './slots';\nimport { TimeDuration } from './timeduration';\nimport type { Temporal } from '..';\nimport { DateTimeFormat } from './intl';\nimport type {\n  BuiltinCalendarId,\n  CalendarDateRecord,\n  ZonedDateTimeParams as Params,\n  ZonedDateTimeReturn as Return\n} from './internaltypes';\n\nimport JSBI from 'jsbi';\n\nconst customResolvedOptions = DateTimeFormat.prototype.resolvedOptions as Intl.DateTimeFormat['resolvedOptions'];\n\nexport class ZonedDateTime implements Temporal.ZonedDateTime {\n  constructor(epochNanosecondsParam: bigint | JSBI, timeZoneParam: string, calendarParam = 'iso8601') {\n    // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n    //       to improve the error message.\n    if (arguments.length < 1) {\n      throw new TypeError('missing argument: epochNanoseconds is required');\n    }\n    const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n    let timeZone = ES.RequireString(timeZoneParam);\n    const { tzName, offsetMinutes } = ES.ParseTimeZoneIdentifier(timeZone);\n    if (offsetMinutes === undefined) {\n      // if offsetMinutes is undefined, then tzName must be present\n      const record = ES.GetAvailableNamedTimeZoneIdentifier(tzName);\n      if (!record) throw new RangeError(`unknown time zone ${tzName}`);\n      timeZone = record.identifier;\n    } else {\n      timeZone = ES.FormatOffsetTimeZoneIdentifier(offsetMinutes);\n    }\n    const calendar = ES.CanonicalizeCalendar(calendarParam === undefined ? 'iso8601' : ES.RequireString(calendarParam));\n\n    ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n  }\n  get calendarId(): Return['calendarId'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return GetSlot(this, CALENDAR);\n  }\n  get timeZoneId(): Return['timeZoneId'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return GetSlot(this, TIME_ZONE);\n  }\n  get year(): Return['year'] {\n    return getCalendarProperty(this, 'year');\n  }\n  get month(): Return['month'] {\n    return getCalendarProperty(this, 'month');\n  }\n  get monthCode(): Return['monthCode'] {\n    return getCalendarProperty(this, 'monthCode');\n  }\n  get day(): Return['day'] {\n    return getCalendarProperty(this, 'day');\n  }\n  get hour(): Return['hour'] {\n    return getTimeProperty(this, 'hour');\n  }\n  get minute(): Return['minute'] {\n    return getTimeProperty(this, 'minute');\n  }\n  get second(): Return['second'] {\n    return getTimeProperty(this, 'second');\n  }\n  get millisecond(): Return['millisecond'] {\n    return getTimeProperty(this, 'millisecond');\n  }\n  get microsecond(): Return['microsecond'] {\n    return getTimeProperty(this, 'microsecond');\n  }\n  get nanosecond(): Return['nanosecond'] {\n    return getTimeProperty(this, 'nanosecond');\n  }\n  get era(): Return['era'] {\n    return getCalendarProperty(this, 'era');\n  }\n  get eraYear(): Return['eraYear'] {\n    return getCalendarProperty(this, 'eraYear');\n  }\n  get epochMilliseconds(): Return['epochMilliseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const value = GetSlot(this, EPOCHNANOSECONDS);\n    return ES.epochNsToMs(value, 'floor');\n  }\n  get epochNanoseconds(): Return['epochNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  get dayOfWeek(): Return['dayOfWeek'] {\n    return getCalendarProperty(this, 'dayOfWeek');\n  }\n  get dayOfYear(): Return['dayOfYear'] {\n    return getCalendarProperty(this, 'dayOfYear');\n  }\n  get weekOfYear(): Return['weekOfYear'] {\n    return getCalendarProperty(this, 'weekOfYear')?.week;\n  }\n  get yearOfWeek(): Return['yearOfWeek'] {\n    return getCalendarProperty(this, 'weekOfYear')?.year;\n  }\n  get hoursInDay(): Return['hoursInDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const today = dateTime(this).isoDate;\n    const tomorrow = ES.BalanceISODate(today.year, today.month, today.day + 1);\n    const todayNs = ES.GetStartOfDay(timeZone, today);\n    const tomorrowNs = ES.GetStartOfDay(timeZone, tomorrow);\n    const diff = TimeDuration.fromEpochNsDiff(tomorrowNs, todayNs);\n    return ES.TotalTimeDuration(diff, 'hour');\n  }\n  get daysInWeek(): Return['daysInWeek'] {\n    return getCalendarProperty(this, 'daysInWeek');\n  }\n  get daysInMonth(): Return['daysInMonth'] {\n    return getCalendarProperty(this, 'daysInMonth');\n  }\n  get daysInYear(): Return['daysInYear'] {\n    return getCalendarProperty(this, 'daysInYear');\n  }\n  get monthsInYear(): Return['monthsInYear'] {\n    return getCalendarProperty(this, 'monthsInYear');\n  }\n  get inLeapYear(): Return['inLeapYear'] {\n    return getCalendarProperty(this, 'inLeapYear');\n  }\n  get offset(): Return['offset'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const offsetNs = ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\n    return ES.FormatUTCOffsetNanoseconds(offsetNs);\n  }\n  get offsetNanoseconds(): Return['offsetNanoseconds'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, EPOCHNANOSECONDS));\n  }\n  with(temporalZonedDateTimeLike: Params['with'][0], options: Params['with'][1] = undefined): Return['with'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    if (!ES.IsObject(temporalZonedDateTimeLike)) {\n      throw new TypeError('invalid zoned-date-time-like');\n    }\n    ES.RejectTemporalLikeObject(temporalZonedDateTimeLike);\n\n    const calendar = GetSlot(this, CALENDAR);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const epochNs = GetSlot(this, EPOCHNANOSECONDS);\n    const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, epochNs);\n    const isoDateTime = dateTime(this);\n    let fields = {\n      ...ES.ISODateToFields(calendar, isoDateTime.isoDate),\n      ...isoDateTime.time,\n      offset: ES.FormatUTCOffsetNanoseconds(offsetNs)\n    };\n    const partialZonedDateTime = ES.PrepareCalendarFields(\n      calendar,\n      temporalZonedDateTimeLike,\n      ['year', 'month', 'monthCode', 'day'],\n      ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond', 'offset'],\n      'partial'\n    );\n    fields = ES.CalendarMergeFields(calendar, fields, partialZonedDateTime);\n\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const disambiguation = ES.GetTemporalDisambiguationOption(resolvedOptions);\n    const offset = ES.GetTemporalOffsetOption(resolvedOptions, 'prefer');\n    const overflow = ES.GetTemporalOverflowOption(resolvedOptions);\n\n    const newDateTime = ES.InterpretTemporalDateTimeFields(calendar, fields, overflow);\n    const newOffsetNs = ES.ParseDateTimeUTCOffset(fields.offset);\n    const epochNanoseconds = ES.InterpretISODateTimeOffset(\n      newDateTime.isoDate,\n      newDateTime.time,\n      'option',\n      newOffsetNs,\n      timeZone,\n      disambiguation,\n      offset,\n      /* matchMinute = */ false\n    );\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n  }\n  withPlainTime(temporalTimeParam: Params['withPlainTime'][0] = undefined): Return['withPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const calendar = GetSlot(this, CALENDAR);\n    const iso = dateTime(this).isoDate;\n\n    let epochNs;\n    if (temporalTimeParam === undefined) {\n      epochNs = ES.GetStartOfDay(timeZone, iso);\n    } else {\n      const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n      const dt = ES.CombineISODateAndTimeRecord(iso, GetSlot(temporalTime, TIME));\n      epochNs = ES.GetEpochNanosecondsFor(timeZone, dt, 'compatible');\n    }\n    return ES.CreateTemporalZonedDateTime(epochNs, timeZone, calendar);\n  }\n  withTimeZone(timeZoneParam: Params['withTimeZone'][0]): Return['withTimeZone'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = ES.ToTemporalTimeZoneIdentifier(timeZoneParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n  }\n  withCalendar(calendarParam: Params['withCalendar'][0]): Return['withCalendar'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const calendar = ES.ToTemporalCalendarIdentifier(calendarParam);\n    return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n  }\n  add(temporalDurationLike: Params['add'][0], options: Params['add'][1] = undefined): Return['add'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.AddDurationToZonedDateTime('add', this, temporalDurationLike, options);\n  }\n  subtract(\n    temporalDurationLike: Params['subtract'][0],\n    options: Params['subtract'][1] = undefined\n  ): Return['subtract'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.AddDurationToZonedDateTime('subtract', this, temporalDurationLike, options);\n  }\n  until(other: Params['until'][0], options: Params['until'][1] = undefined): Return['until'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n  }\n  since(other: Params['since'][0], options: Params['since'][1] = undefined): Return['since'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n  }\n  round(roundToParam: Params['round'][0]): Return['round'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    if (roundToParam === undefined) throw new TypeError('options parameter is required');\n    const roundTo =\n      typeof roundToParam === 'string'\n        ? (ES.CreateOnePropObject('smallestUnit', roundToParam) as Exclude<typeof roundToParam, string>)\n        : ES.GetOptionsObject(roundToParam);\n    const roundingIncrement = ES.GetTemporalRoundingIncrementOption(roundTo);\n    const roundingMode = ES.GetRoundingModeOption(roundTo, 'halfExpand');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(roundTo, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n    const maximumIncrements = {\n      day: 1,\n      hour: 24,\n      minute: 60,\n      second: 60,\n      millisecond: 1000,\n      microsecond: 1000,\n      nanosecond: 1000\n    };\n    const maximum = maximumIncrements[smallestUnit];\n    const inclusive = maximum === 1;\n    ES.ValidateTemporalRoundingIncrement(roundingIncrement, maximum, inclusive);\n\n    if (smallestUnit === 'nanosecond' && roundingIncrement === 1) {\n      return ES.CreateTemporalZonedDateTime(\n        GetSlot(this, EPOCHNANOSECONDS),\n        GetSlot(this, TIME_ZONE),\n        GetSlot(this, CALENDAR)\n      );\n    }\n\n    // first, round the underlying DateTime fields\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const thisNs = GetSlot(this, EPOCHNANOSECONDS);\n    const iso = dateTime(this);\n    let epochNanoseconds;\n\n    if (smallestUnit === 'day') {\n      // Compute Instants for start-of-day and end-of-day\n      // Determine how far the current instant has progressed through this span.\n      const dateStart = iso.isoDate;\n      const dateEnd = ES.BalanceISODate(dateStart.year, dateStart.month, dateStart.day + 1);\n\n      const startNs = ES.GetStartOfDay(timeZone, dateStart);\n      assert(\n        JSBI.greaterThanOrEqual(thisNs, startNs),\n        'cannot produce an instant during a day that occurs before start-of-day instant'\n      );\n\n      const endNs = ES.GetStartOfDay(timeZone, dateEnd);\n      assert(\n        JSBI.lessThan(thisNs, endNs),\n        'cannot produce an instant during a day that occurs on or after end-of-day instant'\n      );\n\n      const dayLengthNs = JSBI.subtract(endNs, startNs);\n      const dayProgressNs = TimeDuration.fromEpochNsDiff(thisNs, startNs);\n      const roundedDayNs = dayProgressNs.round(dayLengthNs, roundingMode);\n      epochNanoseconds = roundedDayNs.addToEpochNs(startNs);\n    } else {\n      // smallestUnit < day\n      // Round based on ISO-calendar time units\n      const roundedDateTime = ES.RoundISODateTime(iso, roundingIncrement, smallestUnit, roundingMode);\n\n      // Now reset all DateTime fields but leave the TimeZone. The offset will\n      // also be retained if the new date/time values are still OK with the old\n      // offset. Otherwise the offset will be changed to be compatible with the\n      // new date/time values. If DST disambiguation is required, the `compatible`\n      // disambiguation algorithm will be used.\n      const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, thisNs);\n      epochNanoseconds = ES.InterpretISODateTimeOffset(\n        roundedDateTime.isoDate,\n        roundedDateTime.time,\n        'option',\n        offsetNs,\n        timeZone,\n        'compatible',\n        'prefer',\n        /* matchMinute = */ false\n      );\n    }\n\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  equals(otherParam: Params['equals'][0]): Return['equals'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const other = ES.ToTemporalZonedDateTime(otherParam);\n    const one = GetSlot(this, EPOCHNANOSECONDS);\n    const two = GetSlot(other, EPOCHNANOSECONDS);\n    if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two))) return false;\n    if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE))) return false;\n    return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n  }\n  toString(options: Params['toString'][0] = undefined): string {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n    const showCalendar = ES.GetTemporalShowCalendarNameOption(resolvedOptions);\n    const digits = ES.GetTemporalFractionalSecondDigitsOption(resolvedOptions);\n    const showOffset = ES.GetTemporalShowOffsetOption(resolvedOptions);\n    const roundingMode = ES.GetRoundingModeOption(resolvedOptions, 'trunc');\n    const smallestUnit = ES.GetTemporalUnitValuedOption(resolvedOptions, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') throw new RangeError('smallestUnit must be a time unit other than \"hour\"');\n    const showTimeZone = ES.GetTemporalShowTimeZoneNameOption(resolvedOptions);\n    const { precision, unit, increment } = ES.ToSecondsStringPrecisionRecord(smallestUnit, digits);\n    return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n      unit,\n      increment,\n      roundingMode\n    });\n  }\n  toLocaleString(\n    locales: Params['toLocaleString'][0] = undefined,\n    options: Params['toLocaleString'][1] = undefined\n  ): string {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const resolvedOptions = ES.GetOptionsObject(options);\n\n    // This is not quite per specification, but this polyfill's DateTimeFormat\n    // already doesn't match the InitializeDateTimeFormat operation, and the\n    // access order might change anyway;\n    // see https://github.com/tc39/ecma402/issues/747\n    const optionsCopy = Object.create(null);\n    ES.CopyDataProperties(optionsCopy, resolvedOptions, ['timeZone']);\n\n    if (resolvedOptions.timeZone !== undefined) {\n      throw new TypeError('ZonedDateTime toLocaleString does not accept a timeZone option');\n    }\n\n    if (\n      optionsCopy.year === undefined &&\n      optionsCopy.month === undefined &&\n      optionsCopy.day === undefined &&\n      optionsCopy.era === undefined &&\n      optionsCopy.weekday === undefined &&\n      optionsCopy.dateStyle === undefined &&\n      optionsCopy.hour === undefined &&\n      optionsCopy.minute === undefined &&\n      optionsCopy.second === undefined &&\n      optionsCopy.fractionalSecondDigits === undefined &&\n      optionsCopy.timeStyle === undefined &&\n      optionsCopy.dayPeriod === undefined &&\n      optionsCopy.timeZoneName === undefined\n    ) {\n      optionsCopy.timeZoneName = 'short';\n      // The rest of the defaults will be filled in by formatting the Instant\n    }\n\n    optionsCopy.timeZone = GetSlot(this, TIME_ZONE);\n    if (ES.IsOffsetTimeZoneIdentifier(optionsCopy.timeZone)) {\n      // Note: https://github.com/tc39/ecma402/issues/683 will remove this\n      throw new RangeError('toLocaleString does not currently support offset time zones');\n    }\n\n    const formatter = new DateTimeFormat(locales, optionsCopy);\n\n    const localeCalendarIdentifier = customResolvedOptions.call(formatter).calendar as BuiltinCalendarId;\n    const calendarIdentifier = GetSlot(this, CALENDAR);\n    if (\n      calendarIdentifier !== 'iso8601' &&\n      localeCalendarIdentifier !== 'iso8601' &&\n      !ES.CalendarEquals(localeCalendarIdentifier, calendarIdentifier)\n    ) {\n      throw new RangeError(\n        `cannot format ZonedDateTime with calendar ${calendarIdentifier}` +\n          ` in locale with calendar ${localeCalendarIdentifier}`\n      );\n    }\n\n    return formatter.format(ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS)));\n  }\n  toJSON(): Return['toJSON'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.TemporalZonedDateTimeToString(this, 'auto');\n  }\n  valueOf(): never {\n    ES.ValueOfThrows('ZonedDateTime');\n  }\n  startOfDay(): Return['startOfDay'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n    const isoDate = dateTime(this).isoDate;\n    const epochNanoseconds = ES.GetStartOfDay(timeZone, isoDate);\n    return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  getTimeZoneTransition(directionParam: Params['getTimeZoneTransition'][0]): Return['getTimeZoneTransition'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    const timeZone = GetSlot(this, TIME_ZONE);\n\n    if (directionParam === undefined) throw new TypeError('options parameter is required');\n    const direction = ES.GetDirectionOption(\n      typeof directionParam === 'string'\n        ? (ES.CreateOnePropObject('direction', directionParam) as Exclude<typeof directionParam, string>)\n        : ES.GetOptionsObject(directionParam)\n    );\n    if (direction === undefined) throw new TypeError('direction option is required');\n\n    // Offset time zones or UTC have no transitions\n    if (ES.IsOffsetTimeZoneIdentifier(timeZone) || timeZone === 'UTC') {\n      return null;\n    }\n\n    const thisEpochNanoseconds = GetSlot(this, EPOCHNANOSECONDS);\n    const epochNanoseconds =\n      direction === 'next'\n        ? ES.GetNamedTimeZoneNextTransition(timeZone, thisEpochNanoseconds)\n        : ES.GetNamedTimeZonePreviousTransition(timeZone, thisEpochNanoseconds);\n    return epochNanoseconds === null\n      ? null\n      : ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n  }\n  toInstant(): Return['toInstant'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n  }\n  toPlainDate(): Return['toPlainDate'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalDate(dateTime(this).isoDate, GetSlot(this, CALENDAR));\n  }\n  toPlainTime(): Return['toPlainTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalTime(dateTime(this).time);\n  }\n  toPlainDateTime(): Return['toPlainDateTime'] {\n    ES.CheckReceiver(this, ES.IsTemporalZonedDateTime);\n    return ES.CreateTemporalDateTime(dateTime(this), GetSlot(this, CALENDAR));\n  }\n\n  static from(item: Params['from'][0], optionsParam: Params['from'][1] = undefined): Return['from'] {\n    return ES.ToTemporalZonedDateTime(item, optionsParam);\n  }\n  static compare(oneParam: Params['compare'][0], twoParam: Params['compare'][1]): Return['compare'] {\n    const one = ES.ToTemporalZonedDateTime(oneParam);\n    const two = ES.ToTemporalZonedDateTime(twoParam);\n    const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n    if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return -1;\n    if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2))) return 1;\n    return 0;\n  }\n  [Symbol.toStringTag]!: 'Temporal.ZonedDateTime';\n}\n\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\n\nfunction dateTime(zdt: Temporal.ZonedDateTime) {\n  return ES.GetISODateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, EPOCHNANOSECONDS));\n}\n\nfunction getCalendarProperty<P extends keyof CalendarDateRecord>(\n  zdt: Temporal.ZonedDateTime,\n  prop: P\n): CalendarDateRecord[P] {\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\n  const isoDate = dateTime(zdt).isoDate;\n  return ES.calendarImplForObj(zdt).isoToDate(isoDate, { [prop]: true })[prop];\n}\n\nfunction getTimeProperty(zdt: Temporal.ZonedDateTime, prop: Temporal.TimeUnit) {\n  ES.CheckReceiver(zdt, ES.IsTemporalZonedDateTime);\n  return dateTime(zdt).time[prop];\n}\n","import * as ES from './ecmascript';\n\n// By default, a plain function can be called as a constructor. A method such as\n// Date.prototype.toTemporalInstant should not be able to. We could check\n// new.target in the body of toTemporalInstant, but that is not sufficient for\n// preventing construction when passing it as the newTarget parameter of\n// Reflect.construct. So we create it as a method of an otherwise unused class,\n// and monkeypatch it onto Date.prototype.\n\nclass LegacyDateImpl {\n  toTemporalInstant(this: Date) {\n    const epochNanoseconds = ES.epochMsToNs(Date.prototype.valueOf.call(this));\n    return ES.CreateTemporalInstant(epochNanoseconds);\n  }\n}\n\nexport const toTemporalInstant = LegacyDateImpl.prototype.toTemporalInstant;\n","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\n\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n  Temporal.Instant,\n  Temporal.PlainDate,\n  Temporal.PlainDateTime,\n  Temporal.Duration,\n  Temporal.PlainMonthDay,\n  // Temporal.Now, // plain object (not a constructor), so no `prototype`\n  Temporal.PlainTime,\n  Temporal.PlainYearMonth,\n  Temporal.ZonedDateTime\n];\nfor (const type of types) {\n  const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype') as PropertyDescriptor;\n  if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n    descriptor.configurable = false;\n    descriptor.enumerable = false;\n    descriptor.writable = false;\n    Object.defineProperty(type, 'prototype', descriptor);\n  }\n}\n\nexport { Temporal, Intl, toTemporalInstant };\n"],"names":["ZERO","JSBI","BigInt","ONE","TWO","TEN","TWENTY_FOUR","SIXTY","THOUSAND","MILLION","BILLION","HOUR_NANOS","multiply","MINUTE_NANOS_JSBI","DAY_NANOS_JSBI","ensureJSBI","value","toString","isEven","equal","remainder","abs","x","lessThan","unaryMinus","compare","y","greaterThan","EPOCHNANOSECONDS","ISO_DATE","ISO_DATE_TIME","TIME","CALENDAR","DATE_BRAND","YEAR_MONTH_BRAND","MONTH_DAY_BRAND","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","DATE","YM","MD","INST","ORIGINAL","TZ_CANONICAL","TZ_ORIGINAL","CAL_ID","OPTIONS","INTRINSICS","TruncatingDivModByPowerOf10","xParam","p","div","mod","sign","Math","xDigits","trunc","log10","xStr","toPrecision","Number","parseInt","slice","FMAPowerOf10","zParam","z","repeat","resStr","padStart","GetUnsignedRoundingMode","isNegative","mode","_defineProperty","_customUtilInspectFor","IntlDateTimeFormat","depth","options","inspect","GetSlot","this","_objectSpread","TemporalDuration","descr","stylize","_repr_","props","i","length","prop","TimeDuration","totalNs","_classCallCheck","sec","toNumber","subsec","_createClass","key","add","other","validateNew","days","addToEpochNs","epochNs","divmod","n","operation","MAX","RangeError","concat","fromEpochNsDiff","epochNs2","epochNs1","h","min","s","ms","µs","ns","tzComponent","timeZoneID","RegExp","source","yearpart","monthpart","daypart","datesplit","timesplit","offset","offsetpart","annotation","zoneddatetime","join","time","DAY_MS","DAY_NANOS","MINUTE_NANOS","MS_MAX","NS_MAX","epochMsToNs","NS_MIN","DATETIME_NS_MIN","subtract","DATETIME_NS_MAX","BUILTIN_CALENDAR_IDS","ICU_LEGACY_TIME_ZONE_IDS","Set","IsObject","_typeof","ToNumber","TypeError","ToString","String","ToIntegerWithTruncation","number","isNaN","integer","ToPositiveIntegerWithTruncation","valueParam","property","undefined","ToIntegerIfIntegral","IsIntegralNumber","argument","Infinity","absValue","ToZeroPaddedDecimalString","minLength","RequireString","ToPrimitive","preferredType","result","CALENDAR_FIELD_KEYS","BUILTIN_CASTS","era","eraYear","year","month","monthCode","ToSyntacticallyValidMonthCode","indexOf","day","hour","minute","millisecond","microsecond","nanosecond","ParseDateTimeUTCOffset","timeZone","ToTemporalTimeZoneIdentifier","BUILTIN_DEFAULTS","second","SINGULAR_FOR","Object","fromEntries","TEMPORAL_UNITS","map","e","PLURAL_FOR","_ref","_ref2","_slicedToArray","UNITS_DESCENDING","_ref3","NS_PER_TIME_UNIT","DURATION_FIELDS","OriginalIntlDateTimeFormat","Intl","DateTimeFormat","IntlDateTimeFormatEnUsCache","Map","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","lowercaseIdentifier","ASCIILowercase","instance","get","hour12","set","IsTemporalInstant","item","HasSlot","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalZonedDateTime","CheckReceiver","test","RejectTemporalLikeObject","calendar","FormatCalendarAnnotation","id","showCalendar","processAnnotations","annotations","PARSE","lastIndex","match","exec","_match","critical","calendarWasCritical","ParseISODateTime","isoString","_ref5","_match$","_ref6","_match$2","_match$3","_ref7","_match$4","_ref8","_match$5","_ref9","_match$6","yearString","hasTime","fraction","tzAnnotation","RejectDateTime","_match$7","_ref10","_match$8","_ref11","_match$9","_ref12","_match$10","_ParseISODateTime","_time","RejectTime","_ParseTemporalMonthDa","ParseTemporalMonthDayString","RejectISODate","_unused","_ParseTemporalYearMon","ParseTemporalYearMonthString","_unused2","referenceISODay","_ParseISODateTime2","referenceISOYear","_ParseISODateTime3","TIMEZONE_IDENTIFIER","OFFSET_IDENTIFIER","throwBadTimeZoneStringError","timeZoneString","msg","OFFSET","ParseTimeZoneIdentifier","identifier","offsetMinutes","tzName","yearParam","monthParam","dayParam","overflow","_ConstrainISODate","ConstrainISODate","RegulateTime","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","ConstrainToRange","temporalDurationLike","years","months","weeks","hours","minutes","seconds","milliseconds","microseconds","nanoseconds","any","index","AdjustDateDurationRecord","_ref17","newDays","newWeeks","newMonths","CombineISODateAndTimeRecord","isoDate","GetTemporalOverflowOption","GetOption","GetTemporalDisambiguationOption","fallback","GetTemporalOffsetOption","GetTemporalShowCalendarNameOption","GetTemporalRoundingIncrementOption","increment","roundingIncrement","integerIncrement","ValidateTemporalRoundingIncrement","dividend","inclusive","maximum","GetTemporalFractionalSecondDigitsOption","normalizedOptions","digitsValue","fractionalSecondDigits","digitCount","floor","smallestUnit","precision","unit","pow","REQUIRED","Symbol","GetTemporalUnitValuedOption","unitGroup","allowedSingular","unitInfo","singular","category","defaultVal","requiredOrDefault","push","allowedValues","plural","retval","GetTemporalRelativeToOption","relativeTo","offsetBehaviour","matchMinutes","zonedRelativeTo","plainRelativeTo","CreateTemporalDate","fields","PrepareCalendarFields","GetTemporalCalendarIdentifierWithISODefault","_InterpretTemporalDat","InterpretTemporalDateTimeFields","_ParseISODateTime5","CanonicalizeCalendar","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","DefaultTemporalLargestUnit","duration","LargerOfTwoTemporalUnits","unit1","unit2","IsCalendarUnit","TemporalUnitCategory","calendarImplForID","GetIntrinsic","calendarImplForObj","temporalObj","ISODateToFields","type","arguments","create","calendarDate","isoToDate","bag","extraFieldNames","extraFields","calendarFieldNames","nonCalendarFieldNames","sort","castExists","requiredFields","includes","field","ToTemporalDate","GetOptionsObject","isoDateTime","GetISODateTimeFor","CalendarDateFromFields","ParseTemporalDateString","_ParseTemporalDateStr","ToTemporalDateTime","CreateTemporalDateTime","deltaDays","_InterpretTemporalDat2","_ParseTemporalDateTim","ParseTemporalDateTimeString","ToTemporalDuration","ParseTemporalDurationString","_ParseTemporalDuratio","ParseTemporalDurationStringRaw","every","part","fHours","minutesStr","fMinutes","secondsStr","fSeconds","excessNanoseconds","_ref13","_ref14","_ref15","_ref16","RejectDuration","partial","ToTemporalPartialDurationRecord","ToTemporalInstant","itemParam","CreateTemporalInstant","_ParseTemporalInstant","ParseTemporalInstantString","_ref18$hour","_ref18$minute","_ref18","_ref18$second","_ref18$millisecond","_ref18$microsecond","balanced","_ref18$nanosecond","CheckISODaysRange","GetUTCEpochNanoseconds","ToTemporalMonthDay","IsTemporalMonthDay","CreateTemporalMonthDay","CalendarMonthDayFromFields","_ParseTemporalMonthDa2","ToTemporalTime","CreateTemporalTime","_ToTemporalTimeRecord","ToTemporalTimeRecord","ParseTemporalTimeString","ToTimeRecordOrMidnight","ToTemporalYearMonth","CreateTemporalYearMonth","CalendarYearMonthFromFields","_ParseTemporalYearMon2","RejectYearMonthRange","offsetNs","disambiguation","offsetOpt","matchMinute","GetStartOfDay","dt","GetEpochNanosecondsFor","BalanceISODateTime","ValidateEpochNanoseconds","utcEpochNs","possibleEpochNs","candidate","candidateOffset","roundedCandidateOffset","RoundNumberToIncrement","offsetStr","FormatUTCOffsetNanoseconds","dtStr","ISODateTimeToString","DisambiguatePossibleEpochNanoseconds","ToTemporalZonedDateTime","resolvedOptions","_InterpretTemporalDat3","_ParseTemporalZonedDa","ParseTemporalZonedDateTimeString","CreateTemporalDateSlots","CreateSlots","SetSlot","TemporalPlainDate","prototype","CreateTemporalDateTimeSlots","TemporalPlainDateTime","CreateTemporalMonthDaySlots","RejectDateRange","TemporalPlainMonthDay","CreateTemporalTimeSlots","TemporalPlainTime","TemporalPlainYearMonth","CreateTemporalYearMonthSlots","CreateTemporalInstantSlots","epochNanoseconds","TemporalInstant","CreateTemporalZonedDateTimeSlots","TemporalZonedDateTime","CalendarFieldKeysPresent","filter","CalendarMergeFields","additionalKeys","additionalFields","overriddenKeys","fieldKeysToIgnore","merged","fieldsKeys","ix","propValue","CalendarDateAdd","dateAdd","dateDuration","CalendarDateUntil","dateUntil","isoOtherDate","largestUnit","ToTemporalCalendarIdentifier","calendarLike","_unused4","_unused5","_unused6","_unused7","CalendarEquals","one","two","calendarImpl","resolveFields","dateToISO","monthDayToISOReferenceDate","temporalTimeZoneLike","_ParseTemporalTimeZon2","ParseTemporalTimeZoneStringRaw","_ParseISODateTime4","_unused3","stringIdent","_ParseTemporalTimeZon","ParseTemporalTimeZoneString","FormatOffsetTimeZoneIdentifier","record","GetAvailableNamedTimeZoneIdentifier","TimeZoneEquals","offsetMinutes1","offsetMinutes2","idRecord2","idRecord1","primaryIdentifier","GetOffsetNanosecondsFor","GetNamedTimeZoneOffsetNanoseconds","absoluteNs","subSecondNs","timeString","FormatTimeString","GetISOPartsFromEpoch","_GetISOPartsFromEpoch2","_GetISOPartsFromEpoch3","_GetISOPartsFromEpoch","GetPossibleEpochNanoseconds","numInstants","utcns","dayBefore","offsetBefore","dayAfter","timeDuration","fromComponents","earlierTime","AddTime","BalanceISODate","laterTime","possible","GetNamedTimeZoneEpochNanoseconds","nsEarlier","nsLater","earlierOffsetNs","laterOffsetNs","candidates","offsetNanoseconds","parts","GetNamedTimeZoneDateTimeParts","_GetISOPartsFromEpoch4","epochMilliseconds","_GetISOPartsFromEpoch5","GetFormatterParts","_GetFormatterParts2","CompareISODateTime","GetNamedTimeZoneNextTransition","ISOYearString","ISODateTimePartString","FormatFractionalSeconds","subSecondNanoseconds","replace","TemporalInstantToString","instant","outputTimeZone","dateTimeString","FormatDateTimeUTCOffsetRounded","DurationSign","datePart","timePart","secondsDuration","isZero","secondsPart","subSecondsPart","TemporalDateToString","date","_GetSlot","monthString","dayString","TimeRecordToString","_ref19","_isoDateTime$isoDate","_isoDateTime$time","calendarString","monthDay","_GetSlot2","resultString","TemporalYearMonthToString","yearMonth","_GetSlot3","TemporalZonedDateTimeToString","zdt","RoundTemporalInstant","roundingMode","tz","showOffset","showTimeZone","IsOffsetTimeZoneIdentifier","string","OFFSET_WITH_PARTS","canonicalTimeZoneIdsCache","isTZIDSep","assign","_","_canonicalTimeZoneIds","_specialCases$get","_specialCases$get2","_Intl$supportedValues","_Intl","canonicalTimeZoneIds","supportedValuesOf","call","lower","_unused8","has","_toConsumableArray","c","toUpperCase","split","segments","etcName","specialCases","_GetFormatterParts","GetUTCEpochMilliseconds","GetNamedTimeZoneOffsetNanosecondsImpl","epochNsToMs","absoluteMinutes","offsetNanosecondsParam","_ref20","_ref20$isoDate","_ref20$time","reducedYear","yearCycles","legacyDate","Date","setUTCHours","getTime","MS_IN_400_YEAR_CYCLE","subMs","nanos","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","BEFORE_FIRST_DST","now","leftMs","leftOffsetNs","rightMs","rightOffsetNs","uppercap","epochMs","GetNamedTimeZonePreviousTransition","lookahead","prevBeforeLookahead","UTC","lastPrecomputed","bisect","parseFromEnUsFormat","datetime","splits","isFinite","format","LeapYear","ISODaysInMonth","standard","leapyear","DateDurationSign","fieldNames","InternalDurationSign","dateSign","BalanceISOYearMonth","_BalanceISOYearMonth","daysIn400YearCycle","nCycles","daysInYear","testYear","_BalanceISOYearMonth2","_BalanceISOYearMonth3","BalanceTime","hourParam","_TruncatingDivModByPo","_TruncatingDivModByPo2","DateDurationDays","yearsMonthsWeeksDuration","later","epochDaysEarlier","ISODateToEpochDays","yearsMonthsWeeksInDays","CreateNegatedTemporalDuration","max","RejectToRange","RejectDateTimeRange","AssertISODateTimeWithinLimits","YEAR_MIN","YEAR_MAX","w","d","mon","propSign","msResult","µsResult","nsResult","remainderSec","totalSec","ToInternalDurationRecord","add24HourDays","ToDateDurationRecordWithoutTime","internalDuration","ToInternalDurationRecordWith24HourDays","TemporalDurationFromInternal","CombineDateAndTimeDuration","_ref22","DifferenceTime","time1","time2","DifferenceInstant","ns1","ns2","RoundTimeDuration","DifferenceISODateTime","isoDateTime1","isoDateTime2","timeSign","CompareISODate","adjustedDate","dateDifference","dateLargestUnit","DifferenceZonedDateTime","nsDiff","intermediateDateTime","isoDtStart","isoDtEnd","dayCorrection","maxDayCorrection","intermediateNs","NudgeToCalendarUnit","destEpochNs","r1","r2","startDuration","endDuration","durationParam","yearsMonths","weeksStart","untilResult","startEpochNs","endEpochNs","start","end","startDateTime","endDateTime","numerator","denominator","unsignedRoundingMode","cmp","even","roundedUnit","ApplyUnsignedRoundingMode","total","fdiv","didExpandCalendarUnit","nudgeResult","nudgedEpochNs","NudgeToZonedTime","NegateRoundingMode","arrayFromSet","src","calendarDateWeekOfYear","impl","yow","_calendar$isoToDate","dayOfWeek","dayOfYear","fdow","getFirstDayOfWeek","mdow","getMinimalDaysInFirstWeek","relDow","relDowJan1","woy","weekNumber","firstDayOfWeek","minimalDaysInFirstWeek","desiredDay","periodStartDayOfWeek","weekNo","lastRelDow","week","y1","isoDate2","m1","startsWith","buildMonthCode","leap","leapMarker","digitPart","resolveNonLunisolarMonth","monthsPerYear","ES","numberPart","nonLeapMonthCodeNumberPart","_fields$year","_ES$RegulateISODate","keys","_ref$years","_ref$months","_ref$weeks","_ref$days","_ES$BalanceISOYearMon","_ES$RegulateISODate2","intermediate","candidateYears","ISODateSurpasses","candidateMonths","constrained","requestedFields","daysInWeek","monthsInYear","shiftedMonth","shiftedYear","century","yearInCentury","dow","m","OneObjectCache","cacheToClone","calls","hits","_step","_iterator","_createForOfIteratorHelper","entries","_this$map","entry","MAX_CACHE_ENTRIES","apply","err","f","report","misses","objectMap","obj","getCacheForObject","cache","isoYear","isoMonth","isoDay","simpleDateDiff","WeakMap","HelperBase","getFormatter","formatter","getCalendarParts","dateTimeFormat","locale","isoToCalendarDate","_this","JSON","stringify","func","cached","toUtcIsoDateString","matches","hasEra","normalize","replacement","eras","find","genericName","code","reviseIntlEra","_this$reviseIntlEra","checkIcuBugs","adjustCalendarDate","forEach","keyReverse","monthExtra","_resolveNonLunisolarM","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","keyOriginal","_this2","originalDate","dateParam","_date","estimateIsoDate","diffDays","testIsoEstimate","addDaysIso","isoEstimate","minimumMonthLength","testCalendarDate","roundtripEstimate","diff","diffTotalDaysEstimate","compareCalendarDates","oldRoundtripEstimate","calculateSameMonthResult","oldSign","date1","date2","addedIso","calendarDateParam","absMonths","oldCalendarDate","daysInPreviousMonth","daysInMonth","monthsInOldYear","regulateDate","addCalendar","_ref4","_ref4$years","_ref4$months","_ref4$weeks","_ref4$days","addedYears","addedMonths","addMonthsCalendar","addDaysCalendar","initialDays","calendarTwo","calendarDaysUntil","calendarOne","totalDays","diffYears","diffInYearSign","current","next","addedIsoDate","addedCalendarDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","startOfCalendarMonth","oneIso","twoIso","monthDayFromFields","closestCalendar","_this$isoToCalendarDa","monthDaySearchStartYear","startDateIso","calendarYear","calendarOfStartDateIso","roundTripCalendarDate","maxDayForMonthCode","closestIso","HebrewHelper","_HelperBase","_inherits","_super","_createSuper","_this3","regular","Kislev","Tevet","Nisan","Iyar","Sivan","Tamuz","Elul","minMaxMonthLength","minOrMax","monthInfo","maxLengthOfMonthCodeInAnyYear","inLeapYear","fromLegacyDate","getMonthCode","validateCalendarDate","endsWith","IslamicBaseHelper","_HelperBase2","_super2","_this4","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","startOfYearCalendar","startOfNextYearCalendar","IslamicHelper","_IslamicBaseHelper","_super3","_this5","IslamicUmalquraHelper","_IslamicBaseHelper2","_super4","_this6","IslamicTblaHelper","_IslamicBaseHelper3","_super5","_this7","IslamicCivilHelper","_IslamicBaseHelper4","_super6","_this8","IslamicRgsaHelper","_IslamicBaseHelper5","_super7","_this9","IslamicCcHelper","_IslamicBaseHelper6","_super8","_this10","_HelperBase3","PersianHelper","_super9","_this11","calendarType","IndianHelper","_HelperBase4","_super10","_this12","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","_monthInfo$leap","GregorianBaseHelperFixedEpoch","_HelperBase5","_super11","isoEpoch","_this13","GregorianBaseHelper","_HelperBase6","_super12","originalEras","_this14","_adjustEras","adjustEras","erasParam","anchorEra","reverseOf","isAnchor","anchorEpoch","hasYearZero","reversedEra","e1","e2","lastEraReversed","completeEraYear","_this15","checkField","names","currentValue","preferredName","expected","eraFromYear","adjustedCalendarDate","matchingEra","eraNames","matchData","_ref5$names","_eraFromYear","_calendarDate3","SameMonthDayAsGregorianBaseHelper","_GregorianBaseHelper","_super13","OrthodoxOps","OrthodoxBaseHelperFixedEpoch","_GregorianBaseHelperF","_super14","_this16","OrthodoxBaseHelper","_GregorianBaseHelper2","_super15","_this17","_OrthodoxBaseHelperFi","EthioaaHelper","_super16","CopticHelper","_OrthodoxBaseHelper","_super17","EthiopicHelper","_OrthodoxBaseHelper2","_super18","_SameMonthDayAsGregor","RocHelper","_super19","BuddhistHelper","_GregorianBaseHelperF2","_super20","GregoryHelper","_SameMonthDayAsGregor2","_super21","JapaneseHelper","_SameMonthDayAsGregor3","_super22","_this18","ChineseBaseHelper","_HelperBase7","_super23","_this19","getMonthList","_monthMap$monthCode","M02L","M04L","M05L","M06L","M07L","M08L","M09L","M10L","M11L","M12L","_this20","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","formatToParts","calendarMonthString","tv","calendarDay","calendarYearPartToVerify","slot","val","ResetSlot","LOCALE","IsPatchedDateTimeFormat","DateTimeFormatImpl","locales","createDateTimeFormat","dtf","optionsParam","hasOptions","ToObject","newOptions","hasOwnProperty","original","ro","clonedResolved","hourCycle","dateAmend","yearMonthAmend","monthDayAmend","TIME_FMT","timeAmend","DATETIME","datetimeAmend","instantAmend","timeZoneOption","boundFormat","bind","defineProperties","enumerable","writable","configurable","name","formatRange","a","b","_len","rest","Array","_key","formatRangeToParts","resolved","overrides","extractOverrides","formatArgs","_len2","_formatter","_formatter2","_len3","_key3","aParam","bParam","_formatter3","toDateTimeFormattable","isTemporalObject","sameTemporalType","_extractOverrides","aa","aformatter","_extractOverrides2","bb","_formatter4","_extractOverrides3","_extractOverrides4","amend","amended","opt","originalOptions","weekday","timeZoneName","dateStyle","timeStyle","hasTimeOptions","hasAnyDateTimeOptions","dayPeriod","style","short","medium","long","full","hasDateOptions","defineProperty","supportedLocalesOf","MakeIntrinsicClass","Instant","since","roundToParam","roundTo","otherParam","digits","_ES$ToSecondsStringPr","toLocaleString","timeZoneParam","fromEpochMilliseconds","epochNanosecondsParam","from","oneParam","twoParam","PlainDate","calendarParam","getCalendarProperty","_getCalendarProperty","_getCalendarProperty2","temporalDateLike","withCalendar","valueOf","temporalTime","toZonedDateTime","timeZoneLike","plainTime","PlainDateTime","getTimeProperty","_with","temporalDateTimeLike","until","round","Duration","yearsParam","monthsParam","weeksParam","hoursParam","minutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","daysParam","durationLike","partialDuration","_partialDuration$year","_partialDuration$mont","_partialDuration$week","_partialDuration$days","_partialDuration$hour","_partialDuration$minu","_partialDuration$seco","_partialDuration$mill","_partialDuration$micr","_partialDuration$nano","_ES$GetTemporalRelati","smallestUnitPresent","defaultLargestUnit","largestUnitPresent","relativeEpochNs","targetTime","isoRelativeToDate","targetDate","existingLargestUnit","quotient","_internalDuration$tim","_ES$GetTemporalRelati2","PlainMonthDay","temporalMonthDayLike","equals","toJSON","toPlainDate","SystemDateTime","Now","plainDateTimeISO","plainDateISO","plainTimeISO","timeZoneId","zonedDateTimeISO","toStringTag","PlainTime","isoHour","isoMinute","isoSecond","isoMillisecond","isoNanosecond","isoMicrosecond","temporalTimeLike","partialTime","_Object$assign","_ES$RegulateTime","PlainYearMonth","temporalYearMonthLike","ZonedDateTime","_ES$ParseTimeZoneIden","today","dateTime","tomorrow","todayNs","tomorrowNs","temporalZonedDateTimeLike","newOffsetNs","newDateTime","iso","temporalTimeParam","thisNs","dateEnd","dateStart","startNs","endNs","dayLengthNs","roundedDateTime","GetTemporalShowOffsetOption","CopyDataProperties","excludedKeys","excludedValues","Reflect","ownKeys","_loop","nextKey","some","is","propertyIsEnumerable","target","optionsCopy","localeCalendarIdentifier","customResolvedOptions","calendarIdentifier","startOfDay","GetDirectionOption","toTemporalInstant","LegacyDateImpl","Temporal","_i","_types","descriptor","getOwnPropertyDescriptor"],"mappings":"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"}